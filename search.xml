<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 食用说明</title>
    <url>/1992/06/21/Github-Pages_Hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p><strong>部署环境</strong>：</p>
<ul>
<li>windows </li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Github Pages<a href="https://docs.github.com/en/github/working-with-github-pages/about-github-pages">(more)</a></p>
</blockquote>
<p>可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p>
<p>使用github pages服务搭建博客的好处有：</p>
<pre><code>全是静态文件，访问速度快；
免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；
可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；
数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；
博客内容可以轻松打包、转移、发布到其它平台；
等等
</code></pre>
<blockquote>
<p>Hexo<a href="https://hexo.io/zh-cn/index.html">(more)</a></p>
</blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="github账号"><a href="#github账号" class="headerlink" title="github账号"></a>github账号</h3><p><a href="https://github.com/">点击此处</a>访问 Github 官网，点击 Sign Up 注册账户</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p><a href="https://nodejs.org/en/download/">点击此处</a>访问官网，按需下载相应版本，默认安装可以了</p>
<blockquote>
<p>检验安装：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<blockquote>
<p>npm的镜像源：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看npm的配置</span><br><span class="line">npm config list</span><br><span class="line"># 默认源</span><br><span class="line">npm config set registry https://registry.npmjs.org</span><br><span class="line"># 临时改变镜像源</span><br><span class="line">npm --registry=https://registry.npm.taobao.org</span><br><span class="line"># 永久设置为淘宝镜像源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"># 另一种方式，编辑 ~/.npmrc 加入下面内容</span><br><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h3 id="安装GIT"><a href="#安装GIT" class="headerlink" title="安装GIT"></a>安装GIT</h3><p><a href="https://git-scm.com/downloads"><img src="https://git-scm.com/images/logo@2x.png" alt="git install" title="Downloads"></a></p>
<blockquote>
<p>检验安装：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置Git个人信息</p>
</blockquote>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>首先选择一个磁盘作为你博客文件的存放位置（例：<code>D:\DevStudyCode</code>），然后新建一个文件夹，比如名为 <code>D:\DevStudyCode\hexo</code> 的文件夹，创建完后，先不要点进去，在此处点击鼠标右键，选择<code>Git Bash Here</code>，然后依次输入如下命令，：</p>
<h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo框架的安装</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"># 等上一个命令完成后，初始化文件夹</span><br><span class="line">hexo init &lt;新建文件夹的名称&gt;</span><br><span class="line">cd &lt;新建文件夹的名称&gt;</span><br><span class="line"># npm install 安装博客所需要的依赖文件</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>执行以下命令，执行完即可登录 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate  </span><br><span class="line">hexo server  </span><br></pre></td></tr></table></figure>

<h3 id="保留CNAME、README-md等文件"><a href="#保留CNAME、README-md等文件" class="headerlink" title="保留CNAME、README.md等文件"></a>保留CNAME、README.md等文件</h3><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：</p>
<p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p>
<h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #根据配置文件渲染出一套静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<p>缩写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<p>组合命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>

<h2 id="将博客部署到Github-Pages"><a href="#将博客部署到Github-Pages" class="headerlink" title="将博客部署到Github Pages"></a>将博客部署到Github Pages</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>新建一个名为<code>你的用户名</code>.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（**<code>必须是你的用户名，其它名称无效</code>**），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>注册的邮箱一定要验证，否则不会成功；</li>
<li>仓库名字必须是：username.github.io，其中username是你的用户名；</li>
<li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li>
</ul>
<h3 id="ssh公钥添加到GitHub"><a href="#ssh公钥添加到GitHub" class="headerlink" title="ssh公钥添加到GitHub"></a>ssh公钥添加到GitHub</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>

<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容<br>打开你的github主页，进入个人设置 -&gt;<code>SSH and GPG keys -&gt; New SSH key</code>：</p>
<p>本地测试配置是否生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure>

<h3 id="将本地hexo文件更新到Github库"><a href="#将本地hexo文件更新到Github库" class="headerlink" title="将本地hexo文件更新到Github库"></a>将本地hexo文件更新到Github库</h3><p>进入博客站点目录，我的是<code>D:\DevStudyCode\hexo</code>，用文本编辑器打开_config.yml，这个_config.yml 是博客的配置文件，在以后的博客修改，如个性化修改，博客 SEO 优化等都会使用到，修改如下图的几个地方：</p>
<pre><code>title: 你的博客名
subtitle: 博客的副标题，有些主题支持
description: 博客描述
keywords: 博客关键词
author: 作者，在文章中显示
language: 博客语言语种   
timezone: 时区
</code></pre>
<p>到文件最底部，有一个 deploy，在 deploy 下面添加一个 repo 项 ，一个 branch 项。填入如下代码，并如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: git@github.com:Github用户名/github用户名.github.io.git</span><br><span class="line">//也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<p><strong>发布至 Github Pages</strong>：<br>在<code>Hexo</code>目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hexo会根据配置文件渲染出一套静态页面</span><br><span class="line">hexo g</span><br><span class="line"># 将上一步渲染出的一系列文件上传至至Github Pages</span><br><span class="line">hexo d</span><br><span class="line"># 也可以直接输入此命令，直接完成渲染和上传</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p><strong>访问博客</strong>：<br>你的博客地址：https://你的用户名.github.io</p>
<h1 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h1><p><strong>关于主题修改</strong>(美化)：<br>由于不同主题的配置方法都是存在差异的，如果想进行修改，请参考对应作者的Github。<br>下面是一些通用的配置方法，可以作为参考</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul>
<li>链接：<a href="https://hexo.io/themes/">官方主题</a></li>
</ul>
<p><strong>步骤参考</strong>：<br>首先下载这个主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># D:\DevStudyCode\hexo右键选择Git Bash Here，进入到hexo目录</span><br><span class="line"></span><br><span class="line">git clone https://github.com/litten/hexo-theme-matery.git themes/matery</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<br>需要明白什么是站点配置文件，什么是主题配置文件，站点配置文件就是根目录下的配置文件，比如我的博客文件在 <code>D:\DevStudyCode\hexo</code> 下，那么站点配置文件就是<code>D:\DevStudyCode\hexo\_config.yml</code>，主题配置文件就<code>D:\DevStudyCode\hexo\themes\matery\_config.yml</code>。</p>
</blockquote>
<p>主题下载完成后，将站点配置文件<code>_config.yml</code>中的 <code>theme: landscape</code>修改为你下载主题的文件名<code>theme: matery</code>，然后重新执行<code>hexo g</code>来重新生成。。另外，配置文件中的<code>标点符号不要出现中文格式</code>，不然运行会出错。</p>
<p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p>
<p><strong>一些站点配置文件的其他地方的修改：</strong></p>
<ul>
<li>语言选择：如果为中文用户，则在 language: 后添加值 zh-CN，如果不修改，默认为英语；</li>
<li>网址修改：url: 的值为你的网址名，如 <a href="http://xxxx.github.io,如果有域名,则修改为你的域名即可,至于有关域名的修改解析,后面我会说到,这里先不说了./">http://xxxx.github.io，如果有域名，则修改为你的域名即可，至于有关域名的修改解析，后面我会说到，这里先不说了。</a></li>
<li>站点配置文件有个 per_page属性，建议修改为 6 的倍数，这样网站在适应设备时，有较好的显示效果。</li>
</ul>
<h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><p><strong>标签 tags 页面</strong><br><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-09-30 18:23:38</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><strong>分类 categories 页面</strong><br><code>categories</code> 页是用来展示所有分类的页面，配置方法参考<code>tags</code>页面</p>
<p><strong>关于我 about 页面</strong><br><code>about</code> 页是用来展示关于我和我的博客信息的页面，配置方法参考<code>tags</code>页面</p>
<h2 id="DIY"><a href="#DIY" class="headerlink" title="DIY"></a>DIY</h2><h3 id="页面添加樱花飘落效果"><a href="#页面添加樱花飘落效果" class="headerlink" title="页面添加樱花飘落效果"></a>页面添加樱花飘落效果</h3><blockquote>
<p>非通用，配置前请备份，如果主题不支持，方便还原。</p>
</blockquote>
<p>在 <code>themes/matery/source/js</code> 目录下新建 <code>sakura.js</code> 文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.3.4/source/js/sakura.js">传送门</a>，将内容复制粘贴到 <code>sakura.js</code> 即可。<br>然后再 <code>themes/matery/layout/layout.ejs</code> 文件内添加下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//只在桌面版网页启用特效</span><br><span class="line">var windowWidth = $(window).width();</span><br><span class="line">if (windowWidth &gt; 768) &#123;</span><br><span class="line">    document.write(&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/sakura.js&quot;&gt;&lt;\/script&gt;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p>参考<a href="https://itrhx.blog.csdn.net/article/details/82121420?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">Hexo个性域名</a><br>不绑定域名情况下，默认使用<code>xxx.github.io</code>来访问</p>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--https://blog.csdn.net/qq_43729277/article/details/112168073-->  
<!--https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html-->  
<!--https://dp2px.com/2019/04/25/hexo-meihua/#comments-->  
<!--http://www.hiekay.com/2018/10/17/Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2hexo%E8%AE%BE%E7%BD%AE%E5%85%B3%E4%BA%8E%E3%80%81%E6%A0%87%E7%AD%BE%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%BD%92%E6%A1%A3%E3%80%81%E6%97%B6%E9%97%B4%E7%BA%BF/-->  

]]></content>
      <categories>
        <category>吃喝玩乐</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言介绍</title>
    <url>/2020/01/31/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="http://wen.topgoer.com/docs/golang/golang-1ccjbpfstsfi1">go语言中文文档</a></li>
<li><a href="https://www.liwenzhou.com/posts/Go/about_golang/">李文周的博客</a></li>
</ul>
<hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong><code>Google开发的开源编程语言</code></strong><br>诞生于2006年1月2日下午15点4分5秒，于2009年11月开源，2012年发布go稳定版。Go语言在多核并发上拥有原生的设计优势，Go语言从底层原生支持并发，<code>无须第三方库</code>、开发者的编程技巧和开发经验。<br>它的主要目标是“兼具Python 等动态语言的开发速度和C/C++等编译型语言的性能与安全性”</p>
<p><strong><code>Go语言为并发而生</code></strong> ——21世纪的C语言<br>硬件制造商正在为处理器添加越来越多的内核以提高性能。所有数据中心都在这些处理器上运行，更重要的是，今天的应用程序使用多个微服务来维护数据库连接，消息队列和维护缓存。因此，开发的软件和编程语言应该可以轻松地支持并发性，并且应该能够随着CPU核心数量的增加而可扩展。</p>
<p>但是，大多数现代编程语言（如Java，Python等）都来自90年代的单线程环境。虽然一些编程语言的框架在不断地提高多核资源使用效率，例如 Java 的 Netty 等，但仍然需要开发人员花费大量的时间和精力搞懂这些框架的运行原理后才能熟练掌握。</p>
<p>Go于2009年发布，当时多核处理器已经上市。Go语言在多核并发上拥有原生的设计优势，Go语言从底层原生支持并发，无须第三方库、开发者的编程技巧和开发经验。</p>
<p>很多公司，特别是中国的互联网公司，即将或者已经完成了使用 Go 语言改造旧系统的过程。经过 Go 语言重构的系统能使用更少的硬件资源获得更高的并发和I/O吞吐表现。充分挖掘硬件设备的潜力也满足当前精细化运营的市场大环境。</p>
<p>Go语言的并发是基于 <code>goroutine</code> 的，<code>goroutine</code> 类似于线程，但并非线程。可以将 <code>goroutine</code> 理解为一种虚拟线程。Go 语言运行时会参与调度 <code>goroutine</code>，并将 <code>goroutine</code> 合理地分配到每个 CPU 中，最大限度地使用CPU性能。开启一个<code>goroutine</code>的消耗非常小（大约2KB的内存），你可以轻松创建数百万个<code>goroutine</code>。</p>
<p><code>goroutine</code>的特点：</p>
<ol>
<li><code>goroutine</code>具有可增长的分段堆栈。这意味着它们只在需要时才会使用更多内存。</li>
<li><code>goroutine</code>的启动时间比线程快。</li>
<li><code>goroutine</code>原生支持利用channel安全地进行通信。</li>
<li><code>goroutine</code>共享数据结构时无需使用互斥锁。</li>
</ol>
<p><strong><code>编译型语言</code></strong><br>与其他现代高级语言（如Java/Python）相比，使用C，C++的最大好处是它们的性能。因为C/ C++是编译型语言而不是解释的语言。 处理器只能理解二进制文件，Java和Python这种高级语言在运行的时候需要先将人类可读的代码翻译成字节码，然后由专门的解释器再转变成处理器可以理解的二进制文件。<br><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/03/15511649241043.jpg?x-oss-process=style/original_format"></p>
<p>同C,C++一样，Go语言也是编译型的语言，它直接将人类可读的代码编译成了处理器可以直接运行的二进制文件，执行效率更高，性能更好。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>语法简洁</strong><br>Go 语言简单易学，学习曲线平缓，不需要像 C/C++ 语言动辄需要两到三年的学习期。Go 语言被称为“互联网时代的C语言”。Go 语言的风格类似于C语言。其语法在C语言的基础上进行了大幅的简化，去掉了不需要的表达式括号，循环也只有 for 一种表示方法，就可以实现数值、键值等各种遍历。</p>
<p><strong>代码风格统一</strong><br>Go 语言提供了一套格式化工具——go fmt。一些 Go 语言的开发环境或者编辑器在保存时，都会使用格式化工具进行修改代码的格式化，这样就保证了不同开发者提交的代码都是统一的格式。(吐槽下：再也不用担心那些看不懂的黑魔法了…)</p>
<p><strong>开发效率高</strong><br>Go语言实现了开发效率与执行效率的完美结合，让你像写Python代码（效率）一样编写C代码（性能）。</p>
<h2 id="Go的使用场景"><a href="#Go的使用场景" class="headerlink" title="Go的使用场景"></a>Go的使用场景</h2><p>目前Go语言已经⼴泛应用于人工智能、云计算开发、容器虚拟化、⼤数据开发、数据分析及科学计算、运维开发、爬虫开发、游戏开发等领域。</p>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!---->  
<!---->  

]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>好用的Markdown编辑器 —— Pad2 和 Typora</title>
    <url>/2018/04/21/Pad2%E5%92%8CTypora/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>前言：<br><del>选用“<a href="http://markdownpad.com/">MarkdownPad 2</a>”作为文档编写工具的原因：方便，支持实时预览</del>。<br><strong>[更新]：<code>目前已经由”MarkdownPad 2“转用”Typora“，但本文内容仍然有效</code>。</strong></p>
</blockquote>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/markdown/markdownpad2.png?x-oss-process=style/watermark" alt="md pad 2"></p>
<hr>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><ul>
<li>MarkdownPad 2 的官网下载地址： <a href="http://markdownpad.com/">http://markdownpad.com/</a></li>
<li>个人网盘下载（附激活码），点击【<a href="https://pan.baidu.com/s/1Aym5-XRNMuWupvOTIdFHNA">链接</a>】， 提取码：ib02 </li>
</ul>
<h2 id="2-破解"><a href="#2-破解" class="headerlink" title="2. 破解"></a>2. 破解</h2><p>安装完毕后，首次启动提示激活，如下图：点击<code>”Enter Key“</code> —&gt; 键入<code>”Email address“</code>和<code>”License key“</code></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/markdown/mdpad2_enterkey.png?x-oss-process=style/watermark" alt="mdpad2_enterkey"></p>
<h2 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h2><h3 id="3-1-http渲染"><a href="#3-1-http渲染" class="headerlink" title="3.1 http渲染"></a>3.1 http渲染</h3><p><strong>安装激活后提示</strong>：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/markdown/erro_html_readering.png?x-oss-process=style/watermark" alt="erro_html_readering"></p>
<p><strong>解决方案</strong>：<br>安装一个SDK的工具包，【<a href="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe">点击获取</a>】，重启pad2即可。</p>
<h3 id="3-2-PDF格式转换"><a href="#3-2-PDF格式转换" class="headerlink" title="3.2 PDF格式转换"></a>3.2 PDF格式转换</h3><p><strong>问题描述</strong>：<br>”.md“文件中包含”https“的图片链接，通过Mdpad2可以进行预览展示，但使用Mdpad2将其导出为“pdf”文件后，包含”https“的图片链接无法通过”pdf“显示。如果你没有导出需求，可以忽略该问题。</p>
<p><strong>解决方案</strong>：<br>可以考虑结合使用”<a href="https://www.typora.io/">Typora</a>“进行转换，它也是一款Markdown编辑器，轻便简洁，支持即时渲染技术。</p>
<p>或者。。。直接放弃”MarkdownPad 2“转而使用”Typora“，这两种MarkDown编辑器都比较亲民。</p>
<pre><code>”MarkdownPad 2“有左右两个分页窗口，实时预览效果比较好。
”Typora“刚刚使用，给我的感觉就是简洁，自定义功能较多。
</code></pre>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--  https://blog.csdn.net/xiaojin21cen/article/details/78752561  -->  
<!--  https://blog.csdn.net/kuangay/article/details/79854665  -->  

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible的配置文件</title>
    <url>/2019/06/06/ansible.cfg/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Ansible的配置文件-more"><a href="#Ansible的配置文件-more" class="headerlink" title="Ansible的配置文件(more)"></a>Ansible的配置文件(<a href="https://ansible-tran.readthedocs.io/en/latest/docs/intro_configuration.html#ansible">more</a>)</h2><p>Ansible的一些的设置可以通过配置文件完成.在大多数场景下默认的配置就能满足大多数用户的需求,在一些特殊场景下,用户还是需要自行修改这些配置文件</p>
<h2 id="读取配置文件的优先级"><a href="#读取配置文件的优先级" class="headerlink" title="读取配置文件的优先级"></a>读取配置文件的优先级</h2><p>ansible的默认配置文件是/etc/ansible/ansible.cfg。其实ansible会按照下面的顺序查找配置文件，并<code>使用第一个发现的</code>配置文件。</p>
<ul>
<li>ANSIBLE_CONFIG (an environment variable)</li>
<li>ansible.cfg (in the current directory)</li>
<li>.ansible.cfg (in the home directory)</li>
<li>/etc/ansible/ansible.cfg</li>
</ul>
<p><strong>V1.5以前的版本顺序为：</strong></p>
<ul>
<li>ansible.cfg (in the current directory)</li>
<li>ANSIBLE_CONFIG (an environment variable)</li>
<li>.ansible.cfg (in the home directory)</li>
<li>/etc/ansible/ansible.cfg</li>
</ul>
<h2 id="配置选项详解"><a href="#配置选项详解" class="headerlink" title="配置选项详解"></a>配置选项详解</h2><p>到目前为止，我还没有见到一个配置项超级少，配置超级简单的配置文件；同样的，Ansible的配置文件也不简单，配置项超级多；但是，二八法则同样也适用于这些配置文件，20%的配置项决定了80%的功能，只有那20%的配置项是我们需要去关心的。所以，大家不要害怕，下面我们就将这20%常用的选项进行一一说明和总结。</p>
<h3 id="defaults配置"><a href="#defaults配置" class="headerlink" title="defaults配置"></a>defaults配置</h3><p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/05/asb_conf.png?x-oss-process=style/original_format"></p>
<h3 id="privilege-escalation配置"><a href="#privilege-escalation配置" class="headerlink" title="privilege_escalation配置"></a>privilege_escalation配置</h3><table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">become</td>
<td align="left">是否开启become模式</td>
<td align="left">True</td>
</tr>
<tr>
<td align="left">become_method</td>
<td align="left">定义become方式</td>
<td align="left">sudo</td>
</tr>
<tr>
<td align="left">become_user</td>
<td align="left">定义become方式</td>
<td align="left">root</td>
</tr>
<tr>
<td align="left">become_ask_pass</td>
<td align="left">是否定义become提示密码</td>
<td align="left">False</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>env</tag>
        <tag>ansible基础</tag>
      </tags>
  </entry>
  <entry>
    <title>使用oss来存取及优化图片资源</title>
    <url>/2019/09/08/aliyun_oss_save_img/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>前言：  </p>
</blockquote>
<p>在日常开发中，不免会遇到需要实现图片上传与展示的需求。比如一个文章发布系统，我们通常会开发图片上传功能，让用户可以为自己的文章提供配图；而且图片上传后，还需要生成不同尺寸的缩略图，供文章列表等不同场景界面展示用。</p>
<p>做过类似功能的朋友肯定熟悉传统的做法：</p>
<ol>
<li>首先，通过文件上传组件将图片文件通过POST请求发送到服务器端</li>
<li>然后，当服务器端接受到上传的图片数据后，写入本地磁盘或分布式文件系统，将图片文件保存在特定文件夹中</li>
<li>接着，服务端在将图片原图保存成文件的同时，调用图片处理服务（例如ImageMagic）对原图进行裁剪、压缩等处理，生成需要的缩略图文件，和原图一并保存</li>
<li>最后，将原图和缩略图的文件路径信息保存在数据库中，供后续展示之用</li>
</ol>
<p>这套典型的图片上传处理流程，是作为一个合格的开发者所必须了解的必备基础知识。但是，在这一系列环节中，我们可能需要自己配置搭建高可用的文件系统，编写各种图片处理代码，还是颇费时间的。在如今讲究开发效率、快速开发产品原型、快速迭代的理念和环境下，如何利用现成服务来实现产品的功能并缩短开发周期，也是一个很有价值的事情，而且选用一个质量比较好的现成服务，可能比你自己开发一个类似功能要来得更加稳定，这也能间接的提升你产品的用户体验。</p>
<p>针对前面提到的这块图片上传处理功能，其实有很多云平台提供了方便的文件存储和图片处理服务，比如阿里云的OSS、腾讯云的COS、七牛云存储等等。而且这类云存储的价格也比较便宜，可以单独购买使用，也可以搭配云主机等搭建整体服务上云方案。</p>
<p>下面我就基于我自己使用阿里云OSS的经验，来介绍一下主要的开发使用流程。阿里云OSS（即Object Storage Service，对象存储服务）提供基于网络的数据存取服务，可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种非结构化数据文件，它将数据文件以对象的形式上传到存储空间中。我们可以对其进行以下几类操作：</p>
<ul>
<li>创建一个或者多个存储空间，向每个存储空间中添加一个或多个文件</li>
<li>通过获取已上传文件的地址进行文件的分享和下载</li>
<li>通过修改存储空间或文件的属性或元信息来设置相应的访问权限</li>
<li>在阿里云管理控制台执行基本和高级OSS任务</li>
<li>使用阿里云开发工具包或直接在应用程序中进行RESTful API调用执行基本和高级OSS任务</li>
<li>当然，如果你使用的是别的云存储服务，也可以作为参考，因为它们的理念和使用方法都是非常接近的。</li>
</ul>
<hr>
<h2 id="1-开通阿里云OSS，并创建存储空间"><a href="#1-开通阿里云OSS，并创建存储空间" class="headerlink" title="1. 开通阿里云OSS，并创建存储空间"></a>1. 开通阿里云OSS，并创建存储空间</h2><p>如果你还没阿里云账号的话，可以先去<a href="https://www.aliyun.com/">注册一个账号</a>，然后再从首页的左侧菜单树中找到<code>对象存储OSS</code>服务，点击并根据提示开通服务后，自动跳转到控制台。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/2a58de9b-d8a3-4a55-b487-c14acf707d90.png?x-oss-process=style/watermark" alt="oss"></p>
<p>进入OSS管理控制台，你需要先创建一个<code>Bucket</code>，这个存储空间相当于是你在阿里云OSS上的专属磁盘空间。在创建时，指定存储类型为<code>标准存储</code>，读写权限为<code>公共读</code>：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/b65c0a1d-882c-45f6-bdef-b8c48d508cdc.png?x-oss-process=style/watermark" alt="oss"></p>
<p>至此，你的第一个存储空间就创建完成了。（此外，根据存储方式的不同，收费也不一样，这需要根据<a href="https://www.aliyun.com/price/product?spm=5176.8465980.0.0.32df1450t4ZWZq&/oss/detail#/oss/detail">收费标准</a>及自身需求做决定。）</p>
<hr>
<h2 id="2-图片上传及处理"><a href="#2-图片上传及处理" class="headerlink" title="2. 图片上传及处理"></a>2. 图片上传及处理</h2><h3 id="2-1-图片上传"><a href="#2-1-图片上传" class="headerlink" title="2.1 图片上传"></a>2.1 图片上传</h3><p>选择你的<code>bucket</code> =》点击<code>文件管理</code> =》点击<code>新建目录</code>（自定义创建，便于分类） =》进入目录并点击<code>上传文件</code></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/be40ba6b-dc70-47ea-98a4-cb30a18990fe.png?x-oss-process=style/watermark" alt="oss"></p>
<p>如图所示， 我在新建”md/“目录下上传了一个文件-”头像.jpg“</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/e5a2942f-df09-451a-bcc8-874fc0ce3b2d.png?x-oss-process=style/watermark" alt="oss"></p>
<p>点击文件<code>详情</code>，可以获取到上传的文件的可访问URL路径，在你的网页或app应用中可以直接使用该URL路径来访问这些文件，但是出于安全和其他自定义需求的考虑，最好进行<code>图片处理</code>。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/64661586-b465-411e-9c03-72832908ce0a.png?x-oss-process=style/watermark" alt="oss"></p>
<h3 id="2-2-图片处理"><a href="#2-2-图片处理" class="headerlink" title="2.2 图片处理"></a>2.2 图片处理</h3><p>能方便的进行批量图片文件处理，是我们使用云存储服务的一个重要原因。<br>阿里云OSS提供了比较丰富的图片处理功能，比如图像裁剪、缩放、转格式、加水印、调整图片质量等等。</p>
<p>在OSS管理控制台的<code>图片处理</code>页面，可以按自己的需要来<code>新建样式</code>，其实它就是一套描述图片处理方式的规则配置。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/2b9a418e-4815-4809-a604-133849bd55ce.png?x-oss-process=style/watermark" alt="oss"></p>
<p>点击<code>新建样式</code>弹出以下配置界面：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/ys_20190919171605.png?x-oss-process=style/watermark" alt="oss"></p>
<p>创建完的这个样式名称为<code>watermark</code>。然后我们怎么来使用它呢？非常简单，只需要在访问原图的URL后面加上特定的参数即可：</p>
<ul>
<li><p>原图url<br><a href="https://mrgao.oss-cn-beijing.aliyuncs.com/md/%E5%A4%B4%E5%83%8F.jpg">https://mrgao.oss-cn-beijing.aliyuncs.com/md/%E5%A4%B4%E5%83%8F.jpg</a></p>
</li>
<li><p>使用了图片样式<code>watermark</code>的URL：<br><a href="https://mrgao.oss-cn-beijing.aliyuncs.com/md/%E5%A4%B4%E5%83%8F.jpg?x-oss-process=style/watermark">https://mrgao.oss-cn-beijing.aliyuncs.com/md/%E5%A4%B4%E5%83%8F.jpg?x-oss-process=style/watermark</a></p>
</li>
</ul>
<p>如果觉得后缀的参数有点长，则可以点击<code>访问设置</code>再配置一下自定义分隔符，简化url后缀参数（不建议使用此法，可能在一些场景出现图片展示不全的情况）：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/f1c50c0d-b048-438e-b483-325f0137af72.png?x-oss-process=style/watermark" alt="oss"></p>
<ul>
<li>配置<code>访问设置</code>后：<br><a href="https://mrgao.oss-cn-beijing.aliyuncs.com/md/%E5%A4%B4%E5%83%8F.jpg!watermark">https://mrgao.oss-cn-beijing.aliyuncs.com/md/%E5%A4%B4%E5%83%8F.jpg!watermark</a></li>
</ul>
<p><strong>原图保护</strong>：  </p>
<pre><code>开启原图包含后，存储在bucket中的源文件是不能被直接访问的，只能通过传入 stylename 和带签名的方式访问；将禁止直接访问 OSS 原文件或传入图片参数修改图片样式的访问。
</code></pre>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/oss/cdbfd863-6595-46e9-99b6-71e83da25c03.png?x-oss-process=style/watermark" alt="oss"></p>
<p><strong>可正常访问的url规则：</strong>  </p>
<ul>
<li>默认规则：域名/sample.jpg?x-oss-process=style/stylename</li>
<li>自定义规则：域名/sample.jpg自定义分隔符stylename</li>
</ul>
<hr>
<!--  https://www.jianshu.com/p/8b19a7416549  -->  

]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible中的幂等性</title>
    <url>/2019/07/06/ansible_Idempotency/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>幂等性（Idempotency）</p>
</blockquote>
<p>幂等性是数学和计算机科学上一个常见的概念，多次执行产生的结果不会发生改变，这样的特性就被成为幂等性。幂等性是Idempotency的中文翻译，幂在数学上表示乘方结果，乘方的结果相等可以简洁地描述多次执行后得到相同结果这一概念的意思。</p>
<h2 id="ansible中的幂等性"><a href="#ansible中的幂等性" class="headerlink" title="ansible中的幂等性"></a>ansible中的幂等性</h2><p>ansible中绝大多数的模块都具有幂等特性，意味着执行一次或多次不会产生副作用。但是<code>shell、command、script、raw</code>这四个模块时不满足幂等性，所有操作会重复执行，但是有些操作不允许重复执行，比如MySQL的初始化命令mysql_install_db，逻辑上它只在第一次配置的过程中初始化一次，其他任何时候都不应该再执行。所有，每当使用这四个模块的时候，都要想一想，重复执行这个命令会不会产生负面影响。</p>
<p>当然，在上面的四个模块中，除了raw模块外，都提供了实现幂等特性的参数，就是creates和removes：</p>
<ul>
<li><strong><code>creates参数</code>：</strong>当指定的文件或目录存在时，则不执行命令；</li>
<li><strong><code>removes参数</code>：</strong>定的文件或目录不存在时，则不执行命令；</li>
</ul>
<blockquote>
<p>示例如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- name: use some module</span><br><span class="line">  hosts: node</span><br><span class="line">  gather_facts: false</span><br><span class="line">  tasks:</span><br><span class="line">  # 网卡配置文件不存在时则不执行</span><br><span class="line">  - name: use command module</span><br><span class="line">    command: ifup ens33</span><br><span class="line">    args:</span><br><span class="line">      removes: /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">  # mysql配置文件已存在时则不执行，避免覆盖</span><br><span class="line">  - name: use shell module</span><br><span class="line">    shell: cp /tmp/my.cnf /etc/my.cnf</span><br><span class="line">    args:</span><br><span class="line">      creates: /etc/my.cnf</span><br></pre></td></tr></table></figure>

<p>经过测试可以证明，使用removes或creates参数之后，就可以实现幂等性，保证命令不会重复执行。</p>
<p>这四个模块都不限于执行shell命令或shell脚本，可以通过executable参数指定其他解释器，如expec执行expect脚本、perl解释器执行perl脚本等等。如下：</p>
<p><strong><code>change_when 和 faild_when</code></strong><br>使用change_when 和 faild_when来改变task是changed还是faild的认定，也可以实现幂等性</p>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--  https://www.jianshu.com/p/af4eb9caa216  -->  


]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>实践总结</tag>
      </tags>
  </entry>
  <entry>
    <title>playbook中的条件判断与错误处理</title>
    <url>/2019/07/22/ansible_change_failed_when/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="failed-when-和-changed-when"><a href="#failed-when-和-changed-when" class="headerlink" title="failed_when 和 changed_when"></a>failed_when 和 changed_when</h1><p><code>failed_when</code>关键字的作用是在条件成立时，将对应任务的执行状态设置为<code>Failed</code></p>
<ul>
<li>任务的执行结果控制：<ul>
<li>在 Ansible 1.4 之前，fail模块</li>
<li>在 Ansible 1.4 之后，failed_when</li>
</ul>
</li>
</ul>
<p><code>changed_when</code>关键字的作用是在条件成立时，将对应任务的执行状态设置为<code>changed</code></p>
<h2 id="failed-when"><a href="#failed-when" class="headerlink" title="failed_when"></a>failed_when</h2><p>在任务执行失败时，ansible-playbook会返回这个task failed，但是有些时候，我们希望playbook按照我们的意愿中断任务，以<code>返回值中的特定字符串</code> 做为 <code>中断这个task的条件</code>，当条件成立时将对应任务的状态设置为失败，中止剧本。</p>
<blockquote>
<p>failed_when 示例：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: web1</span><br><span class="line">  #gather_facts: no</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - debug:</span><br><span class="line">      msg: &quot;I execute normally, Before the condition judgment starts&quot;</span><br><span class="line">  - shell: &quot;echo &#x27;This is a string for testing error&#x27;&quot;</span><br><span class="line">    register: return_value</span><br><span class="line">    failed_when: &#x27; &quot;error&quot; in return_value.stdout&#x27;</span><br><span class="line">  - debug:</span><br><span class="line">      msg: &quot;I execute normally, Because the condition doesn&#x27;t hold&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/failedwhen_20201222162132.png?x-oss-process=style/original_format"></p>
<h2 id="changed-when"><a href="#changed-when" class="headerlink" title="changed_when"></a>changed_when</h2><p>在使用command /shell 模块的时候ansible playbook 会按照自己的判断来决定是否changed了，有时候我们仅仅是ls 了一下，ansible-playbook 也会认为是changed了，可能这并不是我们想要的，这个时候我们就要用例子中方法来修改task的状态了</p>
<p><strong>当changed_when状态被设置为false时，不管原任务状态为啥，最终都会被设置为ok状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - shell: &quot;ls /opt&quot;</span><br><span class="line">    changed_when: False</span><br></pre></td></tr></table></figure>

<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/c1_20201222163756.png?x-oss-process=style/original_format"></p>
<p><strong>在条件成立时，将任务状态改为changed</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - debug:</span><br><span class="line">      msg: &quot;test message&quot;</span><br><span class="line">    changed_when: 2 &gt; 1</span><br></pre></td></tr></table></figure>

<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/c2_20201222163945.png?x-oss-process=style/original_format"></p>
<blockquote>
<p><strong>参考文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://www.503error.com/2018/ansible-playbook-failed_when-%E5%92%8Cchanged_when/1521.html">张志明博客</a></li>
<li><a href="https://blog.csdn.net/weixin_34005042/article/details/92730389?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">ansible任务执行控制</a></li>
</ul>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--https://blog.csdn.net/qq_36417677/article/details/105342211-->  
<!--https://my.oschina.net/u/4341235/blog/3585901-->  

]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>实践总结</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible目录结构介绍</title>
    <url>/2019/05/09/ansible_dir_structure/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>引言</p>
</blockquote>
<p>Ansible是开源工具，整个开发过程或二次开发均遵循GPL协议，所以所有源码均可见。<br>作为一款日常工作所需的核心软件，我们有必要知道其目录分布及各目录功能。通过如下命令我们可以获取Ansible所有文件存放目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ql ansible </span><br></pre></td></tr></table></figure>

<p>该命令输出内容较多，大致分为如下几类：</p>
<ul>
<li><strong>/etc/ansible</strong>：<code>ansible的配置文件目录，如：主机与组的文件（Inventory）、主配置文件（ansible.cfg）、角色(role)、剧本文件(.yml)等等</code>。所有Ansible的配置均存放在该目录下，运维日常的所有配置类操作也均基于此目录进行。</li>
<li><strong>/usr/bin</strong>：ansible系列命令默认存放目录。ansible所有的可执行文件均存放在该目录下。</li>
<li><strong>/usr/lib</strong>：ansible程序的相关模块，模块文件主要放在python相关的目录下面，因为ansible就是用python写的嘛。。</li>
<li><strong>/usr/share</strong>：ansible程序的相关文档</li>
<li><strong>Help文档目录</strong>：/usr/share/doc/ansible-X.X.X/</li>
<li><strong>Man文档目录</strong>：/usr/share/man/man1/</li>
</ul>
<p>整体的目录概要可参考如<em>图2-1</em>所示的Ansible目录树结构：</p>
<p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/05/wKiom1hmDQXy5-acAABpUhXn-oQ211.jpg?x-oss-process=style/original_format"></p>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--https://book.51cto.com/art/201612/526511.htm-->  

]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>env</tag>
        <tag>ansible基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言开发环境</title>
    <url>/2020/01/31/Go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>下载地址：</p>
</blockquote>
<p>Go官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a><br>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<blockquote>
<p>版本的选择：</p>
</blockquote>
<p>Windows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。<br>Go语言更新迭代比较快，推荐使用较新版本，体验最新特性。</p>
<h3 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h3><blockquote>
<p>下载地址：</p>
</blockquote>
<p>Go官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a><br>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<p>如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。</p>
<p>我们在版本选择页面选择并下载好<code>go1.14.1.linux-amd64.tar.gz</code>文件：</p>
<p><code>wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz</code><br>将下载好的文件解压到/usr/local目录下：</p>
<p><code>tar -zxvf go1.14.1.linux-amd64.tar.gz -C /usr/local  # 解压</code><br>如果提示没有权限，加上sudo以root用户的身份再运行。执行完就可以在/usr/local/下看到go目录了。</p>
<p>配置环境变量： Linux下有两个文件可以配置环境变量，其中/etc/profile是对所有用户生效的；$HOME/.profile是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在开发 Go 项目时，你还需要一个环境变量来保存你的工作目录。<br><code>export GOPATH=$HOME/Applications/Go</code><br><code>$GOPATH</code> 可以包含多个工作目录，取决于你的个人情况。如果你设置了多个工作目录，那么当你在之后使用 <code>go get</code>（远程包安装命令）时远程包将会被安装在第一个目录下。</p>
</blockquote>
<p>修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ go version</span><br><span class="line">go version go1.14.1 linux/amd64</span><br></pre></td></tr></table></figure>

<p><strong>GOPROXY</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile &amp;&amp; source ~/.profile</span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="GOROOT和GOPATH"><a href="#GOROOT和GOPATH" class="headerlink" title="GOROOT和GOPATH"></a>GOROOT和GOPATH</h3><p><code>GOROOT</code>和<code>GOPATH</code>都是环境变量，其中<code>GOROOT</code>是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为<code>GOPATH</code>设置一个默认目录，参见下表。<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/golang/gopath_20200915161111.png?x-oss-process=style/original_format"></p>
<p>我们只需要记住默认的<code>GOPATH</code>路径在哪里就可以了，并且默认情况下 <code>GOROOT</code>下的bin目录及<code>GOPATH</code>下的bin目录都已经添加到环境变量中了，我们也不需要额外配置了。</p>
<hr>
<p>Go<code>1.14版本之后</code>，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制我们把代码必须写在<code>GOPATH</code>下面的src目录了；<code>GOPATH</code>下可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：<code>src、pkg 和 bin</code>，这三个目录分别用于存放源码文件、包文件和可执行文件。你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）</p>
<blockquote>
<p>在<code>老版本1.11之前</code>，Go语言开发的时候，我们的代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build、go install</code>或<code>go get</code>等指令后，会将下载的第三方包源代码文件放在<code>$GOPATH/src</code>目录下， 产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在<code>$GOPATH/pkg</code> 下。<br>如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加$GOPATH/src目录的源代码即可。bin 和 pkg 目录的内容无需版本控制。</p>
</blockquote>
<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到<code>https://proxy.golang.org</code>，所以我们需要换一个PROXY，这里推荐使用<code>https://goproxy.io</code>或<code>https://goproxy.cn</code>。</p>
<p>可以执行下面的命令修改GOPROXY：<br><code>go env -w GOPROXY=https://goproxy.cn,direct</code></p>
<h3 id="企业开发者的go项目结构"><a href="#企业开发者的go项目结构" class="headerlink" title="企业开发者的go项目结构"></a>企业开发者的go项目结构</h3><blockquote>
<p>参考文档：<a href="%5Bhttp://www.topgoer.com/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AEgopath.html%5D(http://www.topgoer.com/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AEgopath.html)">go语言中文文档</a></p>
</blockquote>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/golang/gopath-qy.png?x-oss-process=style/original_format"></p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><h3 id="vs-code"><a href="#vs-code" class="headerlink" title="vs code"></a>vs code</h3><p><code>Visual Studio Code</code>，简称<code>VS Code</code>，它是目前使用人数最多的编辑器。尽管它由微软发布于2015年，与其他热门编辑器相比显得有些年轻，但它在过去几年中一直在不停的更新，它在最新的<code>Stack Overflow</code>调查中被选为<code>Web</code>开发人员中最受欢迎的文本编辑器。</p>
<p><code>VS Code</code>不仅仅是一个基本的代码编辑器。有人说它更像是<code>IDE</code>而不是代码编辑器，因为它提供了许多通常只在<code>IDE</code>中才有的功能。主要功能包括内置调试工具，智能代码提示，集成终端以及对简易的<code>Git</code>操作（微软刚收购了GitHub）。作为初学者，您可以利用这些功能大大提高编程效率。</p>
<blockquote>
<p>下载地址：</p>
</blockquote>
<p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<h4 id="配置中文"><a href="#配置中文" class="headerlink" title="配置中文"></a>配置中文</h4><p>点击左侧菜单栏最后一项<code>管理扩展</code>，在搜索框中输入<code>chinese</code>，选中结果列表第一项，点击<code>install</code>安装。<br><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/03/install_cn_language.gif?x-oss-process=style/gif_format"></p>
<h4 id="安装go插件"><a href="#安装go插件" class="headerlink" title="安装go插件"></a>安装go插件</h4><p>启动<code>vscode</code>选择插件-&gt;搜<code>go</code>选择<code>Go for Visual Studio Code</code>插件点击安装即可</p>
<h4 id="安装Go语言开发工具包"><a href="#安装Go语言开发工具包" class="headerlink" title="安装Go语言开发工具包"></a>安装Go语言开发工具包</h4><p>在Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。</p>
<p>Windows平台按下<code>Ctrl+Shift+P</code>，Mac平台按<code>Command+Shift+P</code>，这个时候<code>VS Code</code>界面会弹出一个输入框；</p>
<p>我们在这个输入框中输入&gt;<code>go:install</code>，下面会自动搜索相关命令，我们选择<code>Go:Install/Update Tools</code>这个命令，选中并会回车执行该命令（或者使用鼠标点击该命令）<br><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/03/16tools.png?x-oss-process=style/original_format"></p>
<p>VS Code此时会下载并安装上图列出来的16个工具，但是由于国内的网络环境基本上都会出现安装失败</p>
<p><strong>两种方法解决这个问题：</strong></p>
<blockquote>
<p>方法一：使用git下载源代码再安装</p>
</blockquote>
<p>我们可以手动从github上下载工具，(执行此步骤前提需要你的电脑上已经安装了git)<br>第一步：现在自己的<code>GOPATH</code>的<code>src</code>目录下创建<code>golang.org/x</code>目录<br>第二步：在终端/cmd中cd到<code>GOPATH/src/golang.org/x</code>目录下<br>第三步：执行<code>git clone https://github.com/golang/tools.git tools</code>命令<br>第四步：执行<code>git clone https://github.com/golang/lint.git</code>命令<br>第五步：按下<code>Ctrl/Command+Shift+P</code>再次执行<code>Go:Install/Update Tools</code>命令，在弹出的窗口全选并点击确定，这一次的安装都会SUCCESSED了。<br>经过上面的步骤就可以安装成功了。 这个时候创建一个Go文件，就能正常使用代码提示、代码格式化等工具了。</p>
<blockquote>
<p>方法二：下载已经编译好的可执行文件</p>
</blockquote>
<p>如果上面的步骤执行失败了或者懒得一步一步执行，可以直接下载我已经编译好的可执行文件，拷贝到自己电脑上的 <code>go/bin</code>(GO的安装包目录不是代码包啊) 目录下。 </p>
<blockquote>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1kxXsoSXmqwloTKsvRGZbpQ">https://pan.baidu.com/s/1kxXsoSXmqwloTKsvRGZbpQ</a><br>提取码: cucu</p>
</blockquote>
</blockquote>
<p>注意：特别是Mac下需要给拷贝的这些文件赋予可执行的权限。</p>
<h2 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>现在我们来创建第一个Go项目——<code>hello</code>。在我们桌面创建一个<code>hello</code>目录。<br>在该目录中创建一个main.go文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main // 声明 main 包，表明当前是一个可执行程序</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot; // 导入内置 fmt 包</span><br><span class="line"></span><br><span class="line">func main()&#123; // main函数，是程序执行的入口</span><br><span class="line">    fmt.Println(&quot;Hello World!&quot;) // 在终端打印 Hello World!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p><code>go build</code>表示将源代码编译成可执行文件，或者在其他目录执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build hello</span><br></pre></td></tr></table></figure>
<p>go编译器会去 <code>GOPATH</code>的src目录下查找你要编译的<code>hello</code>项目</p>
<blockquote>
<p>如果报错<code>go: cannot find main module; see &#39;go help modules&#39;</code>，可能是变量<code>GO111MODULE</code>导致，试试设置为<code>GO111MODULE=off</code></p>
</blockquote>
<p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到hello.exe可执行文件。</p>
<p>可在终端直接执行该hello.exe文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\desktop\hello&gt;hello.exe</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>我们还可以使用<code>-o</code>参数来指定编译后得到的可执行文件的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build -o heiheihei.exe</span><br></pre></td></tr></table></figure>

<h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p><code>go install</code>表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到<code>GOPATH</code>的bin目录下。因为我们的环境变量中配置了<code>GOPATH</code>下的bin目录，所以我们就可以在任意地方直接执行可执行文件了。</p>
<h4 id="go-install与go-build-的区别"><a href="#go-install与go-build-的区别" class="headerlink" title="go install与go build 的区别"></a>go install与go build 的区别</h4><p><code>go install</code>与<code>go build</code>都可生成执行文件</p>
<p><code>go build</code>会生成可实行文件放在当前目录中。<br><code>go install</code>则会把它放到<code>$GOPATH/bin</code>中。</p>
<p><code>go install</code>还会把导入的依赖包编译到<code>$GOPATH/pkg</code>，并缓存，如果包未做更改，下次编译则直接使用缓存。<code>go build</code>命令加参数<code>-i</code>也能达到<code>go install</code>的效果。</p>
<p>如果项目很大，每次编译都要花很长时间，则建议使用<code>go install</code>来编译，充分利用它对依赖包的缓存功能。</p>
<h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 直接执行go文件，不用编译</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure>

<h3 id="跨平台编译-more"><a href="#跨平台编译-more" class="headerlink" title="跨平台编译(more)"></a>跨平台编译(<a href="%5Bhttps://www.liwenzhou.com/posts/Go/install_go_dev/#autoid-1-5-4%5D(https://www.liwenzhou.com/posts/Go/install_go_dev/#autoid-1-5-4)">more</a>)</h3><p>默认我们go build的可执行文件都是当前操作系统可执行的文件，如果我想在windows下编译一个linux下可执行文件，那需要怎么做呢？</p>
<p>只需要指定目标操作系统的平台和处理器架构即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure>
<p>使用了cgo的代码是不支持跨平台编译的</p>
<p>然后再执行go build命令，得到的就是能够在Linux平台运行的可执行文件了。</p>
<p>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

<p>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

<p>Windows下编译Mac平台64位可执行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>


<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--  https://www.liwenzhou.com/posts/Go/install_go_dev/  -->
<!--  path https://learnku.com/docs/the-way-to-go/go-environment-variable/3565  -->
<!--  mod https://blog.csdn.net/weixin_39003229/article/details/97638573  -->
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>Ad-Hoc命令——简单任务的执行</title>
    <url>/2019/06/07/ansible_ad_hoc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://ansible-tran.readthedocs.io/en/latest/docs/intro_adhoc.html#deploying-from-source-control">Introduction To Ad-Hoc Commands</a></li>
<li><a href="https://docs.ansible.com/ansible/2.8/user_guide/command_line_tools.html">Working with Command Line Tools
</a></li>
</ul>
<hr>
<h2 id="使用Ad-Hoc命令执行任务"><a href="#使用Ad-Hoc命令执行任务" class="headerlink" title="使用Ad-Hoc命令执行任务"></a>使用Ad-Hoc命令执行任务</h2><p>所谓 ad-hoc 命令是什么呢?<br>(这其实是一个概念性的名字,是相对于写 Ansible playbook 来说的.类似于在命令行敲入shell命令和 写shell scripts两者之间的关系)…</p>
<p>如果我们敲入一些命令去比较快的完成一些事情,而不需要将这些执行的命令特别保存下来, 这样的命令就叫做 ad-hoc 命令.<br>Ansible提供<code>两种方式去完成任务</code>,一是 ad-hoc 命令,一是写 Ansible playbook.前者可以解决一些简单的任务, 后者解决较复杂的任务.</p>
<p><code>Ad-Hoc的执行依赖于模块</code>，ansible官方提供了大量的模块。 如：command、raw、shell、file、cron等，具体可以通过ansible-doc -l 进行查看 。可以使用<code>ansible-doc -s module</code>来查看某个模块的参数，也可以使用<code>ansible-doc help module</code>来查看该模块更详细的信息。</p>
<h3 id="ad-hoc-命令的常用参数"><a href="#ad-hoc-命令的常用参数" class="headerlink" title="ad-hoc 命令的常用参数"></a>ad-hoc 命令的常用参数</h3><blockquote>
<p>$ ansible –help</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: ansible &lt;host-pattern&gt; [options]</span><br><span class="line">    -a MODULE_ARGS, --args=MODULE_ARGS：指定模块参数；</span><br><span class="line">    -b, --become：run operations with become (nopasswd implied)</span><br><span class="line">    --become-user=BECOME_USER：变成BECOME_USER用户身份，不提示密码</span><br><span class="line">    -c CONNECTION, --connection=CONNECTION：连接类型(default=smart)</span><br><span class="line">    -C：只是测试一下会改变什么内容,不会真正去执行</span><br><span class="line">    -f FORKS, --forks=FORKS：并发线程数，默认为5个线程；</span><br><span class="line">    -i：指定inventory信息(default=/etc/ansible/hosts)</span><br><span class="line">    -k, --ask-pass：提示输入ssh登录密码,当使用密码验证的时候用</span><br><span class="line">    -K, --ask-become-pass：提示输入sudo密码,当不是NOPASSWD模式时使用</span><br><span class="line">    -l SUBSET, --limit=SUBSET：限制运行主机；</span><br><span class="line">    -list-host：只打印有哪些主机会执行这个命令,不会实际执行</span><br><span class="line">    -M MODULE_PATH, --module-path=MODULE_PATH：指定模块存放路径，默认为/usr/share/ansible；</span><br><span class="line">    -m MODULE_NAME, --module-name=MODULE_NAME：要执行的模块，默认为command</span><br><span class="line">    -o：压缩输出,摘要输出</span><br><span class="line">    --private-key=PRIVATE_KEY_FILE：指定密钥文件；</span><br><span class="line">    -u REMOTE_USER, --user=REMOTE_USER：指定远程执行的用户</span><br><span class="line">    -s：sudo运行</span><br><span class="line">    --syntax-check：对剧本进行语法检查，但不执行</span><br><span class="line">    -T：ssh连接超时时间，默认是10秒</span><br><span class="line">    -t：日志输出到该目录,日志文件名以主机命名</span><br><span class="line">    -v, --verbose：verbose mode (-vvv for more, -vvvv to enable：输出详细的执行过程信息，可以得到执行过程所有信息；</span><br></pre></td></tr></table></figure>

<h2 id="ansible命令执行结果色彩说明"><a href="#ansible命令执行结果色彩说明" class="headerlink" title="ansible命令执行结果色彩说明"></a>ansible命令执行结果色彩说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绿色：表示没有发生任何改变</span><br><span class="line">红色：执行命令操作出现异常</span><br><span class="line">黄色：执行命令后，对受控主机产生影响，发生了配置改变</span><br></pre></td></tr></table></figure>

<h2 id="命令执行模块"><a href="#命令执行模块" class="headerlink" title="命令执行模块"></a>命令执行模块</h2><p>命令执行模块有四个：<code>command、raw、shell、script</code></p>
<h3 id="command、raw"><a href="#command、raw" class="headerlink" title="command、raw"></a>command、raw</h3><p>command为系统默认模块，使用时可以直接省略指定 <code>-m command</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -a &quot;pwd&quot;</span><br><span class="line">10.122.60.68 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">/root</span><br></pre></td></tr></table></figure>
<p>转换到别的目录中，执行程序，chdir为command模块自带的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -a &quot;pwd chdir=/tmp&quot;</span><br><span class="line">10.122.60.68 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure>
<p><code>command 不支持管道命令</code>：$HOME和”&lt;”, “&gt;”, “|”, “;” and “&amp;”<br>raw和command类似，两个模块都是在<code>远程节点</code>上面执行命令，但是<code>raw支持管道命令</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -m raw -a &quot;cd /tmp;pwd&quot;</span><br><span class="line">10.122.60.68 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">/tmp</span><br><span class="line">Shared connection to 10.122.60.68 closed.</span><br></pre></td></tr></table></figure>

<h3 id="shell、script"><a href="#shell、script" class="headerlink" title="shell、script"></a>shell、script</h3><p>shell模块调用远程主机的指令，支持shell特性，包括执行脚本、管道命令等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -m shell -a &quot;cd /tmp;pwd&quot;</span><br><span class="line">10.122.60.68 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure>

<p>shell直接执行脚本，执行的脚本需要放在远程主机上</p>
<p>script<code>只能执行脚本，不能调用其他指令，该模块的执行是将管理机上的脚本传送到远程节点上运行，并且script不支持管道命令。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -m script -a &#x27;/etc/ansible/test.sh</span><br></pre></td></tr></table></figure>

<p>几个模块中，command是默认模块，建议使用shell，功能较方便，script和shell的区别是一个执行控制端的脚本，一个执行远程端的脚本。</p>
<h2 id="命令行执行的常用示例"><a href="#命令行执行的常用示例" class="headerlink" title="命令行执行的常用示例"></a>命令行执行的常用示例</h2><blockquote>
<p>下面简单介绍通过命令行可以对被控制端做什么，后面再深入语法学习：</p>
</blockquote>
<h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a><strong>Ping</strong></h3><p>检查所有的server，是否以bruce用户创建了ansible主机可以访问的环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ansible all -m ping -u bruce</span><br></pre></td></tr></table></figure>

<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>If you would like to access sudo mode, there are also flags to do that:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># as bruce</span><br><span class="line">$ ansible all -m ping -u bruce</span><br><span class="line"># as bruce, sudoing to root</span><br><span class="line">$ ansible all -m ping -u bruce --sudo</span><br><span class="line"># as bruce, sudoing to batman</span><br><span class="line">$ ansible all -m ping -u bruce --sudo --sudo-user batman</span><br><span class="line"></span><br><span class="line"># With latest version of ansible `sudo` is deprecated so use become</span><br><span class="line"># as bruce, sudoing to root</span><br><span class="line">$ ansible all -m ping -u bruce -b</span><br><span class="line"># as bruce, sudoing to batman</span><br><span class="line">$ ansible all -m ping -u bruce -b --become-user batman</span><br></pre></td></tr></table></figure>

<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>在所有的server上，以当前bash的同名用户，在远程主机执行“echo bash”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible all -a &quot;/bin/echo hello&quot;</span><br></pre></td></tr></table></figure>

<h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p>这是 /usr/bin/ansible 的另一种用法.Ansible 能够以并行的方式同时 SCP 大量的文件到多台机器. 命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible atlanta -m copy -a &quot;src=/etc/hosts dest=/tmp/hosts&quot;</span><br></pre></td></tr></table></figure>
<p>若你使用 playbooks, 则可以利用 <code>template</code> 模块来做到更进一步的事情.(请参见 module 和 playbook 的文档)<br>使用 <code>file</code> 模块可以做到修改文件的属主和权限,(在这里可替换为 <code>copy</code> 模块,是等效的):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m file -a &quot;dest=/srv/foo/a.txt mode=600&quot;</span><br><span class="line">$ ansible webservers -m file -a &quot;dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan&quot;</span><br></pre></td></tr></table></figure>
<p>使用 <code>file</code> 模块也可以创建目录,与执行 <code>mkdir -p</code> 效果类似:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m file -a &quot;dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory&quot;</span><br></pre></td></tr></table></figure>
<p>删除目录(递归的删除)和删除文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m file -a &quot;dest=/path/to/c state=absent&quot;</span><br></pre></td></tr></table></figure>

<h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><p>Ansible 提供对 yum 和 apt 的支持.这里是关于 yum 的示例.</p>
<p>确认一个软件包已经安装,但不去升级它:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m yum -a &quot;name=acme state=present&quot;</span><br></pre></td></tr></table></figure>
<p>确认一个软件包的安装版本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m yum -a &quot;name=acme-1.5 state=present&quot;</span><br></pre></td></tr></table></figure>
<p>确认一个软件包还没有安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m yum -a &quot;name=acme state=absent&quot;</span><br></pre></td></tr></table></figure>
<p>对于不同平台的软件包管理工具,Ansible都有对应的模块.如果没有,你也可以使用 command 模块去安装软件. 或者最好是来为那个软件包管理工具贡献一个相应的模块.请在 mailing list 中查看相关的信息和详情.</p>
<h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p>使用 ‘user’ 模块可以方便的创建账户,删除账户,或是管理现有的账户:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible all -m user -a &quot;name=foo password=&lt;crypted password here&gt;&quot;</span><br><span class="line">$ ansible all -m user -a &quot;name=foo state=absent&quot;</span><br></pre></td></tr></table></figure>
<p>更多可用的选项请参考 <a href="https://docs.ansible.com/ansible/2.8/modules/list_of_system_modules.html">模块相关</a> ,包括对组和组成员关系的操作.</p>
<h3 id="使用git部署应用"><a href="#使用git部署应用" class="headerlink" title="使用git部署应用"></a>使用git部署应用</h3><p>直接使用 git 部署 webapp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m git -a &quot;repo=git://foo.example.org/repo.git dest=/srv/myapp version=HEAD&quot;</span><br></pre></td></tr></table></figure>
<p>因为Ansible 模块可通知到 change handlers ,所以当源码被更新时,我们可以告知 Ansible 这个信息,并执行指定的任务, 比如直接通过 git 部署 Perl/Python/PHP/Ruby, 部署完成后重启 apache.</p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>确认某个服务在所有的webservers上都已经启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m service -a &quot;name=httpd state=started&quot;</span><br></pre></td></tr></table></figure>
<p>或是在所有的webservers上重启某个服务(译者注:可能是确认已重启的状态?):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m service -a &quot;name=httpd state=restarted&quot;</span><br></pre></td></tr></table></figure>
<p>确认某个服务已经停止:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible webservers -m service -a &quot;name=httpd state=stopped&quot;</span><br></pre></td></tr></table></figure>

<h3 id="任务的并行执行"><a href="#任务的并行执行" class="headerlink" title="任务的并行执行"></a>任务的并行执行</h3><p>启动10个并行进行执行重起</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible lb -a &quot;/sbin/reboot&quot; -f 10</span><br></pre></td></tr></table></figure>

<h3 id="系统信息收集"><a href="#系统信息收集" class="headerlink" title="系统信息收集"></a>系统信息收集</h3><p>在 playbooks 中有对于 Facts 做描述,它代表的是一个系统中已发现的变量.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible all -m setup</span><br></pre></td></tr></table></figure>
<p>我们也可以对这个命令的输出做过滤,只输出特定的一些 facts</p>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>env</tag>
        <tag>ansible基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible简介与安装</title>
    <url>/2019/05/09/ansible_env_install/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Ansible是一个开源配置管理工具，可以使用它来自动化任务，部署应用程序实现IT基础架构。</p>
<p>Ansible可以用来自动化日常任务，比如：</p>
<ul>
<li>服务器的初始化配置</li>
<li>安全基线配置</li>
<li>更新系统和打补丁</li>
<li>安装软件包等</li>
</ul>
<p>Ansible架构相对比较简单，仅需通过SSH连接客户机执行任务即可：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/d0c8a786c9177f3ef2e7a557829ef2c29e3d5674.jpeg?x-oss-process=style/original_format"></p>
<p><strong><code>工作机制</code>：</strong>Ansible 在管理节点将 Ansible 模块通过 SSH 协议（或者 Kerberos、LDAP）推送到被管理端执行，执行完之后自动删除，可以使用版本控制系统（git/svn）来管理自定义模块及playbooks。</p>
<h2 id="概念术语"><a href="#概念术语" class="headerlink" title="概念术语"></a>概念术语</h2><p>Ansible使用过程中会用到一些概念术语，<strong>与节点有关的重要术语包括</strong><code>控制节点，受管节点，清单和主机文件</code>：<br><strong>控制节点（Control node）</strong>：指安装了Ansible的主机，也叫Ansible服务器端,管理机。 Ansible控制节点主要用于发布运行任务，执行控制命令。Ansible的程序都安装在控制节点上，控制节点需要安装Python和Ansible所需的各种依赖库。注意：目前Ansible还不能安装在Windows下。</p>
<p><strong>受控节点（Managed nodes）</strong>：也叫客户机，就是想用Ansible执行任务的客户服务器。</p>
<p><strong>清单（<code>Inventory</code>）</strong>：Ansible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置，默认的文件路径为 /etc/ansible/hosts</p>
<pre><code>清单（Inventory）列表通常保存在一个名为hosts的主机文件中。在hosts文件中，可以使用IP地址或者主机名来表示具体的管理主机和认证信息，并可以根据主机的用户进行分组。缺省文件：/etc/ansible/hosts，可以通过-i指定自定义的hosts文件。
</code></pre>
<p><strong>模块（<code>Modules</code>）</strong>：模块是Ansible执行特定任务的代码块。比如：添加用户，上传文件和对客户机执行ping操作等。Ansible现在默认自带450多个模块，，Ansible Galaxy公共存储库则包含大约1600个模块。</p>
<p><strong>任务（<code>Task</code>）</strong>：是Ansible客户机上执行的操作。可以使用”ad-hoc”单行命令执行一个任务，例：<code>$ansible all -a &quot;/bin/echo hello&quot;</code>。</p>
<p><strong>剧本（<code>Playbook</code>）</strong>：是利用YAML标记语言编写的可重复执行的任务的列表，playbook实现任务的更便捷的读写和贡献。比如，在Github上有大量的Ansible playbooks共享，你要你有一双善于发现的眼睛你就能找到大量的宝藏。</p>
<p><strong>角色（<code>roles</code>）</strong>：角色是Ansible 1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。</p>
<p><strong>连接插件（<code>Connectior Plugins</code>）</strong>：ansible基于连接插件连接到各个主机上，虽然ansible是使用ssh连接到各个主机的，但是它还支持其他的连接方法，所以需要有连接插件</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/7c1ed21b0ef41bd512788660a38b48ce38db3dd6.jpeg?x-oss-process=style/original_format"></p>
<h2 id="Ansible的优势"><a href="#Ansible的优势" class="headerlink" title="Ansible的优势"></a>Ansible的优势</h2><p><strong>无需客户端</strong></p>
<p>与Chef、Puppet以及Saltstack（现在也支持Agentless方式salt-ssh）不同，Ansible是无客户端Agent的，所以无需在客户机上安装或配置任何程序，就可以运行Ansible任务。由于Ansible不会在客户机上安装任何软件或运行监听程序，因此消除了许多管理开销，我们可以在即可上手使用Ansible管理服务器，同时Ansible的更新也不会影响任何客户机。</p>
<p><strong>使用SSH进行通讯</strong></p>
<p>默认情况下，Ansible使用SSH协议在管理机和客户机之间进行通信。可以使用SFTP与客户机进行安全的文件传输。</p>
<p><strong>并行执行</strong></p>
<p>Ansible与客户机并行通信，可以更快地运行自动化任务。默认情况下，forks值为5，可以按需，在配置文件中增大该值。</p>
<h2 id="安装-more"><a href="#安装-more" class="headerlink" title="安装(more)"></a>安装(<a href="https://ansible-tran.readthedocs.io/en/latest/docs/intro_installation.html">more</a>)</h2><p><strong>YUM安装</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">yum info ansible</span><br><span class="line">yum install ansible</span><br><span class="line">ansible --version</span><br></pre></td></tr></table></figure>

<p><strong>pip3安装指定版本</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#python3 -m pip install --upgrade pip</span><br><span class="line">pip3 install ansible==2.8.10 --trusted-host mirrors.aliyun.com --index-url=http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--https://baijiahao.baidu.com/s?id=1650879841344431164&wfr=spider&for=pc-->  
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible关闭ssh首次连接(公钥认证)提示</title>
    <url>/2019/06/09/ansible_host_key_ckeck/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Ansible1.2.1及其之后的版本都会默认启用公钥认证.</p>
<p>公钥认证就是如果之后的某一台客户端和之前登录过的某一台主机IP相同，那么在“known_hosts”中有了不同的key，这时会提示一个错误信息直到被纠正为止。</p>
<p>在使用Ansible时，可能不想遇到那样的情况，如果有个主机没有在“known_hosts”中被初始化将会导致在交互使用Ansible或定时执行Ansible时对key信息的确认提示。如果想要禁用这个行为的话，可以关闭公钥认证，而且公钥认证会比较慢，也是提高效率的一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 认证提示：</span><br><span class="line">&quot;msg&quot;: &quot;Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this. Please add this host&#x27;s fingerprint to your known_hosts file to manage this host.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="关闭ssh首次连接的公钥认证提示"><a href="#关闭ssh首次连接的公钥认证提示" class="headerlink" title="关闭ssh首次连接的公钥认证提示"></a>关闭ssh首次连接的公钥认证提示</h2><p><strong>方法1</strong>：<br>编辑<code>ansible.cfg</code>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用来禁止ssh的指纹key字串检查</span><br><span class="line">host_key_checking = False</span><br></pre></td></tr></table></figure>
<p>或者直接设置环境变量：<code>export ANSIBLE_HOST_KEY_CHECKING=False</code></p>
<p><strong>方法2</strong>：<br>可以使用-o参数将StrictHostKeyChecking设置为no，使用ssh连接时避免首次连接时让输入yes/no部分的提示。通过查看ansible.cfg配置文件，发现如下行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ssh_connection]</span><br><span class="line"># ssh arguments to use</span><br><span class="line"># Leaving off ControlPersist will result in poor performance, so use</span><br><span class="line"># paramiko on older platforms rather than removing it</span><br><span class="line">#ssh_args = -o ControlMaster=auto -o ControlPersist=60s</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking＝no</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>实践总结</tag>
      </tags>
  </entry>
  <entry>
    <title>handler响应事件</title>
    <url>/2019/07/10/ansible_handler/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="什么是handler"><a href="#什么是handler" class="headerlink" title="什么是handler?"></a>什么是handler?</h2><p>每个主流的编程语言都会有event机制，那么handler就是playbook的event。<br>Handlers里面的每一个handler，也是对module的一次调用。而handlers与tasks不同，tasks会默认的按定义顺序执行每一个task，handlers则不会，它需要在tasks中被调用，才有可能被执行。<br>Tasks中的任务都是有状态的，changed或者ok。 在Ansible中，只在task的执行状态为changed的时候，才会执行该task调用的handler，这也是handler与普通的event机制不同的地方。</p>
<h2 id="一个handler最多只执行一次"><a href="#一个handler最多只执行一次" class="headerlink" title="一个handler最多只执行一次"></a>一个handler最多只执行一次</h2><p>在所有的任务里表执行之后执行，如果有多个task notify同一个handler,那么只执行一次。</p>
<h2 id="action是Changed-才会执行handler"><a href="#action是Changed-才会执行handler" class="headerlink" title="action是Changed ,才会执行handler"></a>action是Changed ,才会执行handler</h2><p>只有当TASKS种的action的执行状态是changed时，才会触发notify handler的执行。<br>下面的脚本执行两次,执行结果是不同的:</p>
<ul>
<li>第一次执行是，tasks的状态都是changed，会触发两个handler</li>
<li>第二次执行是,</li>
</ul>
<ul>
<li>第一个task的状态是OK，那么不会触发handlers”call by /tmp/hosts”,</li>
<li>第二个task的状态是changed，触发了handler”call by /tmp/hosts.random_number”</li>
</ul>
<blockquote>
<p>示例代码：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: lb</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">      random_number: &quot;&#123;&#123; 10000 | random &#125;&#125;&quot;</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Copy the /etc/hosts to /tmp/hosts</span><br><span class="line">      copy: src=/etc/hosts dest=/tmp/hosts</span><br><span class="line">      notify:</span><br><span class="line">        - call by /tmp/hosts</span><br><span class="line">    - name: Copy the /etc/hosts to /tmp/hosts.&#123;&#123; random_number &#125;&#125;</span><br><span class="line">      copy: src=/etc/hosts dest=/tmp/hosts.&#123;&#123; random_number &#125;&#125;</span><br><span class="line">      notify:</span><br><span class="line">        - call by /tmp/hosts.random_number</span><br><span class="line">  handlers:</span><br><span class="line">    - name: call by /tmp/hosts</span><br><span class="line">      debug: msg=&quot;call first time&quot;</span><br><span class="line">    - name: call by /tmp/hosts.random_number</span><br><span class="line">      debug: msg=&quot;call by /tmp/hosts.random_number&quot;</span><br></pre></td></tr></table></figure>

<h2 id="按Handler的定义顺序执行"><a href="#按Handler的定义顺序执行" class="headerlink" title="按Handler的定义顺序执行"></a>按Handler的定义顺序执行</h2><p>handlers是按照在handlers中定义的顺序执行的，而不是按照notify的顺序执行的。<br>下面的例子定义的顺序是1&gt;2&gt;3，notify的顺序是3&gt;2&gt;1，实际执行顺序：1&gt;2&gt;3.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: lb</span><br><span class="line">  remote_user: root</span><br><span class="line">  gather_facts: no</span><br><span class="line">  vars:</span><br><span class="line">      random_number1: &quot;&#123;&#123; 10000 | random &#125;&#125;&quot;</span><br><span class="line">      random_number2: &quot;&#123;&#123; 10000000000 | random &#125;&#125;&quot;</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Copy the /etc/hosts to /tmp/hosts.&#123;&#123; random_number1 &#125;&#125;</span><br><span class="line">      copy: src=/etc/hosts dest=/tmp/hosts.&#123;&#123; random_number1 &#125;&#125;</span><br><span class="line">      notify:</span><br><span class="line">        - define the 3nd handler</span><br><span class="line">    - name: Copy the /etc/hosts to /tmp/hosts.&#123;&#123; random_number2 &#125;&#125;</span><br><span class="line">      copy: src=/etc/hosts dest=/tmp/hosts.&#123;&#123; random_number2 &#125;&#125;</span><br><span class="line">    notify:</span><br><span class="line">      - define the 2nd handler</span><br><span class="line">      - define the 1nd handler</span><br><span class="line">  handlers:</span><br><span class="line">    - name: define the 1nd handler</span><br><span class="line">      debug: msg=&quot;define the 1nd handler&quot;</span><br><span class="line">    - name: define the 2nd handler</span><br><span class="line">      debug: msg=&quot;define the 2nd handler&quot;</span><br><span class="line">    - name: define the 3nd handler</span><br><span class="line">      debug: msg=&quot;define the 3nd handler&quot;</span><br></pre></td></tr></table></figure>


<hr>
<!--  https://ansible-book.gitbooks.io/ansible-first-book/advance/playbook/handler.html  -->  

]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible Playbook 标准构建</title>
    <url>/2019/07/12/ansible_play_example/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>playbooks是 一个不同于使用Ansible命令行执行方式的模式，其功能更强大灵活。简单来说，playbook是一个非常简单的配置管理和多主机部署系统，不同于任何已经存在的模式，可作为一个适合部署复杂应用程序的基础。Playbook可以定制配置，可以按照指定的操作步骤有序执行，支持同步和异步方式。值得注意的是playbook是通过YAML格式来进行描述定义的。</p>
<h1 id="playbook最佳使用方法："><a href="#playbook最佳使用方法：" class="headerlink" title="playbook最佳使用方法："></a>playbook最佳使用方法：</h1><ul>
<li>鼓励文件的重用，尽量使用include和role避免重复的代码。</li>
<li>尽量把大的文件分成小的文件</li>
</ul>
<blockquote>
<p><a href="https://github.com/ansible/ansible-examples">https://github.com/ansible/ansible-examples</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">production                # inventory file for production servers</span><br><span class="line">staging                   # inventory file for staging environment</span><br><span class="line">group_vars/</span><br><span class="line">   group1                 # 在这里，我们将变量分配给特定的组</span><br><span class="line">   group2                 # &quot;&quot;</span><br><span class="line">host_vars/</span><br><span class="line">   hostname1              # 如果系统需要特定的变量，请将其放在此处</span><br><span class="line">   hostname2              # &quot;&quot;</span><br><span class="line">library/                  # 如果有任何自定义模块，请将其放在此处（可选）</span><br><span class="line">filter_plugins/           # i如果有任何自定义过滤器插件，请将其放在此处（可选）</span><br><span class="line">site.yml                  # master playbook</span><br><span class="line">webservers.yml            # 适用于Web服务器层的playbook</span><br><span class="line">dbservers.yml             # playbook for dbserver tier</span><br><span class="line">roles/</span><br><span class="line">    common/               # 代表&quot;role&quot;的命名</span><br><span class="line">        tasks/            #</span><br><span class="line">            main.yml      #  &lt;-- tasks file can include smaller files if warranted</span><br><span class="line">        handlers/         # 处理程序</span><br><span class="line">            main.yml      #  &lt;-- handlers file</span><br><span class="line">        defaults/         #</span><br><span class="line">            main.yml      #  &lt;-- default lower priority variables for this role</span><br><span class="line">        vars/             #</span><br><span class="line">            main.yml      #  &lt;-- variables associated with this role</span><br><span class="line">        files/            #</span><br><span class="line">            bar.txt       #  &lt;-- files for use with the copy resource</span><br><span class="line">            foo.sh        #  &lt;-- script files for use with the script resource</span><br><span class="line">        templates/        #  &lt;-- files for use with the template resource</span><br><span class="line">            ntp.conf.j2   #  &lt;------- templates end in .j2</span><br><span class="line">        README.md         #  &lt;-- role 角色用途 及 使用说明</span><br><span class="line">        meta/             #</span><br><span class="line">            main.yml      #  &lt;-- role dependencies</span><br><span class="line">    webtier/              # 上述“ common”相同的结构，用于webtier角色</span><br><span class="line">    monitoring/           # &quot;&quot;</span><br><span class="line">    fooapp/               # &quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ansible目录及文件含义"><a href="#ansible目录及文件含义" class="headerlink" title="ansible目录及文件含义"></a>ansible目录及文件含义</h2><p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/a_20201202102534.png?x-oss-process=style/original_format"></p>
<hr>
<!--  https://blog.csdn.net/dick633/article/details/110220279  -->  
<!--  http://gitlab.xpaas.lenovo.com/CBP-Application/ansiblerepos/roles  -->  
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Inventory和Patterns</title>
    <url>/2019/06/05/ansible_inventory_patterns/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://www.bookstack.cn/read/ansible-first-book/begin-ansibleshang_shou.md">Ansible入门</a></li>
<li><a href="http://www.ansible.com.cn/docs/intro_inventory.html#host-group">Ansible实践</a></li>
</ul>
<hr>
<h1 id="Host-Inventory"><a href="#Host-Inventory" class="headerlink" title="Host Inventory"></a>Host Inventory</h1><p><strong>Host Inventory 配置文件：</strong>默认文件/etc/ansible/hosts，用来告诉Ansible需要管理哪些主机。并且把这些主机根据按需分类。</p>
<p>可以根据用途分类：数据库节点，服务节点等；根据地点分类：中部，西部机房。</p>
<p>Ansible可以同时操作属于一个组的多台主机，组和主机之间的关系通过 inventory 文件配置。</p>
<h2 id="远程主机和组"><a href="#远程主机和组" class="headerlink" title="远程主机和组"></a>远程主机和组</h2><p><strong>简单分组：</strong><br>方括号<code>[]</code>中是组名，用于对组进行系统分类，便于对不同系统进行分开的管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mail.example.com</span><br><span class="line">[webservers]</span><br><span class="line">foo.example.com</span><br><span class="line">bar.example.com</span><br><span class="line"></span><br><span class="line">[dbservers]</span><br><span class="line">one.example.com</span><br><span class="line">two.example.com</span><br><span class="line">three.example.com</span><br></pre></td></tr></table></figure>

<p><strong>一组相似的 hostname简写方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[webservers]</span><br><span class="line">www[01:50].example.com</span><br><span class="line">[databases]</span><br><span class="line">db-[a:f].example.com</span><br></pre></td></tr></table></figure>

<p><strong>SSH端口不是22的表示方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">badwolf.example.com:5309</span><br></pre></td></tr></table></figure>

<p><strong>单个主机设置别名方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jumper ansible_ssh_port=5555 ansible_ssh_host=192.168.1.50</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子中，通过 “jumper” 别名，会连接 192.168.1.50:5555<br>（这是通过 inventory 文件的特性功能设置的变量。一般而言,这不是设置变量(描述你的系统策略的变量)的最好方式）</p>
</blockquote>
<h2 id="远程主机的连接参数和变量"><a href="#远程主机的连接参数和变量" class="headerlink" title="远程主机的连接参数和变量"></a>远程主机的连接参数和变量</h2><p><strong>参数</strong><br>指定Server的连接参数，其中包括连接方法，用户等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[targets]</span><br><span class="line"></span><br><span class="line">localhost ansible_connection=local</span><br><span class="line">other1.example.com ansible_connection=ssh ansible_user=mpdehaan</span><br><span class="line">other2.example.com ansible_connection=ssh ansible_user=mdehaan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[atlanta]</span><br><span class="line">host1 http_port=80 maxRequestsPerChild=808</span><br><span class="line">host2 http_port=303 maxRequestsPerChild=909</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以指定的参数参考：<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#list-of-behavioral-inventory-parameters">docs.ansible.com</a></p>
</blockquote>
<p><strong>为一个组指定变量：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[atlanta]</span><br><span class="line">host1</span><br><span class="line">host2</span><br><span class="line">[atlanta:vars]</span><br><span class="line">ntp_server=ntp.atlanta.example.com</span><br><span class="line">proxy=proxy.atlanta.example.com</span><br></pre></td></tr></table></figure>

<h2 id="把一个组作为另一个组的子成员"><a href="#把一个组作为另一个组的子成员" class="headerlink" title="把一个组作为另一个组的子成员"></a>把一个组作为另一个组的子成员</h2><p>可以把一个组作为另一个组的子成员,以及分配变量给整个组使用，例：<br>分组usa的子组还可以是其它的组，例如[usa:children]中还可以包含子组southeast, [southeast:children]中还可以包含atlanta和releigh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[atlanta]</span><br><span class="line">host1</span><br><span class="line">host2</span><br><span class="line">[raleigh]</span><br><span class="line">host2</span><br><span class="line">host3</span><br><span class="line">[southeast:children]</span><br><span class="line">atlanta</span><br><span class="line">raleigh</span><br><span class="line">[usa:children]</span><br><span class="line">southeast</span><br><span class="line">northeast</span><br><span class="line">southwest</span><br><span class="line">northwest</span><br></pre></td></tr></table></figure>

<h2 id="按目录结构-组织Host和Group变量-more"><a href="#按目录结构-组织Host和Group变量-more" class="headerlink" title="按目录结构 组织Host和Group变量(more)"></a>按目录结构 组织Host和Group变量<a href="https://www.bookstack.cn/read/ansible-first-book/advance-inventory-fen_zu_guan_li_wen_jian.md">(more)</a></h2><p>在 inventory 主文件中保存所有的变量并不是最佳的方式.还可以保存在独立的文件中,这些独立文件与 inventory 文件保持关联. 不同于 inventory 文件(INI 格式),这些独立文件的格式为 YAML.详见 <a href="http://www.ansible.com.cn/docs/YAMLSyntax.html">YAML 语法</a> .</p>
<p>假设 inventory 文件的路径为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/ansible/hosts</span><br></pre></td></tr></table></figure>

<p>假设有一个主机名为 ‘foosball’, 主机同时属于两个组，组的名字分别是 ‘raleigh’和 ‘webservers’.<br>那么以下组变量的配置文件中的变量可以被 ‘foosball’ 主机所用.</p>
<p>下面依次为 ‘raleigh’ 的组变量,’webservers’ 的组变量,’foosball’ 的主机变量 的配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/ansible/group_vars/raleigh # an optionally end in &#x27;.yml&#x27;, &#x27;.yaml&#x27;, or &#x27;.json</span><br><span class="line">/etc/ansible/group_vars/webservers</span><br><span class="line">/etc/ansible/host_vars/foosball</span><br></pre></td></tr></table></figure>

<p>举例来说,假设你有一些主机,属于不同的数据中心,并依次进行划分.每一个数据中心使用一些不同的服务器.比如 ntp 服务器, database 服务器等等. 那么 ‘raleigh’ 这个组的组变量定义在文件 ‘/etc/ansible/group_vars/raleigh’ 之中,可能类似这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">ntp_server: acme.example.org</span><br><span class="line">database_server: storage.example.org</span><br></pre></td></tr></table></figure>

<p>这些定义变量的文件不是一定要存在,因为这是可选的特性.</p>
<p>还有更进一步的运用,你可以为一个主机,或一个组,创建一个目录,目录名就是主机名或组名.目录中的可以创建多个文件, 文件中的变量都会被读取为主机或组的变量.如下 ‘raleigh’ 组对应于 /etc/ansible/group_vars/raleigh/ 目录,其下有两个文件 db_settings 和 cluster_settings, 其中分别设置不同的变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/ansible/group_vars/raleigh/db_settings</span><br><span class="line">/etc/ansible/group_vars/raleigh/cluster_settings</span><br></pre></td></tr></table></figure>
<p>‘raleigh’ 组下的所有主机,都可以使用 ‘raleigh’ 组的变量.当变量变得太多时,分文件定义变量更方便我们进行管理和组织. 还有一个方式也可参考,详见 <a href="http://www.ansible.com.cn/docs/playbooks_vault.html">Ansible Vault</a> 关于组变量的部分. 注意,分文件定义变量的方式只适用于 Ansible 1.4 及以上版本.</p>
<p>Tip: Ansible 1.2 及以上的版本中,group_vars/ 和 host_vars/ 目录可放在 inventory 目录下,或是 playbook 目录下. 如果两个目录下都存在,那么 playbook 目录下的配置会覆盖 inventory 目录的配置.</p>
<p>Tip: 把你的 inventory 文件 和 变量 放入 git repo 中,以便跟踪他们的更新,这是一种非常推荐的方式.</p>
<h2 id="Inventory-参数的说明"><a href="#Inventory-参数的说明" class="headerlink" title="Inventory 参数的说明"></a>Inventory 参数的说明</h2><p>如同前面提到的,通过设置下面的参数,可以控制 ansible 与远程主机的交互方式,其中一些我们已经讲到过:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible_ssh_host</span><br><span class="line">      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span><br><span class="line"></span><br><span class="line">ansible_ssh_port</span><br><span class="line">      ssh端口号.如果不是默认的端口号,通过此变量设置.</span><br><span class="line"></span><br><span class="line">ansible_ssh_user</span><br><span class="line">      默认的 ssh 用户名</span><br><span class="line"></span><br><span class="line">ansible_ssh_pass</span><br><span class="line">      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)</span><br><span class="line"></span><br><span class="line">ansible_sudo_pass</span><br><span class="line">      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)</span><br><span class="line"></span><br><span class="line">ansible_sudo_exe (new in version 1.8)</span><br><span class="line">      sudo 命令路径(适用于1.8及以上版本)</span><br><span class="line"></span><br><span class="line">ansible_connection</span><br><span class="line">      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &#x27;smart&#x27;,&#x27;smart&#x27; 方式会根据是否支持 ControlPersist, 来判断&#x27;ssh&#x27; 方式是否可行.</span><br><span class="line"></span><br><span class="line">ansible_ssh_private_key_file</span><br><span class="line">      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span><br><span class="line"></span><br><span class="line">ansible_shell_type</span><br><span class="line">      目标系统的shell类型.默认情况下,命令的执行使用 &#x27;sh&#x27; 语法,可设置为 &#x27;csh&#x27; 或 &#x27;fish&#x27;.</span><br><span class="line"></span><br><span class="line">ansible_python_interpreter</span><br><span class="line">      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如 \*BSD, 或者 /usr/bin/python</span><br><span class="line">      不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).</span><br><span class="line"></span><br><span class="line">      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</span><br></pre></td></tr></table></figure>

<p>一个主机文件的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">some_host ansible_ssh_port=2222 ansible_ssh_user=manager</span><br><span class="line">aws_host ansible_ssh_private_key_file=/home/example/.ssh/aws.pem</span><br><span class="line">freebsd_host ansible_python_interpreter=/usr/local/bin/python</span><br><span class="line">ruby_module_host ansible_ruby_interpreter=/usr/bin/ruby.1.9.3</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Patterns匹配"><a href="#Patterns匹配" class="headerlink" title="Patterns匹配"></a>Patterns匹配</h1><h2 id="如何使用Patterns匹配主机或组"><a href="#如何使用Patterns匹配主机或组" class="headerlink" title="如何使用Patterns匹配主机或组"></a>如何使用Patterns匹配主机或组</h2><p>首先要知道，我们使用ansible执行任务的两种方法：</p>
<ul>
<li>Ad-Hoc：执行一个单行命令，适合于运行单个任务。</li>
<li>Playbook：<br> 每个playbook 由一个或多个 <code>play</code> 组成，它的内容是一个以 plays` 为元素的列表。<br> 在 play 之中,一组机器被映射为定义好的角色.在 ansible中，play 的内容被称为 tasks，即任务。在基本层次的应用中,一个任务是一个对 ansible 模块的调用。</li>
</ul>
<p>Ansible中的Patterns决定了我们执行任务可以匹配到哪些主机，意思是与哪些主机进行交互。</p>
<h3 id="Ad-Hoc"><a href="#Ad-Hoc" class="headerlink" title="Ad-Hoc"></a>Ad-Hoc</h3><p>命令格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible &lt;pattern_goes_here&gt; -m &lt;module_name&gt; -a &lt;arguments&gt;</span><br></pre></td></tr></table></figure>

<p>使用示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible webservers -m service -a &quot;name=httpd state=restarted&quot;</span><br></pre></td></tr></table></figure>
<p>一个pattern通常关联到一系列组(主机的集合) ,如上示例中,所有的主机均在 “webservers” 组中.</p>
<p>不管怎么样,在使用Ansible前,我们需事先告诉Ansible哪台机器将被执行. 能这样做的前提是需要预先定义唯一的 host names 或者 主机组.</p>
<p><strong>匹配所有的主机</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<p><strong>精确匹配</strong><br>可以写IP地址或系列主机名:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one.example.com</span><br><span class="line">one.example.com:two.example.com</span><br><span class="line">192.168.1.50</span><br><span class="line">192.168.1.*</span><br></pre></td></tr></table></figure>

<p><strong>或匹配</strong><br>Patterns 表示匹配的主机在web组或db组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web:db</span><br></pre></td></tr></table></figure>

<p><strong>非模式匹配</strong><br>命令下需转义特殊符号，以下Patterns 表示匹配的主机在web组，不在db组中，包含在web组，又在db中的用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web:\!db</span><br></pre></td></tr></table></figure>

<p><strong>交集匹配</strong><br>以下Patterns 表示匹配的主机同时在db组和dbservers组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web:&amp;db</span><br></pre></td></tr></table></figure>

<p><strong>通配符匹配</strong><br>*表示所有字符，[0]表示组第一个成员，[0:25] 表示组第1个到第24个成员，类似python中得切片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web-*.com:dbserver</span><br><span class="line">webserver[0]</span><br><span class="line">webserver[0:25]</span><br></pre></td></tr></table></figure>

<p><strong>正则表达式匹配</strong><br>在开头的地方使用“~”，表示这是一个正则表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~(web|db).*\.example\.com</span><br></pre></td></tr></table></figure>

<p><strong>组合匹配</strong><br>在webservers 或者dbservers 组中，必须还存在于staging 组中，但是不在phoenix 组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webservers:dbservers:&amp;staging:!phoenix</span><br></pre></td></tr></table></figure>
<p>上面这个例子表示“‘webservers’ 和 ‘dbservers’ 两个组中隶属于 ‘staging’ 组并且不属于 ‘phoenix’ 组的机器才执行命令” … 哟！唷! 好烧脑的说！</p>
<h3 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h3><p>在ansible-palybook 命令中，你也可以使用变量来组成这样的表达式，但是你必须使用“-e”的选项来指定这个表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webservers:!&#123;&#123;excluded&#125;&#125;:&amp;&#123;&#123;required&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过 –limit 标记来添加排除条件</strong><br>只对  “–limit” 后的主机或组 执行剧本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible-playbook site.yml --limit datacenter2</span><br></pre></td></tr></table></figure>
<p>如果你想从文件读取hosts,文件名以@为前缀即可.从Ansible 1.2开始支持该功能:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible-playbook site.yml --limit @retry_hosts.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 此时使用认证方式依然使用 Inventory hosts文件中的ssh密码，retry_hosts.txt 中只包含节点ip</span><br><span class="line">192.168.1.21</span><br><span class="line">192.168.1.22</span><br></pre></td></tr></table></figure>

<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--Patterns-->  
<!--https://blog.51cto.com/lxlxlx/1894384 -->  
<!--  http://www.ansible.com.cn/docs/intro_patterns.html  -->  
<!--  https://www.cnblogs.com/hanyifeng/p/6193249.html  -->  
<!--Ansible用命令管理主机-->  
<!--  https://www.jianshu.com/p/82b4e9162590  -->  
<!--  https://blog.csdn.net/weixin_44033360/article/details/103779064  -->  
<!--  https://blog.csdn.net/weixin_33743880/article/details/89595014  -->  
<!--  https://blog.csdn.net/qq_34646546/article/details/86606408  -->  
<!--  https://blog.csdn.net/MatrixGod/article/details/82149712?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3  -->  
<!--  https://www.cnblogs.com/xiaoyaojinzhazhadehangcheng/articles/8628877.html  -->  
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>env</tag>
        <tag>ansible基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible playbook keywords</title>
    <url>/2019/07/05/ansible_play_keyword/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Playbook-Keywords"><a href="#Playbook-Keywords" class="headerlink" title="Playbook Keywords"></a>Playbook Keywords</h1><p>playbook对象上可用的关键字是配置可执行行为的几个来源之一。有关每个源的相对优先级：</p>
<blockquote>
<p><strong><code>Precedence categories</code></strong><a href="https://docs.ansible.com/ansible/latest/reference_appendices/general_precedence.html#general-precedence-rules">(more)</a><br>Ansible offers four sources for controlling its behavior. In order of precedence from lowest (most easily overridden) to highest (overrides all others), the categories are:</p>
</blockquote>
<ul>
<li>Configuration settings</li>
<li>Command-line options</li>
<li>Playbook keywords</li>
<li>Variables</li>
</ul>
<hr>
<h2 id="通用关键字"><a href="#通用关键字" class="headerlink" title="通用关键字"></a>通用关键字</h2><p>以下为<code>角色 - Play/Role/Block/Task</code> 通用的关键字整理：</p>
<pre><code>**any_errors_fatal**
强制任何主机上的任何未处理任务错误传播到所有主机并结束播放

**become**
布尔值，切换成其它用户身份执行，值为yes或者no

**become_exe**
UNDOCUMENTED!!

**become_flags**
当变为True的时候，要传递给权限提升程序的标志

**become_method**
与became一起用，适用那种权限升级方法(such as sudo or su)

**become_user**
设置为具有所需权限的用户（你要切换到的目标用户），而不是您登录的用户。远程/登录用户必须具有成为该用户的权限。必须跟become: yes 一起使用。

**check_mode**
一个布尔值，控制是否以“检查”模式执行任务

**collections**
UNDOCUMENTED!!

**connection**[(more)](https://docs.ansible.com/ansible/latest/plugins/connection.html#using-connection)
Allows you to change the connection plugin used for tasks to execute on the target.

**debugger**
调试器，根据任务结果的状态启用调试任务

**diff**
切换使任务是否返回“ diff”信息。

**environment**
一个字典，该字典将转换为环境变量，以便在执行时为任务提供。这不会影响Ansible本身或其配置，它只会为负责执行任务的代码设置变量。

**ignore_errors**
布尔值，允许您忽略任务失败并继续执行。它不会影响连接错误

**ignore_unreachable**
布尔值，允许您忽略无法访问的主机并继续这个play

**module_defaults**
指定模块的默认参数值

**name**
Identifier. Can be used for documentation, in or tasks/handlers.

**no_log**
控制信息泄露的布尔值

**port**
用于覆盖连接中使用的默认端口

**remote_user**
以哪个用户身份执行

**run_once**
布尔值，它将绕过主机循环，强制任务尝试在第一个可用主机上执行，然后将任何结果和事实应用于同一批次中的所有活动主机

**tags**
应用于任务或包含任务的标签，允许从命令行选择任务子集

**throttle**
限制在任务、块和剧本级别上运行的并发任务的数量。这与fork和serial设置无关，但不能设置得高于这些限制。例如，如果将fork设置为10，而将throttle设置为15，则最多将并行操作10台主机。

**vars**
变量
</code></pre>
<h2 id="非通用关键字"><a href="#非通用关键字" class="headerlink" title="非通用关键字"></a>非通用关键字</h2><h3 id="Play"><a href="#Play" class="headerlink" title="Play"></a>Play</h3><p><strong>fact_path</strong><br>为由gather_facts控制的事实收集插件设置事实路径选项</p>
<p><strong>force_handlers</strong><br>即使在播放期间失败，也会强制通知处理程序执行主机</p>
<p><strong>gather_facts</strong><br>一个布尔值，用于控制播放是否将自动运行“ setup”任务来为主机收集事实。</p>
<p><strong>gather_subset</strong><br>允许您将子集选项传递给gather_facts控制的事实收集插件</p>
<p><strong>gather_timeout</strong><br>允许您设置由gather_facts控制的事实收集插件的超时</p>
<p><strong>handlers</strong><br>处理器，是playbook的event，默认不会执行，在action里触发才会执行。多次触发只执行一次。</p>
<p><strong>hosts</strong><br>主机或主机组列表</p>
<p><strong>max_fail_percentage</strong><br>在当前批处理中给定百分比的主机失败后，可用于中止运行</p>
<p><strong>order</strong><br>控制主机在用于执行play时的排序。可能的值是inventory（默认），sorted，reverse_sorted，reverse_inventory和shuffle。</p>
<p><strong>post_tasks</strong><br>任务部分后要执行的任务列表</p>
<p><strong>pre_tasks</strong><br>在roles之前执行的任务列表</p>
<p><strong>roles</strong><br>要导入到剧本中的角色列表</p>
<p><strong>serial</strong><br>明确定义Ansible如何在剧本目标上分批执行当前剧本</p>
<p><strong>strategy</strong><br>允许您选择用于play的连接插件</p>
<p><strong>tasks</strong><br>在play中执行的任务的主要列表，它们在角色之后和post_tasks之前运行</p>
<p><strong>vars_files</strong><br>包含vars的文件列表到剧本中</p>
<p><strong>vars_prompt</strong><br>要提示的变量列表</p>
<hr>
<h3 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h3><p><strong>delegate_facts</strong><br>布尔值，允许您将事实应用于委托主机而不是inventory_hostname<br><strong>delegate_to</strong><br>主机执行任务而不是目标（inventory_hostname）。来自委派主机的连接变量也将用于该任务<br><strong>when</strong><br>条件表达式，确定是否运行任务的迭代</p>
<hr>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p><strong>always</strong><br>block中的任务列表，无论block中是否有错误，都将执行。<br><strong>block</strong><br>List of tasks in a block.<br><strong>rescue</strong><br>当主block中出现任务错误时，运行rescue，然后做一些补救性的工作</p>
<p><strong>delegate_facts</strong><br>布尔值，允许您将事实应用于委托主机而不是inventory_hostname<br><strong>delegate_to</strong><br>主机执行任务而不是目标（inventory_hostname）。来自委派主机的连接变量也将用于该任务<br><strong>when</strong><br>条件表达式，确定是否运行任务的迭代</p>
<hr>
<h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p><strong>action</strong><br>任务要执行的操作<br><strong>args</strong><br>将参数传递到任务的第二种方法<br><strong>async</strong><br>Run a task asynchronously if the C(action) supports this; value is maximum runtime in seconds.<br><strong>block</strong><br>List of tasks in a block.<br><strong>changed_when</strong><br>覆盖任务的正常“‘changed’”状态的条件表达式<br><strong>delay</strong><br>延迟的秒数<br><strong>failed_when</strong><br>覆盖任务的正常“failed”状态的条件表达式<br><strong>local_action</strong><br>Same as action but also implies delegate_to: localhost<br><strong>loop</strong><br>循环取值的任务列表<br><strong>loop_control</strong><br>Several keys here allow you to modify/set loop behaviour in a task.<br><strong>notify</strong><br>当任务返回changed=True状态时要通知处理程序<br><strong>poll</strong><br>Sets the polling interval in seconds for async tasks (default 10s).<br><strong>register</strong><br>寄存器，接收任务的返回值或者状态（用于自定义变量定义）<br><strong>retries</strong><br>重试次数，与until配合适用<br><strong>until</strong><br>直到…结束循环<br><strong>with_[lookup_plugin]</strong><br>The same as loop but magically adds the output of any lookup plugin to generate the item list.</p>
<p><strong>delegate_facts</strong><br>布尔值，允许您将事实应用于委托主机而不是inventory_hostname<br><strong>delegate_to</strong><br>主机执行任务而不是目标（inventory_hostname）。来自委派主机的连接变量也将用于该任务<br><strong>when</strong><br>条件表达式，确定是否运行任务的迭代</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/playbook%20keywords.png?x-oss-process=style/original_format"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/playbook%20keywords%20common.png?x-oss-process=style/original_format"></p>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--  https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html  -->  
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>实践总结</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible免密登录和账号登录</title>
    <url>/2019/06/09/ansible_login_nopasswd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Ansible默认是通过<code>SSH key</code>和远程被控制主机进行通信,当然我们可以<code>SSH password</code>来和远程主机进行通信。 如果使用SSH KEY,则要将控制主机上的公钥放到被监控主机的<code>/root/.ssh/authorized_keys</code>文件中，这种方式也是官方提倡的。毕竟直接使用密码存在一定的风险。</p>
<blockquote>
<p>密钥认证原理</p>
</blockquote>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/ansible/1545976-20190903164007168-245635235.png?x-oss-process=style/original_format"></p>
<h1 id="一、通过ssh密钥免密登录"><a href="#一、通过ssh密钥免密登录" class="headerlink" title="一、通过ssh密钥免密登录"></a>一、通过ssh密钥免密登录</h1><h2 id="创建密钥对-ssh-keygen-more"><a href="#创建密钥对-ssh-keygen-more" class="headerlink" title="创建密钥对 ssh-keygen(more)"></a>创建密钥对 ssh-keygen<a href="https://wangchujiang.com/linux-command/c/ssh-keygen.html">(more)</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 解决创建秘钥对需要进行交互的问题</span><br><span class="line">ssh-keygen -t dsa -f ~/.ssh/id_dsa -P &quot;&quot; -q</span><br></pre></td></tr></table></figure>

<h2 id="分发公钥文件"><a href="#分发公钥文件" class="headerlink" title="分发公钥文件"></a>分发公钥文件</h2><h3 id="ssh-copy-id-手动分发公钥文件"><a href="#ssh-copy-id-手动分发公钥文件" class="headerlink" title="ssh-copy-id 手动分发公钥文件"></a>ssh-copy-id 手动分发公钥文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ~]# ssh-copy-id -i /root/.ssh/id_dsa.pub -p 22 root@10.122.60.68</span><br><span class="line">/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_dsa.pub&quot;</span><br><span class="line">The authenticity of host &#x27;10.122.60.68 (10.122.60.68)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:RHy25keGgWs+/k9ETi13P8KLjvaFS0P0kV1W9DLQgW8.</span><br><span class="line">ECDSA key fingerprint is MD5:25:c5:04:8e:5f:16:21:f1:53:9d:b2:bb:00:36:0e:08.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes # 可通过ansible.cfg配置&quot;host_key_checking = False&quot;跳过 ssh 首次连接提示验证部分</span><br><span class="line">/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@10.122.60.68&#x27;s password: # 远程被管理端密码</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with: &quot;ssh -p &#x27;22&#x27; &#x27;root@10.122.60.68&#x27;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line"></span><br><span class="line">[root@sltkp3cbpch ~]#</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>基于ssh key的登录验证：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ~]# ssh root@10.122.60.68 &quot;hostname -i&quot;</span><br><span class="line">fe80::f816:3eff:fe4b:25a1%eth0 10.122.60.68 172.17.0.1 172.18.0.1</span><br></pre></td></tr></table></figure>

<h3 id="sshpass-批量分发公钥"><a href="#sshpass-批量分发公钥" class="headerlink" title="sshpass 批量分发公钥"></a>sshpass 批量分发公钥</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>创建秘钥对需要进行交互<ul>
<li>需要确认秘钥保存路径</li>
<li>需要确认密码信息</li>
</ul>
</li>
<li>分发公钥时需要进行交互<ul>
<li>首次ssh连接时需要进行确认yes|no</li>
<li>第一次分发公钥需要进行密码认证</li>
</ul>
</li>
</ol>
<h4 id="解决-创建秘钥-时需要进行的交互"><a href="#解决-创建秘钥-时需要进行的交互" class="headerlink" title="解决 创建秘钥 时需要进行的交互"></a>解决 创建秘钥 时需要进行的交互</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t dsa -f ~/.ssh/id_dsa -P &quot;&quot; -q</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：</p>
</blockquote>
<pre><code>-f：filename Specifies the filename of the key file.
    指定密钥文件保存的路径信息（免交互）
-N：提供一个新密语；
-P：提供（旧）密语；
-q：安静的 不输出信息，减少信息输出
</code></pre>
<h4 id="解决-第一次分发公钥-时需要进行的交互-sshpass"><a href="#解决-第一次分发公钥-时需要进行的交互-sshpass" class="headerlink" title="解决 第一次分发公钥 时需要进行的交互(sshpass)"></a>解决 第一次分发公钥 时需要进行的交互(sshpass)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sshpass -p $clientpasswd ssh-copy-id -p22 -i /root/.ssh/id_dsa.pub root@$ip -o StrictHostKeyChecking=no</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：</p>
</blockquote>
<pre><code>-o option 选择 （man 手册中可以查到有很多选项）
StrictHostKeyChecking=no 对询问的回应（不进行对密钥检查）
</code></pre>
<p>要实现免密码，需要一款软件 sshpass 该软件就是为ssh提供密码使用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install sshpass -y</span><br></pre></td></tr></table></figure>

<h4 id="分发脚本"><a href="#分发脚本" class="headerlink" title="分发脚本"></a>分发脚本</h4><p>非交互式创建/分发密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># check key pair</span><br><span class="line">ID_DSA=&#x27;/root/.ssh/id_dsa&#x27;</span><br><span class="line">ID_PUB=&#x27;/root/.ssh/id_dsa.pub&#x27;</span><br><span class="line"></span><br><span class="line"># distribute public key</span><br><span class="line">function Distribute_pubkey ()&#123;</span><br><span class="line">    for ip in 83 68</span><br><span class="line">    do</span><br><span class="line">        #sshpass -p $clientpasswd ssh-copy-id -p22 -i /root/.ssh/id_dsa.pub root@$ip -o StrictHostKeyChecking=no</span><br><span class="line">        sshpass -p&quot;$GKLPASSWD&quot; ssh-copy-id -p22 -i /root/.ssh/id_dsa.pub root@10.122.60.&quot;$ip&quot; -o StrictHostKeyChecking=no &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        if [ $? -ne 0 ];then</span><br><span class="line">            echo -e &quot;distribute public key to ip-$ip is false&quot;</span><br><span class="line">        else</span><br><span class="line">            echo -e &quot;distribute public key to ip-$ip is true&quot;</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$ID_DSA&quot; ] &amp;&amp; [ -f &quot;$ID_PUB&quot; ];then</span><br><span class="line">    echo &quot;key pair is already exists, Start distributing pub files&quot;</span><br><span class="line">    Distribute_pubkey</span><br><span class="line">else</span><br><span class="line">    # make key pair</span><br><span class="line">    ssh-keygen -t dsa -f ~/.ssh/id_dsa -P &quot;&quot; -q</span><br><span class="line">    Distribute_pubkey</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ansible免密登录验证"><a href="#ansible免密登录验证" class="headerlink" title="ansible免密登录验证"></a>ansible免密登录验证</h2><p>添加ansible hosts，<code>编辑 /etc/ansible/hosts</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-servers]</span><br><span class="line">10.122.60.68</span><br><span class="line">10.122.60.83</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -m &quot;ping&quot;</span><br><span class="line">[DEPRECATION WARNING]: The TRANSFORM_INVALID_GROUP_CHARS settings is set to allow bad characters in group names by default,</span><br><span class="line">this will change, but still be user configurable on deprecation. This feature will be removed in version 2.10. Deprecation</span><br><span class="line">warnings can be disabled by setting deprecation_warnings=False in ansible.cfg.</span><br><span class="line">[WARNING]: Invalid characters were found in group names but not replaced, use -vvvv to see details</span><br><span class="line">10.122.60.68 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">10.122.60.83 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、ansible-账号密码登录-more"><a href="#二、ansible-账号密码登录-more" class="headerlink" title="二、ansible 账号密码登录(more)"></a>二、ansible 账号密码登录<a href="https://blog.csdn.net/liumiaocn/article/details/82354158">(more)</a></h1><p>上一章中，我们利用<code>sshpass命令</code>完成了批量推送公钥的操作，使ansible可以通过<code>SSH key</code>进行免密登录来管理远程主机。</p>
<p>本章将学习ansible通过<code>SSH password</code>来和远程主机进行通信。<br>需要用到的hosts文件内部支持的俩个特定指令(inventory参数)：</p>
<ul>
<li>ansible_ssh_user：连接到该主机的ssh用户</li>
<li>ansible_ssh_pass：连接到该主机的ssh密码（连-k选项都省了），安全考虑还是建议使用私钥或在命令行指定-k选项输入</li>
</ul>
<p><strong>准备工作：</strong><br>首先，为了不影响实验效果，请<code>将推送完成的公钥信息从远程被控制主机</code>authorized_keys<code>中删除</code>并验证环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -m &quot;ping&quot;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">10.122.60.83 | UNREACHABLE! =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;msg&quot;: &quot;Failed to connect to the host via ssh: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).&quot;,</span><br><span class="line">    &quot;unreachable&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="添加ansible-hosts"><a href="#添加ansible-hosts" class="headerlink" title="添加ansible hosts"></a>添加ansible hosts</h2><p><code>$vim /etc/ansible/hosts</code></p>
<blockquote>
<p>格式：【主机名】 【主机地址】 【主机密码】 默认是root用户来进行的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-servers]</span><br><span class="line">1 ansible_ssh_user=&quot;root&quot; ansible_ssh_host=10.122.60.68 ansible_ssh_pass=&quot;houjue1992***&quot;</span><br><span class="line">2 ansible_ssh_user=&quot;root&quot; ansible_ssh_host=10.122.60.83 ansible_ssh_pass=&quot;houjue1992***&quot;</span><br></pre></td></tr></table></figure>

<p>新版的ansible(2.4+) hosts有更新， 用以下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-servers]</span><br><span class="line">10.122.60.68 ansible_user=root ansible_ssh_pass=&quot;houjue1992***&quot;</span><br><span class="line">10.122.60.83 ansible_user=root ansible_ssh_pass=&quot;houjue1992***&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ansible账号密码登录验证"><a href="#ansible账号密码登录验证" class="headerlink" title="ansible账号密码登录验证"></a>ansible账号密码登录验证</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@sltkp3cbpch ansible]# ansible all -m &quot;ping&quot;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">10.122.60.68 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>参考文章：<a href="https://blog.csdn.net/liumiaocn/article/details/82354158">https://blog.csdn.net/liumiaocn/article/details/82354158</a></p>
</blockquote>
<p>ansible在执行的时候实际还是使用了ssh，可以不必打通ssh通道，但是实际在执行的时候需要输入用户名和密码，而这两个信息，可以通过<code>/etc/ansible/hosts</code>中的选项进行设定：<code>ansible_ssh_user</code>和<code>ansible_ssh_pass</code>。<br>另外，没有打通ssh通道的时候，ansible使用了sshpass , 而sshpass则正是免去交互式输入用户名密码的ssh命令。</p>
<blockquote>
<p>ansible 在执行时使用sshpass的过程：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parsed /etc/ansible/hosts inventory source with ini plugin</span><br><span class="line">META: ran handlers</span><br><span class="line">&lt;10.122.60.68&gt; ESTABLISH SSH CONNECTION FOR USER: root</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 ssh -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc 10.122.60.68 &#x27;/bin/sh -c &#x27;&quot;&#x27;&quot;&#x27;echo ~root &amp;&amp; sleep 0&#x27;&quot;&#x27;&quot;&#x27;&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;/root\n&#x27;, &#x27;&#x27;)</span><br><span class="line">&lt;10.122.60.68&gt; ESTABLISH SSH CONNECTION FOR USER: root</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 ssh -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc 10.122.60.68 &#x27;/bin/sh -c &#x27;&quot;&#x27;&quot;&#x27;( umask 77 &amp;&amp; mkdir -p &quot;` echo /root/.ansible/tmp `&quot;&amp;&amp; mkdir /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247 &amp;&amp; echo ansible-tmp-1588928466.74-17075-281433475095247=&quot;` echo /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247 `&quot; ) &amp;&amp; sleep 0&#x27;&quot;&#x27;&quot;&#x27;&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;ansible-tmp-1588928466.74-17075-281433475095247=/root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247\n&#x27;, &#x27;&#x27;)</span><br><span class="line">&lt;10.122.60.68&gt; Attempting python interpreter discovery</span><br><span class="line">&lt;10.122.60.68&gt; ESTABLISH SSH CONNECTION FOR USER: root</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 ssh -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc 10.122.60.68 &#x27;/bin/sh -c &#x27;&quot;&#x27;&quot;&#x27;echo PLATFORM; uname; echo FOUND; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;/usr/bin/python&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;python3.7&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;python3.6&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;python3.5&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;python2.7&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;python2.6&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;/usr/libexec/platform-python&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;/usr/bin/python3&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; command -v &#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;python&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;&quot;&#x27;; echo ENDFOUND &amp;&amp; sleep 0&#x27;&quot;&#x27;&quot;&#x27;&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;PLATFORM\nLinux\nFOUND\n/usr/bin/python\n/usr/bin/python3.6\n/usr/bin/python2.7\n/usr/libexec/platform-python\n/usr/bin/python3\n/usr/bin/python\nENDFOUND\n&#x27;, &#x27;&#x27;)</span><br><span class="line">&lt;10.122.60.68&gt; ESTABLISH SSH CONNECTION FOR USER: root</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 ssh -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc 10.122.60.68 &#x27;/bin/sh -c &#x27;&quot;&#x27;&quot;&#x27;/usr/bin/python &amp;&amp; sleep 0&#x27;&quot;&#x27;&quot;&#x27;&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;&#123;&quot;osrelease_content&quot;: &quot;NAME=\\&quot;CentOS Linux\\&quot;\\nVERSION=\\&quot;7 (Core)\\&quot;\\nID=\\&quot;centos\\&quot;\\nID_LIKE=\\&quot;rhel fedora\\&quot;\\nVERSION_ID=\\&quot;7\\&quot;\\nPRETTY_NAME=\\&quot;CentOS Linux 7 (Core)\\&quot;\\nANSI_COLOR=\\&quot;0;31\\&quot;\\nCPE_NAME=\\&quot;cpe:/o:centos:centos:7\\&quot;\\nHOME_URL=\\&quot;https://www.centos.org/\\&quot;\\nBUG_REPORT_URL=\\&quot;https://bugs.centos.org/\\&quot;\\n\\nCENTOS_MANTISBT_PROJECT=\\&quot;CentOS-7\\&quot;\\nCENTOS_MANTISBT_PROJECT_VERSION=\\&quot;7\\&quot;\\nREDHAT_SUPPORT_PRODUCT=\\&quot;centos\\&quot;\\nREDHAT_SUPPORT_PRODUCT_VERSION=\\&quot;7\\&quot;\\n\\n&quot;, &quot;platform_dist_result&quot;: [&quot;centos&quot;, &quot;7.5.1804&quot;, &quot;Core&quot;]&#125;\n&#x27;, &#x27;&#x27;)</span><br><span class="line">Using module file /usr/lib/python2.7/site-packages/ansible/modules/system/ping.py</span><br><span class="line">&lt;10.122.60.68&gt; PUT /root/.ansible/tmp/ansible-local-17067x6om3y/tmp1Exf0H TO /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247/AnsiballZ_ping.py</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 sftp -o BatchMode=no -b - -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc &#x27;[10.122.60.68]&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;sftp&gt; put /root/.ansible/tmp/ansible-local-17067x6om3y/tmp1Exf0H /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247/AnsiballZ_ping.py\n&#x27;, &#x27;&#x27;)</span><br><span class="line">&lt;10.122.60.68&gt; ESTABLISH SSH CONNECTION FOR USER: root</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 ssh -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc 10.122.60.68 &#x27;/bin/sh -c &#x27;&quot;&#x27;&quot;&#x27;chmod u+x /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247/ /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247/AnsiballZ_ping.py &amp;&amp; sleep 0&#x27;&quot;&#x27;&quot;&#x27;&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;&#x27;, &#x27;&#x27;)</span><br><span class="line">&lt;10.122.60.68&gt; ESTABLISH SSH CONNECTION FOR USER: root</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 ssh -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc -tt 10.122.60.68 &#x27;/bin/sh -c &#x27;&quot;&#x27;&quot;&#x27;/usr/bin/python /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247/AnsiballZ_ping.py &amp;&amp; sleep 0&#x27;&quot;&#x27;&quot;&#x27;&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;\r\n&#123;&quot;invocation&quot;: &#123;&quot;module_args&quot;: &#123;&quot;data&quot;: &quot;pong&quot;&#125;&#125;, &quot;ping&quot;: &quot;pong&quot;&#125;\r\n&#x27;, &#x27;Shared connection to 10.122.60.68 closed.\r\n&#x27;)</span><br><span class="line">&lt;10.122.60.68&gt; ESTABLISH SSH CONNECTION FOR USER: root</span><br><span class="line">&lt;10.122.60.68&gt; SSH: EXEC sshpass -d10 ssh -C -o ControlMaster=auto -o ControlPersist=60s -o &#x27;User=&quot;root&quot;&#x27; -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/2611c79bbc 10.122.60.68 &#x27;/bin/sh -c &#x27;&quot;&#x27;&quot;&#x27;rm -f -r /root/.ansible/tmp/ansible-tmp-1588928466.74-17075-281433475095247/ &gt; /dev/null 2&gt;&amp;1 &amp;&amp; sleep 0&#x27;&quot;&#x27;&quot;&#x27;&#x27;</span><br><span class="line">&lt;10.122.60.68&gt; (0, &#x27;&#x27;, &#x27;&#x27;)</span><br><span class="line">10.122.60.68 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;invocation&quot;: &#123;</span><br><span class="line">        &quot;module_args&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &quot;pong&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">META: ran handlers</span><br><span class="line">META: ran handlers</span><br></pre></td></tr></table></figure>

<h1 id="三、使用authorized-key模块推送公钥-more"><a href="#三、使用authorized-key模块推送公钥-more" class="headerlink" title="三、使用authorized_key模块推送公钥(more)"></a>三、使用authorized_key模块推送公钥<a href="https://docs.ansible.com/ansible/2.8/modules/authorized_key_module.html#">(more)</a></h1><p>结合上面学习的内容，我们对比ansible管理远程主机的两种手段：</p>
<ol>
<li><code>SSH key</code>：将控制主机上的公钥放到被监控主机的<code>/root/.ssh/authorized_keys</code>文件中，这种方式安全并且是官方提倡的。</li>
<li><code>SSH password</code>：ansible使用ssh通过读取<code>hosts</code>中配置的账号密码来登录并控制远程主机，这种方法存在账号密码泄漏的风险。</li>
</ol>
<p>由此可见，<code>SSH key</code> 安全且一本万利，但是前提是需要进行公钥推送的操作，而通过<code>sshpass</code>命令完成这个任务就需要进行脚本编写，无疑增加了工作量。此时，authorized_key模块就显得格外方便。</p>
<hr>
<p><strong>两个重要命令：</strong></p>
<ul>
<li>ssh-keygen ：这个命令是用来生成本机的公钥和私钥的</li>
<li>ssh-keyscan ： 这条命令是用来把远程服务器的公钥来获取到本地的</li>
</ul>
<h2 id="首先关闭公钥认证"><a href="#首先关闭公钥认证" class="headerlink" title="首先关闭公钥认证"></a>首先关闭公钥认证</h2><p>如果说不想关闭公钥认证的话，可以用ssh-keycan 命令将公钥添加到本地的known_hosts文件里面去<br>具体命令是<code>ssh-keyscan IP1 (IP2 ...) &gt;&gt; /root/.ssh/known_hosts</code> 可以添加多个</p>
<p>Ansible1.2.1及其之后的版本都会默认启用公钥认证.</p>
<p>公钥认证就是如果之后的某一台客户端和之前登录过的某一台主机IP相同，那么在“known_hosts”中有了不同的key，这时会提示一个错误信息直到被纠正为止。<br>在使用Ansible时，可能不想遇到那样的情况，如果有个主机没有在“known_hosts”中被初始化将会导致在交互使用Ansible或定时执行Ansible时对key信息的确认提示。如果想要禁用这个行为的话，可以关闭公钥认证，而且公钥认证会比较慢，也是提高效率的一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 认证提示：</span><br><span class="line">&quot;msg&quot;: &quot;Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this. Please add this host&#x27;s fingerprint to your known_hosts file to manage this host.&quot;</span><br></pre></td></tr></table></figure>

<p>关闭公钥认证，编辑<code>ansible.cfg</code>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用来禁止ssh的指纹key字串检查</span><br><span class="line">host_key_checking = False</span><br></pre></td></tr></table></figure>
<p>或者直接设置环境变量：<code>export ANSIBLE_HOST_KEY_CHECKING=False</code></p>
<h2 id="使用ssh-key产生公钥和私钥"><a href="#使用ssh-key产生公钥和私钥" class="headerlink" title="使用ssh-key产生公钥和私钥"></a>使用ssh-key产生公钥和私钥</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可参考第一章节内容</span><br><span class="line">ssh-keygen -t dsa -f ~/.ssh/id_dsa -P &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="添加ansible-hosts-1"><a href="#添加ansible-hosts-1" class="headerlink" title="添加ansible hosts"></a>添加ansible hosts</h2><p><code>$vim /etc/ansible/hosts</code></p>
<blockquote>
<p>格式：【主机名】 【主机地址】 【主机密码】 默认是root用户来进行的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-servers]</span><br><span class="line">1 ansible_ssh_user=&quot;root&quot; ansible_ssh_host=10.122.60.68 ansible_ssh_pass=&quot;houjue1992***&quot;</span><br><span class="line">2 ansible_ssh_user=&quot;root&quot; ansible_ssh_host=10.122.60.83 ansible_ssh_pass=&quot;houjue1992***&quot;</span><br></pre></td></tr></table></figure>

<p>新版的ansible(2.4+) hosts有更新， 用以下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-servers]</span><br><span class="line">10.122.60.68 ansible_user=root ansible_ssh_pass=&quot;houjue1992***&quot;</span><br><span class="line">10.122.60.83 ansible_user=root ansible_ssh_pass=&quot;houjue1992***&quot;</span><br></pre></td></tr></table></figure>

<h2 id="批量推送公钥到远程机器"><a href="#批量推送公钥到远程机器" class="headerlink" title="批量推送公钥到远程机器"></a>批量推送公钥到远程机器</h2><h3 id="方法1：编写Playbook剧本文件"><a href="#方法1：编写Playbook剧本文件" class="headerlink" title="方法1：编写Playbook剧本文件"></a>方法1：编写Playbook剧本文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># put_ssh_pub_key.yml  是基于YAML语言编写的</span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  #gather_facts: no</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: install ssh key</span><br><span class="line">      authorized_key:</span><br><span class="line">        user: root</span><br><span class="line">        key: &quot;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;/root/.ssh/id_dsa.pub&#x27;) &#125;&#125;&quot;</span><br><span class="line">        state: present</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i hosts put_ssh_pub_key.yml</span><br></pre></td></tr></table></figure>

<h3 id="方法2：ansible命令行调用authorized-key模块"><a href="#方法2：ansible命令行调用authorized-key模块" class="headerlink" title="方法2：ansible命令行调用authorized_key模块"></a>方法2：ansible命令行调用authorized_key模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible nginx-server -m authorized_key -a &quot;user=root state=present key=&#x27;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;/root/.ssh/id_dsa.pub&#x27;) &#125;&#125;&#x27;&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过上面的方法，我们将ansible管理端的公钥批量推送后，就建立了ssh通道、实现了免密登录，这时<code>hosts</code>文件中配置的<code>ansible_user</code>和<code>ansible_ssh_pass</code>参数就没有用途了，我们需要进行安全优化操作，类似如下效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-servers]</span><br><span class="line">10.122.60.68</span><br><span class="line">10.122.60.83</span><br></pre></td></tr></table></figure>

<p>如果，ansible管理所有远程主机使用的账号密码是统一的一个，那么<code>hosts</code>文件中可以不进行账号信息的配置并保障了信息安全，而是执行ansible命令指定authorized_key模块时，通过<code>-k</code>选项，输入远程主机的统一密码，即可实现批量推送ssh公钥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible nginx-server -m authorized_key -a &quot;user=root state=present key=&#x27;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;/root/.ssh/id_dsa.pub&#x27;) &#125;&#125;&#x27;&quot; -k</span><br></pre></td></tr></table></figure>

<h2 id="5-ansible-playbook-免密登录优化"><a href="#5-ansible-playbook-免密登录优化" class="headerlink" title="5. ansible-playbook 免密登录优化"></a>5. ansible-playbook 免密登录优化</h2><p>占位符</p>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--  https://zhuanlan.zhihu.com/p/133998700  -->  
<!--  https://www.bookstack.cn/read/ansible-first-book/advance-inventory-zhi_ding_lian_jie_de_can_shu.md  -->
<!--  https://blog.51cto.com/13812615/2475306  -->
<!-- https://docs.ansible.com/ansible/2.8/modules/list_of_system_modules.html -->
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>实践总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Playbook基本语法</title>
    <url>/2019/07/10/ansible_py_basic_grammar/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="ansible-playbook命令行-more"><a href="#ansible-playbook命令行-more" class="headerlink" title="ansible-playbook命令行(more)"></a>ansible-playbook命令行<a href="https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html">(more)</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: ansible-playbook [-h] [--version] [-v] [-k]</span><br></pre></td></tr></table></figure>

<h3 id="常用命令行关键字"><a href="#常用命令行关键字" class="headerlink" title="常用命令行关键字"></a>常用命令行关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--ask-vault-password, --ask-vault-pass</span><br><span class="line">要求提供保管库密码</span><br><span class="line"></span><br><span class="line">--become-method &lt;BECOME_METHOD&gt;</span><br><span class="line">要使用的特权升级方法（默认= sudo），请使用ansible-doc -t成为-l列出有效的选择。</span><br><span class="line"></span><br><span class="line">--become-user &lt;BECOME_USER&gt;</span><br><span class="line">以该用户身份运行操作（默认= root）</span><br><span class="line"></span><br><span class="line">--flush-cache</span><br><span class="line">清除清单中每个主机的事实缓存</span><br><span class="line"></span><br><span class="line">--force-handlers</span><br><span class="line">即使任务失败也运行处理程序</span><br><span class="line"></span><br><span class="line">--list-hosts</span><br><span class="line">输出匹配主机列表；不执行其他任何操作</span><br><span class="line"></span><br><span class="line">--list-tags</span><br><span class="line">列出所有可用标签</span><br><span class="line"></span><br><span class="line">--list-tasks</span><br><span class="line">列出将要执行的所有任务</span><br><span class="line"></span><br><span class="line">--private-key &lt;PRIVATE_KEY_FILE&gt;, --key-file &lt;PRIVATE_KEY_FILE&gt;</span><br><span class="line">使用此文件来验证连接</span><br><span class="line"></span><br><span class="line">--scp-extra-args &lt;SCP_EXTRA_ARGS&gt;</span><br><span class="line">指定额外的参数以仅传递给scp（例如-l）</span><br><span class="line"></span><br><span class="line">--sftp-extra-args &lt;SFTP_EXTRA_ARGS&gt;</span><br><span class="line">指定额外的参数以仅传递给sftp（例如-f，-l）</span><br><span class="line"></span><br><span class="line">--skip-tags</span><br><span class="line">仅运行标签与这些值不匹配的剧本和任务</span><br><span class="line"></span><br><span class="line">--ssh-common-args &lt;SSH_COMMON_ARGS&gt;</span><br><span class="line">指定要传递给sftp / scp / ssh的通用参数（例如ProxyCommand）</span><br><span class="line"></span><br><span class="line">--ssh-extra-args &lt;SSH_EXTRA_ARGS&gt;</span><br><span class="line">指定额外的参数以仅传递给ssh（例如-R）</span><br><span class="line"></span><br><span class="line">--start-at-task &lt;START_AT_TASK&gt;</span><br><span class="line">在与此名称匹配的任务处启动剧本</span><br><span class="line"></span><br><span class="line">--step</span><br><span class="line">一步一步：在运行之前确认每个任务</span><br><span class="line"></span><br><span class="line">--syntax-check</span><br><span class="line">在剧本上执行语法检查，但不执行</span><br><span class="line"></span><br><span class="line">--vault-id</span><br><span class="line">要使用的库身份</span><br><span class="line"></span><br><span class="line">--vault-password-file, --vault-pass-file</span><br><span class="line">保险库密码文件</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line">显示程序的版本号，配置文件位置，配置的模块搜索路径，模块位置，可执行文件位置和退出</span><br><span class="line"></span><br><span class="line">-C, --check</span><br><span class="line">不要做任何改变；相反，尝试预测可能发生的某些变化</span><br><span class="line"></span><br><span class="line">-D, --diff</span><br><span class="line">更改（小的）文件和模板时，请显示这些文件中的差异；与–check一起使用效果很好</span><br><span class="line"></span><br><span class="line">-K, --ask-become-pass</span><br><span class="line">要求特权升级密码</span><br><span class="line"></span><br><span class="line">-M, --module-path</span><br><span class="line">将冒号分隔的路径添加到模块库（默认=〜/ .ansible / plugins / modules：/ usr / share / ansible / plugins / modules）</span><br><span class="line"></span><br><span class="line">-T &lt;TIMEOUT&gt;, --timeout &lt;TIMEOUT&gt;</span><br><span class="line">覆盖连接超时（以秒为单位）（默认为10）</span><br><span class="line"></span><br><span class="line">-b, --become</span><br><span class="line">使用变为运行操作（不表示提示输入密码）</span><br><span class="line"></span><br><span class="line">-c &lt;CONNECTION&gt;, --connection &lt;CONNECTION&gt;</span><br><span class="line">要使用的连接类型（默认=智能）</span><br><span class="line"></span><br><span class="line">-e, --extra-vars</span><br><span class="line">如果文件名以@开头，则将其他变量设置为key = value或YAML / JSON</span><br><span class="line"></span><br><span class="line">-f &lt;FORKS&gt;, --forks &lt;FORKS&gt;</span><br><span class="line">指定要使用的并行进程数（默认= 5）</span><br><span class="line"></span><br><span class="line">-h, --help</span><br><span class="line">显示此帮助消息并退出</span><br><span class="line"></span><br><span class="line">-i, --inventory, --inventory-file</span><br><span class="line">指定清单主机路径或逗号分隔的主机列表。–不推荐使用库存文件</span><br><span class="line"></span><br><span class="line">-k, --ask-pass</span><br><span class="line">询问连接密码</span><br><span class="line"></span><br><span class="line">-l &lt;SUBSET&gt;, --limit &lt;SUBSET&gt;</span><br><span class="line">将所选主机进一步限制为其他模式</span><br><span class="line"></span><br><span class="line">-t, --tags</span><br><span class="line">只运行带有这些值标记的剧本和任务</span><br><span class="line"></span><br><span class="line">-u &lt;REMOTE_USER&gt;, --user &lt;REMOTE_USER&gt;</span><br><span class="line">以该用户身份连接（默认=无）</span><br><span class="line"></span><br><span class="line">-v, --verbose</span><br><span class="line">详细模式（-vvv用于更多，-vvvv用于启用连接调试）</span><br></pre></td></tr></table></figure>

<h3 id="执行Playbook的语法"><a href="#执行Playbook的语法" class="headerlink" title="执行Playbook的语法"></a>执行Playbook的语法</h3><p><code>$ ansible-playbook deploy.yml</code><br>查看输出的细节<br><code>ansible-playbook playbook.yml --verbose</code><br>查看该脚本影响哪些hosts<br><code>ansible-playbook playbook.yml --list-hosts</code><br>并行执行脚本<br><code>ansible-playbook playbook.yml -f 10</code></p>
<h2 id="完整的playbook脚本示例"><a href="#完整的playbook脚本示例" class="headerlink" title="完整的playbook脚本示例"></a>完整的playbook脚本示例</h2><p>最基本的playbook脚本分为三个部分:</p>
<ol>
<li>在什么机器上以什么身份执行</li>
</ol>
<ul>
<li>hosts</li>
<li>users</li>
</ul>
<ol start="2">
<li>执行的任务是都有什么</li>
</ol>
<ul>
<li>tasks</li>
</ul>
<ol start="3">
<li>善后的任务都有什么</li>
</ol>
<ul>
<li>handlers</li>
</ul>
<blockquote>
<p>deploy.yml文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: webservers</span><br><span class="line">  vars:</span><br><span class="line">    http_port: 80</span><br><span class="line">    max_clients: 200</span><br><span class="line">  user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: ensure apache is at the latest version</span><br><span class="line">      yum: pkg=httpd state=latest</span><br><span class="line">    - name: write the apache config file</span><br><span class="line">      template: src=/srv/httpd.j2 dest=/etc/httpd.conf</span><br><span class="line">      notify:</span><br><span class="line">        - restart apache</span><br><span class="line">    - name: ensure apache is running</span><br><span class="line">      service: name=httpd state=started</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart apache</span><br><span class="line">      service: name=httpd state=restarted</span><br></pre></td></tr></table></figure>

<h2 id="playbook语法特性"><a href="#playbook语法特性" class="headerlink" title="playbook语法特性"></a>playbook语法特性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 以 --- (三个减号)开始，必须顶行写；</span><br><span class="line">2. 次行开始写Playbook的内容，但是一般要求写明该playbook的功能；</span><br><span class="line">3. 严格缩进，并且不能用Tab键缩进；</span><br><span class="line">4. 缩进级别必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的；</span><br><span class="line">5. K/V的值可同行写，也可换行写。同行使用 :分隔，换行写需要以 - 分隔；</span><br></pre></td></tr></table></figure>

<hr>
<p>&nbsp;  </p>
<!--  https://www.cnblogs.com/yanjieli/p/10969299.html  -->  
<!--  https://ansible-tran.readthedocs.io/en/latest/docs/playbooks.html  -->  
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>playbook中逻辑控制语句的使用</title>
    <url>/2019/07/12/ansible_py_control_words/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>playbook也有逻辑控制的语句：</p>
<ul>
<li>when： 条件判断语句，类似于编程语言中的if</li>
<li>loop： 循环语句，类似于编程语言的中的while</li>
<li>block： 把几个tasks组成一块代码，便于针对一组操作的异常处理等操作。</li>
</ul>
<h1 id="条件语句When"><a href="#条件语句When" class="headerlink" title="条件语句When"></a>条件语句When</h1><p>类似于编程语言的if</p>
<h2 id="When语句"><a href="#When语句" class="headerlink" title="When语句"></a>When语句</h2><p>有时候用户有可能需满足特定条件才执行某一个特定的步骤。例如，在某个特定版本的系统上装包，或者只在磁盘空间满了的文件系统上执行清理操作。这些操作在Playbook中用when语句实现。</p>
<p>主机为Debian Linux立刻关机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - name: &quot;shutdown Debian flavored systems&quot;</span><br><span class="line">    command: /sbin/shutdown -t now</span><br><span class="line">    when: ansible_os_family == &quot;Debian&quot;</span><br></pre></td></tr></table></figure>

<p>根据action的执行结果，来决定接下来执行的action。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - command: /bin/false</span><br><span class="line">    register: result</span><br><span class="line">    ignore_errors: True</span><br><span class="line">  - command: /bin/something</span><br><span class="line">    when: result|failed</span><br><span class="line">  - command: /bin/something_else</span><br><span class="line">    when: result|success</span><br><span class="line">  - command: /bin/still/something_else</span><br><span class="line">    when: result|skipped</span><br></pre></td></tr></table></figure>

<p>远程中的系统变量facts变量作为when的条件，用“|int”还可以转换返回值的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - debug: msg=&quot;only on Red Hat 7, derivatives, and later&quot;</span><br><span class="line">      when: ansible_os_family == &quot;RedHat&quot; and ansible_lsb.major_release|int &gt;= 6</span><br></pre></td></tr></table></figure>

<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">  epic: true</span><br></pre></td></tr></table></figure>

<p>基本款</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">    - shell: echo &quot;This certainly is epic!&quot;</span><br><span class="line">      when: epic</span><br></pre></td></tr></table></figure>

<p>否定款：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">    - shell: echo &quot;This certainly isn&#x27;t epic!&quot;</span><br><span class="line">      when: not epic</span><br></pre></td></tr></table></figure>

<p>变量定义款</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">    - shell: echo &quot;I&#x27;ve got &#x27;&#123;&#123; foo &#125;&#125;&#x27; and am not afraid to use it!&quot;</span><br><span class="line">      when: foo is defined</span><br><span class="line"></span><br><span class="line">    - fail: msg=&quot;Bailing out. this play requires &#x27;bar&#x27;&quot;</span><br><span class="line">      when: bar is not defined</span><br></pre></td></tr></table></figure>

<p>数值表达款</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">    - command: echo &#123;&#123; item &#125;&#125;</span><br><span class="line">      with_items: [ 0, 2, 4, 6, 8, 10 ]</span><br><span class="line">      when: item &gt; 5</span><br></pre></td></tr></table></figure>

<h2 id="与Include一起用"><a href="#与Include一起用" class="headerlink" title="与Include一起用"></a>与Include一起用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- include: tasks/sometasks.yml</span><br><span class="line">  when: &quot;&#x27;reticulating splines&#x27; in output&quot;</span><br></pre></td></tr></table></figure>

<h2 id="与Role一起用"><a href="#与Role一起用" class="headerlink" title="与Role一起用"></a>与Role一起用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">     - &#123; role: debian_stock_config, when: ansible_os_family == &#x27;Debian&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Loop循环"><a href="#Loop循环" class="headerlink" title="Loop循环"></a>Loop循环</h1><h2 id="标准循环"><a href="#标准循环" class="headerlink" title="标准循环"></a>标准循环</h2><p>为了保持简洁,重复的任务可以用以下简写的方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: add several users</span><br><span class="line">  user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel</span><br><span class="line">  with_items:</span><br><span class="line">     - testuser1</span><br><span class="line">     - testuser2</span><br></pre></td></tr></table></figure>

<p>如果你在变量文件中或者 ‘vars’ 区域定义了一组YAML列表,你也可以这样做:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">  somelist: [&quot;testuser1&quot;, &quot;testuser2&quot;]</span><br><span class="line">tasks:</span><br><span class="line">  -name: add several user</span><br><span class="line">   user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel</span><br><span class="line">   with_items: &quot;&#123;&#123;somelist&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>使用 ‘with_items’ 用于迭代的条目类型不仅仅支持简单的字符串列表.如果你有一个哈希列表,那么你可以用以下方式来引用子项:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: add several users</span><br><span class="line">  user: name=&#123;&#123; item.name &#125;&#125; state=present groups=&#123;&#123; item.groups &#125;&#125;</span><br><span class="line">  with_items:</span><br><span class="line">    - &#123; name: &#x27;testuser1&#x27;, groups: &#x27;wheel&#x27; &#125;</span><br><span class="line">    - &#123; name: &#x27;testuser2&#x27;, groups: &#x27;root&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果同时使用 when 和 with_items （或其它循环声明）,<code>when</code>声明会为每个条目单独执行.请参见 the_when_statement 示例.</p>
<h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h2><p>循环也可以嵌套:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: give users access to multiple databases</span><br><span class="line">  mysql_user: name=&#123;&#123; item[0] &#125;&#125; priv=&#123;&#123; item[1] &#125;&#125;.*:ALL append_privs=yes password=foo</span><br><span class="line">  with_nested:</span><br><span class="line">    - [ &#x27;alice&#x27;, &#x27;bob&#x27; ]</span><br><span class="line">    - [ &#x27;clientdb&#x27;, &#x27;employeedb&#x27;, &#x27;providerd&#x27;]</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: give users access to multiple databases</span><br><span class="line">  mysql_user: name=&#123;&#123; item.0 &#125;&#125; priv=&#123;&#123; item.1 &#125;&#125;.*:ALL append_privs=yes password=foo</span><br><span class="line">  with_nested:</span><br><span class="line">    - [ &#x27;alice&#x27;, &#x27;bob&#x27; ]</span><br><span class="line">    - [ &#x27;clientdb&#x27;, &#x27;employeedb&#x27;, &#x27;providerd&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="对哈希表使用循环"><a href="#对哈希表使用循环" class="headerlink" title="对哈希表使用循环"></a>对哈希表使用循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">vars:</span><br><span class="line">  users:</span><br><span class="line">    alice:</span><br><span class="line">      name: Alice Appleworth</span><br><span class="line">      telephone: 123-456-7890</span><br><span class="line">    bob:</span><br><span class="line">      name: Bob Bananarama</span><br><span class="line">      telephone: 987-654-3210</span><br><span class="line">tasks:</span><br><span class="line">  - name: Print phone records</span><br><span class="line">    debug: msg=&quot;User &#123;&#123; item.key &#125;&#125; is &#123;&#123; item.value.name &#125;&#125; (&#123;&#123; item.value.telephone &#125;&#125;)&quot;</span><br><span class="line">    with_dict: &quot;&#123;&#123;users&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="对文件列表使用循环"><a href="#对文件列表使用循环" class="headerlink" title="对文件列表使用循环"></a>对文件列表使用循环</h2><p>with_fileglob 可以以非递归的方式来模式匹配单个目录中的文件.如下面所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line"></span><br><span class="line">    # first ensure our target directory exists</span><br><span class="line">    - file: dest=/etc/fooapp state=directory</span><br><span class="line"></span><br><span class="line">    # copy each file over that matches the given pattern</span><br><span class="line">    - copy: src=&#123;&#123; item &#125;&#125; dest=/etc/fooapp/ owner=root mode=600</span><br><span class="line">      with_fileglob:</span><br><span class="line">        - /playbooks/files/fooapp/*</span><br></pre></td></tr></table></figure>

<h1 id="Block块"><a href="#Block块" class="headerlink" title="Block块"></a>Block块</h1><p>多个action组装成块，可以根据不同条件执行一段语句 ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">yum:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=installed</span></span><br><span class="line">      <span class="attr">with_items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">httpd</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">memcached</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">src=templates/src.j2</span> <span class="string">dest=/etc/foo.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">name=bar</span> <span class="string">state=started</span> <span class="string">enabled=True</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_distribution</span> <span class="string">==</span> <span class="string">&#x27;CentOS&#x27;</span></span><br><span class="line">    <span class="attr">become:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">become_user:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>组装成块处理异常更方便：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&#x27;i</span> <span class="string">execute</span> <span class="string">normally&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">command:</span> <span class="string">/bin/false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&#x27;i</span> <span class="string">never</span> <span class="string">execute,</span> <span class="string">cause</span> <span class="string">ERROR!&#x27;</span></span><br><span class="line">    <span class="attr">rescue:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&#x27;I</span> <span class="string">caught</span> <span class="string">an</span> <span class="string">error&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">command:</span> <span class="string">/bin/false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&#x27;I</span> <span class="string">also</span> <span class="string">never</span> <span class="string">execute</span> <span class="string">:-(&#x27;</span></span><br><span class="line">    <span class="attr">always:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;this</span> <span class="string">always</span> <span class="string">executes&quot;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Role - Playbook的“Package”</title>
    <url>/2019/07/12/ansible_play_role_care/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Role-Playbook的“Package”"><a href="#Role-Playbook的“Package”" class="headerlink" title="Role - Playbook的“Package”"></a><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#role-directory-structure">Role</a> - Playbook的“Package”</h1><p>Role是比include更强大灵活的代码重用和分享机制。Include类似于编程语言中的include，是重用单个文件的，功能有限。</p>
<p>而Role类似于编程语言中的“Package”，可以重用一组文件形成完整的功能。例如安装和配置apache，需要tasks实现安装包和拷贝模版等，httpd.conf和index.html的模版文件，和handler文件实现重起功能。这些文件都可以放在一个role里面，供不同的playbook文件重用。</p>
<p>Ansible非常提倡在playbook中使用role，并且提供了一个分享role的平台Ansible Galaxy, <a href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a>, 在galaxy上可以找到别人写好的role。在后面的章节中，我们再详细介绍如何使用它。</p>
<h2 id="定义role完整的目录结构"><a href="#定义role完整的目录结构" class="headerlink" title="定义role完整的目录结构"></a>定义role完整的目录结构</h2><p><strong>在ansible中,通过遵循特定的目录结构,就可以实现对role的定义。</strong>。具体遵循的目录结构是什么呢？看下面的例子：</p>
<p>下面的目录结构定义了一个role：名字为myrole。在site.yml，调用了这个role。</p>
<table>
    <tr>
        <td>
            role的目录结构
        </td>
        <td>
            site.yml中调用role
        </td>
    </tr>
    <tr>
        <td>
            <pre>
<code class='lang-yml'>
site.yml
roles/
├── myrole
    ├── tasks
    │ └── main.yml
    ├── handlers
    │ └── main.yml
    ├── defaults
    │ └── main.yml
    ├── vars
    │ └── main.yml
    ├── files
    ├── templates
    ├── README.md
    ├── meta
    │ └── main.yml


</code>
</pre>
        </td>
        <td>
            <pre>
<code>
---
- hosts: webservers
  roles:
     - myrole
</code>
</pre>
        </td>
    </tr>
</table>

<p>ansible并不要求role包含上述所有的目录及文件，根据role的功能需要加入对应的目录和文件。下面是每个目录和文件的功能。</p>
<ul>
<li>如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中，所以这个文件也可以视作role的入口文件，想看role做了什么操作，可以从此文件看起。</li>
<li>如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中</li>
<li>如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中</li>
<li>如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中</li>
<li>roles/x/tasks/main.yml中所有tasks，可以引用 roles/x/{files,templates,tasks}中的文件，不需要指明文件的路径。</li>
</ul>
<p>你自己在写role的时候，一般都要包含role入口文件roles/x/tasks/main.yml，其它的文件和目录，可以根据需求选择加入。</p>
<p>学会写一个功能完整的role是一个相对复杂的过程，也是ansible中较高级的使用方法。在本小节，我们重点介绍如何使用别人已经写好的role。在后面的章节中，我们会通过具体的示例来逐步介绍写role的所需的知识。</p>
<h2 id="带参数的Role"><a href="#带参数的Role" class="headerlink" title="带参数的Role"></a>带参数的Role</h2><h3 id="参数在role中是如何定义的呢"><a href="#参数在role中是如何定义的呢" class="headerlink" title="参数在role中是如何定义的呢"></a>参数在role中是如何定义的呢</h3><p> 定义一个带参数的role,名字是myrole,那么目录结构为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.yml</span><br><span class="line">roles</span><br><span class="line">  role_with_var</span><br><span class="line">    tasks</span><br><span class="line">      main.yml</span><br></pre></td></tr></table></figure>

<p> 在roles/myrole/tasks/main.yml中,使用<code>&#123;&#123; &#125;&#125;</code>定义的变量就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- name: use param</span><br><span class="line">  debug: msg=&quot;&#123;&#123; param &#125;&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用带参数的role"><a href="#使用带参数的role" class="headerlink" title="使用带参数的role"></a>使用带参数的role</h3><p>那么在main.yml就可以用如下的方法使用myrole</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - &#123; role: myrole, param: &#x27;Call some_role for the 1st time&#x27; &#125;</span><br><span class="line">    - &#123; role: myrole, param: &#x27;Call some_role for the 2nd time&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>或者写成YAML字典格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - role: myrole</span><br><span class="line">      param: &#x27;Call some_role for the 1st time&#x27;</span><br><span class="line">    - role: myrole</span><br><span class="line">      param: &#x27;Call some_role for the 2nd time&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="role指定默认的参数"><a href="#role指定默认的参数" class="headerlink" title="role指定默认的参数"></a>role指定默认的参数</h3><p>指定默认参数后,如果在调用时传参数了,那么就使用传入的参数值.如果调用的时候没有传参数,那么就使用默认的参数值.</p>
<p>指定默认参数很简单,以上面的role_with_var为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.yml</span><br><span class="line">roles:</span><br><span class="line">  myrole</span><br><span class="line">    tasks</span><br><span class="line">      main.yml</span><br><span class="line">    defaults</span><br><span class="line">      main.yml</span><br></pre></td></tr></table></figure>
<p>在roles/myrole/defaults/main.yml中,使用yml的字典定义语法定义param的值,如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">param: &quot;I am the default value&quot;</span><br></pre></td></tr></table></figure>

<p>这样在main.yml中,下面两种调用方法都可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - role_with_var</span><br><span class="line">    - &#123; role: role_with_var, param: &#x27;I am the value from external&#x27; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多的例子在<a href="https://github.com/shijingjing1221/ansible-first-book-examples/blob/master/role_vars.yml">ansible-first-book</a>中</p>
<h2 id="role与条件语句when一起执行"><a href="#role与条件语句when一起执行" class="headerlink" title="role与条件语句when一起执行"></a>role与条件语句when一起执行</h2><p>下面的例子中,my_role只有在RedHat系列的server上才执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - &#123; role: my_role, when: &quot;ansible_os_family == &#x27;RedHat&#x27;&quot; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样也可以写成YAML字典格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - role: my_role</span><br><span class="line">      when: &quot;ansible_os_family == &#x27;RedHat&#x27;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="roles和tasks的执行顺序"><a href="#roles和tasks的执行顺序" class="headerlink" title="roles和tasks的执行顺序"></a>roles和tasks的执行顺序</h2><p>如果一个playbook同时出现role和tasks，他们的调用顺序是什么样的呢？</p>
<p>先揭晓答案，再根据实例来验证：</p>
<p><strong>pre_tasks &gt; role &gt; tasks &gt; post_tasks</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: lb</span><br><span class="line">  user: root</span><br><span class="line"></span><br><span class="line">  pre_tasks:</span><br><span class="line">    - name: pre</span><br><span class="line">      shell: echo &#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line">  roles:</span><br><span class="line">    - &#123; role: some_role &#125;</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: task</span><br><span class="line">      shell: echo &#x27;still busy&#x27;</span><br><span class="line"></span><br><span class="line">  post_tasks:</span><br><span class="line">    - name: post</span><br><span class="line">      shell: echo &#x27;goodbye&#x27;</span><br></pre></td></tr></table></figure>

<p>执行的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAY [lb] **********************************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TASK [setup] *******************************************************************</span><br><span class="line">ok: [rhel7u3]</span><br><span class="line"></span><br><span class="line">TASK [pre] *********************************************************************</span><br><span class="line">changed: [rhel7u3]</span><br><span class="line"></span><br><span class="line">TASK [some_role : some role] ***************************************************</span><br><span class="line">ok: [rhel7u3] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Im some role&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [task] ********************************************************************</span><br><span class="line">changed: [rhel7u3]</span><br><span class="line"></span><br><span class="line">TASK [post] ********************************************************************</span><br><span class="line">changed: [rhel7u3]</span><br><span class="line"></span><br><span class="line">PLAY RECAP *********************************************************************</span><br><span class="line">rhel7u3 : ok=5 changed=3 unreachable=0 failed=0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible 远程Windows主机</title>
    <url>/2019/07/22/ansible_remote_win/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Windows客户端配置"><a href="#Windows客户端配置" class="headerlink" title="Windows客户端配置"></a>Windows客户端配置</h2><p>Powershell请在标准镜像中进行预配置，以降低人员成本。</p>
<h3 id="PowerShell-升级至4-0"><a href="#PowerShell-升级至4-0" class="headerlink" title="PowerShell 升级至4.0+"></a>PowerShell 升级至4.0+</h3><p>Windows机器需要安装或升级powershell4.0以上版本，升级PowerShell步骤：</p>
<ol>
<li>检查powershell版本<br><code>$PSVersionTable</code></li>
<li>下载并安装 <a href="https://pan.baidu.com/s/1p4uZs0k3aaShmVGBsbpD4g">PowerShell 4.0</a>（提取码：c7kl ）： </li>
</ol>
<ul>
<li>Microsoft .NET Framework 4.5</li>
<li>powershell4.0( Windows Management Framework 4.0 )</li>
</ul>
<p><strong>注意</strong> ：先安装.NET Framework 4.5 ，而后安装powershell4.0</p>
<blockquote>
<p>关于Windows已内置的Powershell版本说明：</p>
</blockquote>
<pre><code>Powershell是运行在Windows机器上实现系统和应用程序管理自动化的命令行脚本环境。 需要.NET环境的支持，
同时支持.NET对象。当前PowerShell有5个版本，分别为1.0、2.0、3.0、4.0、5.0
如果系统是Windows 7或者Windows Server 2008 R2，那么PowerShell 2.0已经内置了，可以升级为3.0或4.0版本 
如果系统是Windows Server 2012，那么PowerShell 3.0已经内置了，可以升级为4.0版本
如果系统是Windows 8.1或者Windows server 2012 R2，那么默认已经是4.0版本
如果系统是Windows Server 2016或者Windows 10，那么默认为5.0版本
</code></pre>
<h3 id="配置winrm，启用powershell远程管理"><a href="#配置winrm，启用powershell远程管理" class="headerlink" title="配置winrm，启用powershell远程管理"></a>配置winrm，启用powershell远程管理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看powershell版本</span><br><span class="line">get-host</span><br><span class="line"># 查看powershell执行策略</span><br><span class="line">get-executionpolicy</span><br><span class="line"># 更改powershell执行策略为remotesigned</span><br><span class="line">set-executionpolicy remotesigned</span><br><span class="line"># 配置winrm service并启动服务</span><br><span class="line">winrm quickconfig</span><br><span class="line"># 查看winrm service启动监听状态</span><br><span class="line">winrm enumerate winrm/config/listener</span><br><span class="line"># 修改winrm配置，启用远程连接认证</span><br><span class="line">winrm set winrm/config/service/auth &#x27;@&#123;Basic=&quot;true&quot;&#125;&#x27;</span><br><span class="line">winrm set winrm/config/service &#x27;@&#123;AllowUnencrypted=&quot;true&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="Ansible服务端配置"><a href="#Ansible服务端配置" class="headerlink" title="Ansible服务端配置"></a>Ansible服务端配置</h2><h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><p>安装request2.9版本依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip install -I requests==2.9</span><br></pre></td></tr></table></figure>
<p>安装winrm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip install pywinrm</span><br></pre></td></tr></table></figure>

<h3 id="编写剧本测试连接Windows"><a href="#编写剧本测试连接Windows" class="headerlink" title="编写剧本测试连接Windows"></a>编写剧本测试连接Windows</h3><p>编辑<code>/etc/ansible/hosts</code>，添加客户端主机信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[windows]</span><br><span class="line">172.16.10.23 ansible_ssh_user=&quot;Administrator&quot; ansible_ssh_pass=&quot;123123&quot; ansible_ssh_port=5985 ansible_connection=&quot;winrm&quot; ansible_winrm_server_cert_validation=ignore</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要的主机变量：</p>
</blockquote>
<ul>
<li>ansible_ssh_user: </li>
<li>ansible_ssh_password: </li>
<li>ansible_ssh_port: 5986</li>
<li>ansible_connection: winrm</li>
<li>ansible_winrm_server_cert_validation: ignore</li>
</ul>
<p>测试ping探测windows客户主机是否存活</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible 172.16.10.23 -m win_ping</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>实践总结</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>playbook常见的变量分类与变量优先级</title>
    <url>/2019/07/10/ansible_var_categores/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="playbook常见的变量分类"><a href="#playbook常见的变量分类" class="headerlink" title="playbook常见的变量分类"></a>playbook常见的变量分类</h2><p>在Playbook中常用的几种变量包含一下几种情况：</p>
<ol>
<li>在Playbook中用户<code>自定义的变量</code>。—var*|other</li>
<li>用户无需自定义，Ansible会在执行Playbook之前去全程主机上搜集的关于远程节点<code>系统信息的变量</code>。—ansible setup模块</li>
<li>在文件模版中，可以直接使用上述两种变量</li>
<li>把task的运行结果作为一个变量来使用，这个变量叫做<code>注册变量</code>。—register</li>
<li>为了使Playbook更灵活、通用性更强，允许用户在执行的时候传入变量的值，这个时候就需要用到<code>额外变量</code>。</li>
</ol>
<h2 id="Ansible变量优先级（由高到低）"><a href="#Ansible变量优先级（由高到低）" class="headerlink" title="Ansible变量优先级（由高到低）"></a>Ansible变量优先级（由高到低）</h2><p>extra vars (在命令行中使用 -e)优先级最高：ansible-playbook -e var=value<br>task变量<br>block变量<br>role中定义的变量和include变量<br>set_fact<br>registered变量<br>vars_files<br>var_prompt<br>play变量<br>host facts<br>playbook中设置的host_vars<br>playbook中设置的group_vars<br>inventory中设置的host_vars<br>inventory中设置的group_vars<br>inventory变量<br>role中defaults/main.yml中定义的变量</p>
<hr>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>env</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>playbook常见的变量的使用方法</title>
    <url>/2019/07/11/ansible_play_var_use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="一、Playbook中vars关键字定义的变量"><a href="#一、Playbook中vars关键字定义的变量" class="headerlink" title="一、Playbook中vars关键字定义的变量"></a>一、Playbook中vars关键字定义的变量</h1><h2 id="Playbook中定义和使用的变量的方法"><a href="#Playbook中定义和使用的变量的方法" class="headerlink" title="Playbook中定义和使用的变量的方法"></a>Playbook中定义和使用的变量的方法</h2><p>用户可以在Playbook中，通过vars关键字自定义变量，使用时用<code>&#123;&#123; &#125;&#125;</code>引用以来即可。</p>
<p>下面的例子中，用户定义变量名为http_port，其值为为80。在tasks firewalld中，通过<code>&#123;&#123; &#125;&#125;</code>引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- hosts: web</span><br><span class="line">  vars:</span><br><span class="line">    http_port: 80</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: insert firewalld rule for httpd</span><br><span class="line">    firewalld: port=&#123;&#123; http_port &#125;&#125;/tcp permanent=true state=enabled immediate=yes</span><br></pre></td></tr></table></figure>

<h2 id="把变量放在单独的文件中"><a href="#把变量放在单独的文件中" class="headerlink" title="把变量放在单独的文件中"></a>把变量放在单独的文件中</h2><p>当变量比较多的时候，或者变量需要在多个playbook中重用的时候，可以把变量放到一个单独的文件中。通过关键字<code>var_files</code>把文件中定义的变量引入playbook中，使用变量的方法和在本文件中定义的变量相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars_files:</span><br><span class="line">    - vars/server_vars.yml</span><br><span class="line">  tasks:</span><br><span class="line">  - name: insert firewalld rule for httpd</span><br><span class="line">    firewalld: port=&#123;&#123; http_port &#125;&#125;/tcp permanent=true state=enabled immediate=yes</span><br></pre></td></tr></table></figure>

<p>变量文件vars/server_vars.yml的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_port: 80</span><br></pre></td></tr></table></figure>

<h2 id="定义和使用复杂变量"><a href="#定义和使用复杂变量" class="headerlink" title="定义和使用复杂变量"></a>定义和使用复杂变量</h2><p>有时候我们需要使用的变量的值不是简单的字符串或者数字，而是一个对象。这时候定义的语法如下，格式为YAML的字典格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo:</span><br><span class="line">  field1: one</span><br><span class="line">  field2: two</span><br></pre></td></tr></table></figure>

<p>访问复杂变量中的子属性，可以利用中括号或者点号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo[&#x27;field1&#x27;]</span><br><span class="line">foo.field1</span><br></pre></td></tr></table></figure>

<h2 id="YAML的陷阱"><a href="#YAML的陷阱" class="headerlink" title="YAML的陷阱"></a>YAML的陷阱</h2><p>YAML的陷阱是某些时候YAML和Ansible Playbook的变量语法不能在一起好好工作了。这里仅发生在指冒号后面的值不能以{开头的时候，如果有必要以{开头，必须加上引号。总之在YAML值的定义中，如果提示YMAL语法错误，都可以尝试下加入引号来解决。<br>下面的代码会报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- hosts: app_servers</span><br><span class="line">  vars:</span><br><span class="line">    app_path: &#123;&#123; base_path &#125;&#125;/22</span><br></pre></td></tr></table></figure>

<p>解决办法：要在”{ “开始的值<strong>加上引号</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- hosts: app_servers</span><br><span class="line">  vars:</span><br><span class="line">     app_path: &quot;&#123;&#123; base_path &#125;&#125;/22&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二、主机的系统变量-gather-facts"><a href="#二、主机的系统变量-gather-facts" class="headerlink" title="二、主机的系统变量(gather_facts)"></a>二、主机的系统变量(gather_facts)</h1><p>ansible会通过<code>module setup</code>来收集主机的系统信息，这些收集到的系统信息叫做<code>facts</code>，这些<code>facts</code>信息可以直接以变量的形式使用。<br>哪些<code>facts</code>变量可以引用呢？在命令行上通过调用<code>setup module</code>命令可以查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ansible all -m setup -u root</span><br></pre></td></tr></table></figure>

<p>怎样在playbook中使用facts变量呢，答案是直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: echo system</span><br><span class="line">    shell: echo &#123;&#123; ansible_os_family &#125;&#125;</span><br><span class="line">  - name install ntp on Debian linux</span><br><span class="line">    apt: name=git state=installed</span><br><span class="line">    when: ansible_os_family == &quot;Debian&quot;</span><br><span class="line">  - name install ntp on redhat linux</span><br><span class="line">    yum: name=git state=present</span><br><span class="line">    when: ansible_os_family == &quot;RedHat&quot;</span><br></pre></td></tr></table></figure>

<p>使用复杂facts变量<br>一般在系统中收集到如下的信息，复杂的、多层级的facts变量如何使用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        &quot;ansible_ens3&quot;: &#123;</span><br><span class="line">            &quot;active&quot;: true, </span><br><span class="line">            &quot;device&quot;: &quot;ens3&quot;, </span><br><span class="line">            &quot;ipv4&quot;: &#123;</span><br><span class="line">                &quot;address&quot;: &quot;10.66.192.234&quot;, </span><br><span class="line">                &quot;netmask&quot;: &quot;255.255.254.0&quot;, </span><br><span class="line">                &quot;network&quot;: &quot;10.66.192.0&quot;</span><br><span class="line">            &#125;, </span><br><span class="line">            &quot;ipv6&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;address&quot;: &quot;2620:52:0:42c0:5054:ff:fef2:e2a3&quot;, </span><br><span class="line">                    &quot;prefix&quot;: &quot;64&quot;, </span><br><span class="line">                    &quot;scope&quot;: &quot;global&quot;</span><br><span class="line">                &#125;, </span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;address&quot;: &quot;fe80::5054:ff:fef2:e2a3&quot;, </span><br><span class="line">                    &quot;prefix&quot;: &quot;64&quot;, </span><br><span class="line">                    &quot;scope&quot;: &quot;link&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ], </span><br><span class="line">            &quot;macaddress&quot;: &quot;52:54:00:f2:e2:a3&quot;, </span><br><span class="line">            &quot;module&quot;: &quot;8139cp&quot;, </span><br><span class="line">            &quot;mtu&quot;: 1500, </span><br><span class="line">            &quot;promisc&quot;: false, </span><br><span class="line">            &quot;type&quot;: &quot;ether&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么可以通过下面的两种方式访问复杂的变量中的子属性:<br>中括号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; ansible_ens3[&quot;ipv4&quot;][&quot;address&quot;] &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>点号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; ansible_ens3.ipv4.address &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭facts"><a href="#关闭facts" class="headerlink" title="关闭facts"></a>关闭facts</h2><p>在Playbook中,如果写gather_facts来控制是否收集远程系统的信息.如果不收集系统信息,那么上面的变量就不能在该playybook中使用了.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- hosts: whatever</span><br><span class="line">  gather_facts: no</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三、template文件模板中使用的变量"><a href="#三、template文件模板中使用的变量" class="headerlink" title="三、template文件模板中使用的变量"></a>三、template文件模板中使用的变量</h1><h2 id="template变量的定义-more"><a href="#template变量的定义-more" class="headerlink" title="template变量的定义(more)"></a>template变量的定义<a href="https://ansible-book.gitbooks.io/ansible-first-book/advance/playbook/tamplatezhong_shi_yong_bian_liang.html">(more)</a></h2><p>在playbook中定义的变量，可以直接在template中使用，同时facts变量也可以直接在template中使用，当然也包含在inventory里面定义的host和group变量。只要是在playbook中可以访问的变量，都可以在template文件中使用。</p>
<hr>
<h1 id="四、把task运行结果进行注册变量"><a href="#四、把task运行结果进行注册变量" class="headerlink" title="四、把task运行结果进行注册变量"></a>四、把task运行结果进行注册变量</h1><p>把task的执行结果也可以作为一个变量值。这个时候就需要用到<code>register</code>关键字实现<code>注册变量</code>，将执行结果注册到一个变量中，待后面的action使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: web</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">     - shell: ls</span><br><span class="line">       register: result</span><br><span class="line">       ignore_errors: True</span><br><span class="line"></span><br><span class="line">     - shell: echo &quot;&#123;&#123; result.stdout &#125;&#125;&quot;</span><br><span class="line">       when: result.rc == 5</span><br><span class="line"></span><br><span class="line">     - debug: msg=&quot;&#123;&#123; result.stdout &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p><code>注册变量</code>经常和<code>debug module</code>一起使用，这样可以得到更多action的输出信息，帮助用户调试。</p>
<hr>
<h1 id="五、playbook-命令行变量传值"><a href="#五、playbook-命令行变量传值" class="headerlink" title="五、playbook 命令行变量传值"></a>五、playbook 命令行变量传值</h1><p>为了使Playbook更灵活、通用性更强，允许用户在执行的时候传入变量的值，这个时候就需要用到“额外变量”。</p>
<h2 id="定义命令行变量"><a href="#定义命令行变量" class="headerlink" title="定义命令行变量"></a>定义命令行变量</h2><p>在release.yml文件里，<code>hosts和user</code>都定义为变量，需要从命令行传递变量值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: &#x27;&#123;&#123; hosts &#125;&#125;&#x27;</span><br><span class="line">  remote_user: &#x27;&#123;&#123; user &#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">     - ...</span><br></pre></td></tr></table></figure>

<h2 id="使用命令行变量"><a href="#使用命令行变量" class="headerlink" title="使用命令行变量"></a>使用命令行变量</h2><p>在命令行里面传值得的方法：<br><code>ansible-playbook e33_var_in_command.yml --extra-vars &quot;hosts=web user=root&quot;</code><br>还可以用json格式传递参数：<br><code>ansible-playbook e33_var_in_command.yml --extra-vars &quot;&#123;&#39;hosts&#39;:&#39;vm-rhel7-1&#39;, &#39;user&#39;:&#39;root&#39;&#125;&quot;</code><br>还可以将参数放在文件里面：<br><code>ansible-playbook e33_var_in_command.yml --extra-vars &quot;@vars.json&quot;</code></p>
<hr>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>ansible基础</tag>
        <tag>playbook</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义创建 Amazon EBS 支持的AMI</title>
    <url>/2020/08/26/aws_ami_1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/creating-an-ami-ebs.html">创建 Amazon EBS 支持的 Linux AMI</a></li>
</ul>
<hr>
<p>自定义AMI，可以让我们结合日常工作，预置好一些应用程序或配置，以缩短配置耗时。</p>
<p>此外，您还可以借助自定义 AMI 对底层组件 (如 Linux 内核) 进行更改，这在配置文件中很难实现或需要很长时间才能完成。</p>
<p>AMI 包括以下内容：</p>
<ul>
<li>一个或多个 Amazon Elastic Block Store (Amazon EBS) 快照；对于由实例存储支持的 AMI，包括一个用于实例（例如，操作系统、应用程序服务器和应用程序）根卷的模板。</li>
<li>控制可以使用 AMI 启动实例的 AWS 账户的启动许可。</li>
<li>数据块设备映射，指定在实例启动时要附加到实例的卷。</li>
</ul>
<h2 id="选择适合的AMI"><a href="#选择适合的AMI" class="headerlink" title="选择适合的AMI"></a>选择适合的AMI</h2><p>可以基于以下特性选择要使用的 AMI：</p>
<ul>
<li>区域 (请参阅区域和可用区)</li>
<li>操作系统</li>
<li>架构 (32 位或 64 位)</li>
<li>启动许可</li>
<li>根设备存储</li>
</ul>
<h2 id="AMI类型"><a href="#AMI类型" class="headerlink" title="AMI类型"></a>AMI类型</h2><p><strong>确定 AMI 的根设备类型</strong><br>使用控制台确定 AMI 的根设备类型：</p>
<ol>
<li>打开 Amazon EC2 控制台。</li>
<li>在导航窗格中，单击 AMI，然后选择 AMI。</li>
<li>在 <strong>Details (详细信息)</strong> 选项卡中检查 <strong>Root Device Type(根设备类型)</strong> 的值，如下所示：<ul>
<li>如果值是 <code>ebs</code>，则是 Amazon EBS 支持的 AMI。</li>
<li>如果值是 <code>instance store</code>，则是实例存储支持的 AMI。</li>
</ul>
</li>
</ol>
<p><strong>停止状态</strong><br><code>您可以停止由 Amazon EBS 支持的实例，但不能停止由 Amazon EC2 实例存储支持的实例</code>。停止操作会导致实例停止运行 (它的状态会由 running 变成 stopping 再到 stopped)。停止的实例保留在 Amazon EBS 中，这样就可重新启动。停止与终止不同；您无法重新启动一个已终止的实例。因为由 Amazon EC2 实例存储支持的实例不能被停止，所以它们要么在运行要么已经终止。</p>
<p><strong>如何收费</strong><br>如果您使用由实例存储提供支持的 AMI，您需要为实例使用和在 Amazon S3 中存储 AMI 付费。如果您使用由 Amazon EBS 支持的 AMI，您需要为实例使用、Amazon EBS 卷的存储和使用、以 Amazon EBS 快照形式存储 AMI 付费。</p>
<p>如果您使用由 Amazon EC2 实例存储支持的 AMI，当您每次自定义以及新建一个 AMI 时，所有分段都存储在每个 AMI 的 Amazon S3 中。因此，每个自定义 AMI 的存储占用空间都是 AMI 的完整大小。对于由 Amazon EBS 支持的 AMI，当您每次自定义以及新建 AMI 时，将仅存储更改内容。因此，您之后自定义的 AMI 的存储占用空间比首次自定义的 AMI 要小得多，从而降低 AMI 存储费用。</p>
<p>当由 Amazon EBS 支持的实例停止时，您无需再为实例使用付费；但是，您仍需为卷存储付费。一旦您启动实例时，我们便会收取最低一分钟的使用费用。一分钟之后，我们仅按您使用的秒数收费。例如，如果您运行一个实例 20 秒后停止实例，我们将按一整分钟收取费用。如果您运行一个实例 3 分 40 秒，我们将收取 3 分 40 秒的使用费用。我们将对您的实例保持运行状态的每秒钟收取费用，最低一分钟，即使实例处于闲置状态并且您没有连接到它也是如此。</p>
<h2 id="创建镜像的注意事项"><a href="#创建镜像的注意事项" class="headerlink" title="创建镜像的注意事项"></a>创建镜像的注意事项</h2><p>“不重启” 选项<code>必须勾选</code>，否则在做映像的时候，会自动重启你的机器<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/cami_20200824153435.png?x-oss-process=style/original_format"></p>
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>AMI</tag>
      </tags>
  </entry>
  <entry>
    <title>Amazon EBS卷的使用</title>
    <url>/2020/08/26/aws_ebs_use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ebs-attaching-volume.html">创建 Amazon EBS 卷</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ebs-attaching-volume.html">将 Amazon EBS 卷附加到实例</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ebs-creating-snapshot.html">创建 Amazon EBS 快照</a></li>
</ul>
<hr>
<p>Amazon Elastic Block Store (Amazon EBS) 提供了块级存储卷以用于 EC2 实例。EBS 卷的行为类似于原始、未格式化的块储存设备。您可以将这些卷作为设备挂载在实例上。附加到 EBS 实例的卷公开为独立于实例生命周期而持续存在的存储卷。您可以在这些卷上创建文件系统，或者以使用块储存设备（如硬盘）的任何方式使用这些卷。您可以动态更改附加到实例的卷的配置。</p>
<p>建议为必须能够快速访问且需要长期保存的数据使用 Amazon EBS。EBS 卷特别适合用作文件系统和数据库的主存储，还适用于任何需要细粒度更新及访问原始的、未格式化的块级存储的应用程序。Amazon EBS 非常适合依赖随机读写操作的数据库式应用程序以及执行长期持续读写操作的吞吐量密集型应用程序。</p>
<h2 id="Amazon-EBS卷的使用"><a href="#Amazon-EBS卷的使用" class="headerlink" title="Amazon EBS卷的使用"></a>Amazon EBS卷的使用</h2><p><strong>创建卷的方法</strong></p>
<ul>
<li>在指定块储存设备映射用以启动实例时，创建并附加 EBS 卷。</li>
<li>创建空 EBS 卷并将其附加到运行的实例。</li>
<li>从以前创建的快照中创建 EBS 卷，并将其附加到运行的实例（用于资源恢复）</li>
</ul>
<h2 id="创建-Amazon-EBS-快照"><a href="#创建-Amazon-EBS-快照" class="headerlink" title="创建 Amazon EBS 快照"></a>创建 Amazon EBS 快照</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>创建快照时需考虑以下事项：</p>
<ul>
<li>当您为充当根设备的 EBS 卷创建快照时，应在<code>拍摄快照之前停止实例</code>。</li>
<li>无法从启用了休眠的实例创建快照。</li>
<li>无法从已休眠实例创建快照。</li>
<li>尽管您可以在某个卷的前一个快照处于 pending 状态时拍摄该卷的快照，但一个卷有多个 pending 快照可能会导致该卷的性能降低，直至这些快照完成。</li>
<li>一个 gp2、io1、io2 或 磁介质 卷最多可有 5 个 pending 快照，而一个 st1 或 sc1 卷只能有 1 个 pending 快照。如果您在尝试给同一个卷创建多个并发快照时收到 ConcurrentSnapshotLimitExceeded 错误，请等待一个或多个 pending 快照完成，然后再为该卷创建另一个快照。</li>
<li>在从具有 AWS Marketplace 产品代码的卷创建快照后，该卷的产品代码将会传送到该快照。</li>
</ul>
<h3 id="AWS-EC2的snapshot创建与恢复"><a href="#AWS-EC2的snapshot创建与恢复" class="headerlink" title="AWS EC2的snapshot创建与恢复"></a>AWS EC2的snapshot创建与恢复</h3><p><strong>创建snapshot</strong>：</p>
<ul>
<li>点击<code>EBS&gt;快照</code>，创建快照&gt;选择EC2的<code>根设备</code>的卷ID(拍摄快照之前停止实例)</li>
</ul>
<p><strong>通过snapshot恢复EC2</strong>：</p>
<ul>
<li>按照原EC2配置创建一个新实例（正常启动）</li>
<li>停止新实例，删除默认<code>根设备</code>的EBS卷</li>
<li>通过snapshot新建一个可挂载的volume，并挂载到新实例的<code>根设备</code>位置</li>
<li>启动新实例</li>
</ul>
<hr>
<!--https://www.orczhou.com/index.php/2019/12/ec2-snapshot-backup-restore/-->  


]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>EBS</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows打印机漏洞修复</title>
    <url>/2021/07/10/ansible_win_spooler_fix/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527">CVE-2021-34527</a></li>
<li><a href=""></a></li>
</ul>
<hr>
<p><strong>漏洞风险描述：</strong>Windows 打印后台处理程序远程代码执行漏洞 (CVE-2021-34527)</p>
<p>当 Windows 打印后台处理程序服务不正确地执行特权文件操作时，存在远程执行代码漏洞。成功利用此漏洞的攻击者可以使用系统特权运行任意代码。攻击者可随后安装程序；查看、更改或删除数据；或者创建拥有完全用户权限的新帐户。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p>运行PowerShell：<code>Win+X</code>，选择<code>以管理员身份运行</code>命令行或 Windows Terminal；<br>确定打印后台处理程序服务是否正在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-Service -Name Spooler</span><br></pre></td></tr></table></figure>

<p>关闭并禁用打印后台处理程序服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stop-Service -Name Spooler -Force</span><br><span class="line">Set-Service -Name Spooler -StartupType Disabled</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：禁用打印后台处理程序服务会禁用本地和远程打印功能</p>
</blockquote>
<h3 id="手动关闭"><a href="#手动关闭" class="headerlink" title="手动关闭"></a>手动关闭</h3><p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/06/disable_win_print_spooler_20210712134258.png?x-oss-process=style/original_format"></p>
<h3 id="ansible-role远程关闭"><a href="#ansible-role远程关闭" class="headerlink" title="ansible role远程关闭"></a>ansible <a href="https://www.996promax.com/2019/07/12/ansible_play_example/">role</a>远程关闭</h3><blockquote>
<p>Windows端需要提前进行环境配置，文档请参考<a href="https://www.996promax.com/2019/07/22/ansible_remote_win/">ansible 远程Windows主机</a>；</p>
</blockquote>
<p>配置<strong>inventory hosts：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># windows需要的主机变量</span><br><span class="line">ansible_ssh_user: </span><br><span class="line">ansible_ssh_password: </span><br><span class="line">ansible_ssh_port: 5986</span><br><span class="line">ansible_connection: winrm</span><br><span class="line">ansible_winrm_server_cert_validation: ignore</span><br></pre></td></tr></table></figure>

<p>模块使用：<code>$ansible-doc win_command</code>，tasks的执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: Windows Print Spooler - Stop</span><br><span class="line">  win_command: powershell.exe -</span><br><span class="line">  args:</span><br><span class="line">    stdin: Stop-Service -Name Spooler -Force</span><br><span class="line"></span><br><span class="line">- name: Windows Print Spooler - Disabled</span><br><span class="line">  win_command: powershell.exe -</span><br><span class="line">  args:</span><br><span class="line">    stdin: Set-Service -Name Spooler -StartupType Disabled</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>实践总结</tag>
        <tag>baseline</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>创建一个EC2的步骤</title>
    <url>/2020/08/23/aws_ec2_create/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h3><p>AWS 使用公共密钥密码术来保护您的实例的登录信息。Linux 实例没有密码；您可以使用密钥对安全地登录您的实例。 使用 SSH 登录时，您在启动实例时指定密钥对的名称，然后提供私有密钥。<br>如果您尚未创建密钥对，则可以通过 Amazon EC2 控制台自行创建。请注意，如果您计划在多个区域中启动实例，则需要在每个区域中创建密钥对。</p>
<blockquote>
<p>将私有密钥文件保存在安全位置，<code>这是您保存私有密钥文件的唯一机会</code>。</p>
</blockquote>
<h3 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h3><p>安全组用作相关实例的防火墙，可在实例级别控制入站和出站的数据流。您必须在安全组中添加规则，以便能够使用 SSH 从您的 IP 地址连接到实例。您还可以添加允许来自任意位置的入站和出站 HTTP 和 HTTPS 访问的规则。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/sc1_20200821145027.png?x-oss-process=style/original_format"></p>
<h2 id="EC2创建步骤-more"><a href="#EC2创建步骤-more" class="headerlink" title="EC2创建步骤(more)"></a>EC2创建步骤(<a href="https://www.bookstack.cn/read/awschina/9c773d8e94048e03.md">more</a>)</h2><p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/s2_20200821145400.png?x-oss-process=style/original_format"></p>
<h2 id="Amazon-EC2-的最佳实践-more"><a href="#Amazon-EC2-的最佳实践-more" class="headerlink" title="Amazon EC2 的最佳实践(more)"></a>Amazon EC2 的最佳实践(<a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ec2-best-practices.html">more</a>)</h2>]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>EC2</tag>
      </tags>
  </entry>
  <entry>
    <title>实例类型及收费方式</title>
    <url>/2020/08/22/aws_ec2_calculator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="如何选择实例类型和购买选项"><a href="#如何选择实例类型和购买选项" class="headerlink" title="如何选择实例类型和购买选项"></a>如何选择实例类型和购买选项</h2><p><strong>实例类型</strong>：</p>
<ul>
<li>通用实例</li>
<li>计算优化型实例</li>
<li>内存优化型实例</li>
<li>存储优化型实例</li>
<li>加速计算实例</li>
</ul>
<p>更多详情请查看<a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/instance-types.html">官方文档</a></p>
<p><strong>实例购买选择</strong>：</p>
<ul>
<li>按需实例（On-Demand Instances ） 按秒为启动的实例付费。</li>
<li>预留实例 （Reserved Instances）以大幅折扣购买一年期到三年期的始终可用的实例。</li>
<li>计划实例 （Scheduled Instances）以一年为期限购买按指定重复计划始终可用的实例。</li>
<li>Spot 实例 （Spot Instances）请求未使用的 EC2 实例，这可能会显著降低您的 Amazon EC2 成本。</li>
<li>专用主机 （Dedicated Hosts）为完全专用于运行您的实例的物理主机付费，让您现有的按插槽、按内核或按 VM 计费的软件许可证降低成本。</li>
<li>专用实例 （Dedicated Instances）为在单一租户硬件上运行的实例按小时付费。</li>
<li>容量预留 （Capacity Reservations）可在特定可用区中为 EC2 实例预留容量，持续时间不限。</li>
</ul>
<p><strong>计算器</strong>：<br><a href="https://calculator.aws/#/createCalculator">https://calculator.aws/#/createCalculator</a></p>
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>EC2</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS 实例生命周期管理</title>
    <url>/2020/08/25/aws_ec2_management/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-template-permissions">EC2增删启停</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/Configure_Instance.html">EC2系统基础配置</a></li>
</ul>
<hr>
<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>创建实例常用的几种方式：</p>
<ol>
<li>从控制台向导<code>启动实例</code>：一般是用于建立一个全新的EC2</li>
<li>从<code>现有实例</code>启动类似实例：操作》映像和模板》启动更多类似实例</li>
<li>从<code>启动模板</code>启动实例：控制台向导<code>启动实例</code>》从模板启动实例</li>
</ol>
<h1 id="停止和启动"><a href="#停止和启动" class="headerlink" title="停止和启动"></a>停止和启动</h1><p>您只能停止由 Amazon <code>EBS</code> 支持的实例。当您停止运行实例时，将出现以下情况：</p>
<ul>
<li>所有 Amazon EBS 卷保持连接至实例，而且其数据将保留下来。</li>
<li>存储在主机 RAM 或主机实例存储卷中的所有数据都不复存在。</li>
<li>大多数情况下，实例在启动时会迁移到新的底层主机（尽管在某些情况下，它仍会保留在当前主机上）。</li>
<li>实例会在停止和启动时保留其私有 IPv4 地址以及任何 IPv6 地址。我们会<code>释放公有 IPv4 地址</code>并在您启动实例时为其分配新的 IPv4 地址。</li>
<li>实例会保留其关联的弹性 IP 地址。您需要<code>对所有与已停止实例关联的弹性 IP 地址付费</code>。借助 <a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ec2-classic-platform.html">EC2-Classic</a>，弹性 IP 地址会在您停止实例时取消与其的关联。</li>
<li>如果您的实例处于 Auto Scaling 组中，则 Amazon EC2 Auto Scaling 服务会将已停止的实例标记为<code>运行状况不佳</code>，可能会<code>终止它并启动替换实例</code>。参阅<a href="https://docs.aws.amazon.com/autoscaling/latest/userguide/healthcheck.html">Auto Scaling 实例的运行状况检查。</a></li>
</ul>
<p>只有在实例停止时，您才能修改以下实例属性：</p>
<ul>
<li>实例类型</li>
<li>用户数据</li>
<li>内核</li>
<li>RAM 磁盘</li>
</ul>
<h1 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h1><p>实例重启相当于操作系统重启。在许多情况下，只需要几分钟时间即可重启您的实例。当您重新启动实例时，将会保留其公有 DNS 名称 (IPv4)、私有 IPv4 地址、IPv6 地址（如果适用）以及实例存储卷上的任何数据。</p>
<p>与停止并启动您的实例不同，重启实例不会启动新的实例计费周期 (最低收取一分钟的费用)。</p>
<h1 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h1><p>当实例终止时，与该实例关联的所有实例存储卷上的数据都会被删除。</p>
<p>默认情况下，当实例终止时，Amazon EBS 根设备卷将自动删除。但是，默认情况下，即使在实例终止后，您在启动时附加的所有额外 EBS 卷或您附加到现有实例的所有 EBS 卷也会保留。这一操作是由卷的 <code>DeleteOnTermination</code> 属性控制的，您可以对其进行修改。有关更多信息，请参阅<a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination">在实例终止时保留 Amazon EBS 卷</a>。</p>
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>EC2</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义监控 EC2 内存和磁盘使用率</title>
    <url>/2020/09/02/aws_ec2_monitor-disk_memory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/mon-scripts.html">监控EC2内存和磁盘使用率</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html">设置SNS通知</a></li>
</ul>
<hr>
<p>AWS提供的CloudWatch中，没有提供内存使用率和磁盘使用率的信息，因此需要手动添加cron<br>不过，AWS提供了官方的脚本，可以直接下载安装；环境以<code>Amazon Linux 2 或 Amazon Linux AMI </code>为例</p>
<h2 id="Role权限"><a href="#Role权限" class="headerlink" title="Role权限"></a><strong>Role权限</strong></h2><p>首先确保用户权限中有操作权限，没有的话，用户界面添加：</p>
<ul>
<li>cloudwatch:PutMetricData</li>
<li>cloudwatch:GetMetricStatistics</li>
<li>cloudwatch:ListMetrics</li>
<li>ec2:DescribeTags</li>
</ul>
<h2 id="依赖包的安装"><a href="#依赖包的安装" class="headerlink" title="依赖包的安装"></a>依赖包的安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y perl-Switch perl-DateTime perl-Sys-Syslog perl-LWP-Protocol-https perl-Digest-SHA.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="安装监控脚本"><a href="#安装监控脚本" class="headerlink" title="安装监控脚本"></a>安装监控脚本</h2><p><strong>下载、安装和配置监控脚本：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://aws-cloudwatch.s3.amazonaws.com/downloads/CloudWatchMonitoringScripts-1.2.2.zip -O</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行以下命令安装监控脚本：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip CloudWatchMonitoringScripts-1.2.2.zip &amp;&amp; \</span><br><span class="line">rm CloudWatchMonitoringScripts-1.2.2.zip &amp;&amp; \</span><br><span class="line">cd aws-scripts-mon</span><br></pre></td></tr></table></figure>

<h2 id="配置IAM访问认证"><a href="#配置IAM访问认证" class="headerlink" title="配置IAM访问认证"></a>配置IAM访问认证</h2><p>您需要提供一个 IAM 角色或 awscreds.conf 文件。否则，您必须使用 –aws-access-key-id 和 –aws-secret-key 参数为这些命令提供凭证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp awscreds.template awscreds.conf</span><br></pre></td></tr></table></figure>

<p><code>sudo vim awscreds.conf</code>，配置认证信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AWSAccessKeyId = my-access-key-id</span><br><span class="line">AWSSecretKey = my-secret-access-key</span><br></pre></td></tr></table></figure>

<h2 id="收集信息发送到CloudWatch"><a href="#收集信息发送到CloudWatch" class="headerlink" title="收集信息发送到CloudWatch"></a>收集信息发送到CloudWatch</h2><p><strong>测试使用：</strong><br>以下示例执行简单的测试运行而不将数据发布到 CloudWatch。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mon-put-instance-data.pl --mem-util --verify --verbose</span><br></pre></td></tr></table></figure>

<p>以下示例收集所有可用内存指标并将其发送到 CloudWatch，将缓存和缓冲区内存计为“已用”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mon-put-instance-data.pl --mem-used-incl-cache-buff --mem-util --mem-used --mem-avail</span><br></pre></td></tr></table></figure>

<p><strong><code>crontab -e</code>，添加定时任务：</strong><br>以下示例收集指定将内存和磁盘空间使用率报告到 CloudWatch：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/5 * * * * ~/aws-scripts-mon/mon-put-instance-data.pl --mem-used-incl-cache-buff --mem-util --disk-space-util --disk-path=/ --from-cron --aws-credential-file=/root/aws-scripts-mon/awscreds.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/1113/aws-diskmonitor_20201113104839.png?x-oss-process=style/original_format"></p>
<h2 id="创建CloudWatch控制面板"><a href="#创建CloudWatch控制面板" class="headerlink" title="创建CloudWatch控制面板"></a>创建CloudWatch控制面板</h2><p>创建一个自定义监控面板<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/1113/control_20201113105603.png?x-oss-process=style/original_format"></p>
<p>搜索并添加你想要监控的指标<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/1113/comment1_20201113105910.png?x-oss-process=style/original_format"></p>
<p><code>创建小部件</code>》<code>保存控制面板</code><br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/1113/comment2_20201113110200.png?x-oss-process=style/original_format"></p>
<h2 id="添加报警"><a href="#添加报警" class="headerlink" title="添加报警"></a>添加报警</h2><ul>
<li>方式一：通过CloudWatch控制台主页的“警报”入库，添加警报</li>
<li>方式二：通过控制面板中创建的图表，进入选择对应的指标，点击“小铃铛”，添加警报<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/1113/monitor2_20201113111010.png?x-oss-process=style/original_format"></li>
</ul>
<h3 id="SNS"><a href="#SNS" class="headerlink" title="SNS"></a>SNS</h3><p>在配置报警前，创建一个用于接收和发送告警信息的SNS主题，配置方法参考<a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudWatch/latest/monitoring/US_SetupSNS.html">Amazon SNS 主题</a><br><strong>服务简介<a href="https://docs.aws.amazon.com/zh_cn/sns/latest/dg/welcome.html">(more)</a>：</strong><br>Amazon Simple Notification Service (Amazon SNS) 是一项 Web 服务，用于协调和管理向订阅终端节点或客户端交付或发送消息的过程。在 Amazon SNS 中，有两类客户端—发布者和订阅者—也称为创建者和用户。发布者通过创建消息并将消息发送至主题与订阅者进行异步交流，主题是一个逻辑访问点和通信渠道。订阅者（即 Web 服务器、电子邮件地址、Amazon SQS 队列、AWS Lambda 函数）在其订阅主题后通过受支持协议（即 Amazon SQS、HTTP/S、电子邮件、SMS、Lambda）之一使用或接收消息或通知</p>
<h3 id="配置报警"><a href="#配置报警" class="headerlink" title="配置报警"></a>配置报警</h3><p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/1113/monitor3_20201113112849.png?x-oss-process=style/original_format"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/1113/alarm1_20201113134723.png?x-oss-process=style/original_format"></p>
<hr>
<blockquote>
<p><strong>触发报警后，会通过SNS发出邮件提醒：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alarm Details:</span><br><span class="line">- Name:                       EC2-Diskspace-Alarm</span><br><span class="line">- Description:                磁盘空间不足20%告警</span><br><span class="line">- State Change:               OK -&gt; ALARM</span><br><span class="line">- Reason for State Change:    Threshold Crossed: 1 out of the last 1 datapoints [30.8640807993983 (13/11/20 06:01:00)] was greater than or equal to the threshold (18.0) (minimum 1 datapoint for OK -&gt; ALARM transition).</span><br><span class="line">- Timestamp:                  Friday 13 November, 2020 06:06:29 UTC</span><br><span class="line">- AWS Account:                845089424886</span><br><span class="line">- Alarm Arn:                  arn:aws:cloudwatch:us-east-1:845089424886:alarm:EC2-Diskspace-Alarm</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<!--https://blog.csdn.net/oblily/article/details/86767502-->  
<!--https://docs.aws.amazon.com/zh_cn/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html-->  
<!--https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/mon-scripts.html-->  
<!--https://blog.csdn.net/newtyun/article/details/105384430-->  


]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>EC2</tag>
        <tag>CloudWatch</tag>
      </tags>
  </entry>
  <entry>
    <title>EC2监控最佳实践</title>
    <url>/2020/09/01/aws_ec2_monitor_ideas/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="EC2监控最佳实践"><a href="#EC2监控最佳实践" class="headerlink" title="EC2监控最佳实践"></a>EC2监控最佳实践</h1><p>使用以下监控最佳实践，帮助您执行 Amazon EC2 监控任务。</p>
<ul>
<li>让监控成为优先事务，阻止小问题演变为大问题。</li>
<li>创建并实施从 AWS 解决方案各个部分收集监控数据的监控计划，以便更轻松地调试发生的多点故障。您的监控计划至少应该解决以下问题：<ul>
<li>您的监控目标是什么？</li>
<li>您将监控哪些资源？</li>
<li>监控这些资源的频率如何？</li>
<li>您将使用哪些监控工具？</li>
<li>谁负责执行监控任务？</li>
<li>出现错误时应通知谁？</li>
</ul>
</li>
<li>尽可能自动监控任务。</li>
<li>检查 EC2 实例的日志文件。</li>
</ul>
<hr>
<h2 id="使用-EC2-控制台创建警报"><a href="#使用-EC2-控制台创建警报" class="headerlink" title="使用 EC2 控制台创建警报"></a>使用 EC2 控制台创建警报</h2><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/using-cloudwatch-createalarm.html">为实例创建 CloudWatch 警报</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html">使用CloudWatch 警报</a></li>
</ul>
<p>您可以使用 Amazon EC2 控制台创建 CloudWatch 警报，或者使用 CloudWatch 控制台提供的更多高级选项。</p>
<p>当该指标达到指定阈值时，CloudWatch 自动向您发送通知。</p>
<p><strong>使用 CloudWatch 控制台创建警报</strong><br>有关示例，请参阅Amazon CloudWatch 用户指南中的<a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html">创建 Amazon CloudWatch 警报</a>。</p>
<p><strong>使用 Amazon EC2 控制台创建警报</strong></p>
<ul>
<li>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/%E3%80%82">https://console.aws.amazon.com/ec2/。</a></li>
<li>在导航窗格中，选择 <code>Instances</code>。</li>
<li>选择所需实例，然后依次选择<code>操作、监控、管理 CloudWatch 警报</code>。</li>
<li>在<code>管理 CloudWatch 警报</code>详细信息页面的<code>添加或编辑警报</code>下，选择<code>创建新警报</code>。</li>
<li>对于<code>警报通知</code>，选择打开或关闭开关来配置 Amazon Simple Notification Service (<strong>Amazon SNS</strong>) 通知。输入现有 Amazon SNS 主题或输入名称来创建新主题。</li>
<li>对于<code>警报操作</code>，选择打开或关闭开关来指定触发警报时要执行的操作。从下拉列表中选择一个操作。</li>
<li>对于<code>警报阈值</code>，选择警报的指标和条件。例如，您可以为<code>样本分组依据（平均）</code>和<code>要采样的数据类型（CPU 利用率）</code>保留默认设置。对于<code>警报触发条件</code>，选择 &gt;= 并输入 <code>0.80</code>。对于<code>连续周期</code>，输入 1。对于<code>时段</code>，选择 <code>5 分钟</code>。</li>
<li>（可选）对于<code>样本指标数据</code>，选择<code>添加到控制面板</code>。 </li>
<li>选择<code>创建</code>。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>EC2</tag>
        <tag>CloudWatch</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS ELB介绍</title>
    <url>/2020/09/02/aws_elb_introduction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>知识文档：</p>
</blockquote>
<ul>
<li><a href="https://amazonaws-china.com/cn/elasticloadbalancing/?nc=sn&loc=1">Elastic Load Balancing 概况</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/elasticloadbalancing/index.html">Elastic Load Balancing 文档</a></li>
</ul>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>Elastic Load Balancing 在多个目标（如 Amazon EC2 实例、容器、IP 地址和 Lambda 函数）之间自动分配传入的应用程序流量。它可以在单个可用区内处理不断变化的应用程序流量负载，也可以跨多个可用区处理此类负载。</p>
<p><strong>Elastic Load Balancing 支持三种类型的负载均衡器：</strong></p>
<ul>
<li>Application Load Balancer（7层应用程序负载均衡器）</li>
<li>Network Load Balancer （4层网络负载均衡器）</li>
<li>Classic Load Balancer（传统负载均衡器）#这个使用很少了</li>
</ul>
<p>可以根据应用程序需求选择不同类型的负载均衡器</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/elb1_20200821175944.png?x-oss-process=style/original_format"></p>
<p><strong>底层实现原理</strong><br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/8fef392c19752b1fd25c8180dca44ddf.png?x-oss-process=style/original_format"></p>
<pre><code>1、ELB由负载均衡器和目标组组成
2、⭐️A、B为两个安全组。
3、负载均衡器里面的实例地址IP也占用VPC子网的IP，并且负载均衡器里面的实例可以自动伸缩；负载均衡器内的实例对用户不可见；
4、VPC子网划分，IP使用数量，也要考虑elb的自动伸缩的场景；
5、目标组里面的实例无法做到自动伸缩，需要配合AS伸缩；
6、目标组的实例，所在的子网可以与负载均衡器的子网相同或者不通，但是必须所在的AZ是一样的。
7、ELB占用的IP你可以在EC2控制台，网络与安全、网络接口这里查询到
</code></pre>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>高可用性</p>
<ul>
<li>Elastic Load Balancing 在单个可用区或多个可用区内的多个目标（Amazon EC2 实例、容器和 IP 地址）之间自动分配流量。</li>
</ul>
<p>运行状况检查</p>
<ul>
<li>Elastic Load Balancing 可以检测无法正常运行的目标、停止向它们发送流量，然后将负载分散到剩余的正常运行的目标上。</li>
</ul>
<p>安全性功能</p>
<ul>
<li>使用 Amazon Virtual Private Cloud (Amazon VPC) 创建和管理与负载均衡器关联的安全组，以提供更多联网和安全选项。您还可以创建内部（非面向 Internet 的）负载均衡器。</li>
</ul>
<p>TLS 终止</p>
<ul>
<li>Elastic Load Balancing 提供集成化证书管理和 SSL/TLS 解密，使您可以灵活地集中管理负载均衡器的 SSL 设置，并从您的应用程序上卸载 CPU 密集型工作。</li>
</ul>
<p>第 4 层或第 7 层负载均衡</p>
<ul>
<li>您可以对 HTTP/HTTPS 应用程序执行负载均衡以实现特定于第 7 层的功能，或者对依赖于 TCP 和 UDP 协议的应用程序使用严格的第 4 层负载均衡。</li>
</ul>
<p>运行监控</p>
<ul>
<li>Elastic Load Balancing 提供与 Amazon CloudWatch 指标的集成和请求跟踪，以便实时监控应用程序的性能。</li>
</ul>
<p>产品比较</p>
<ul>
<li>您可以根据应用程序按需选择合适的负载均衡器。如果您需要灵活管理应用程序，建议您使用 Application Load Balancer。如果应用程序需要实现极致性能和静态 IP，建议您使用网络负载均衡器。如果您的现有应用程序构建于 EC2-Classic 网络内，则您应使用 Classic Load Balancer。</li>
</ul>
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>ELB</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS 侦听器配置管理</title>
    <url>/2020/09/03/aws_elb_listener/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/elasticloadbalancing/latest/application/load-balancer-listeners.html">ALB侦听器</a></li>
<li><a href="https://blog.csdn.net/zhuzixiangshui/article/details/83341343">ELB disable TLSv1.0</a></li>
</ul>
<h2 id="Application-Load-Balancer-的侦听器"><a href="#Application-Load-Balancer-的侦听器" class="headerlink" title="Application Load Balancer 的侦听器"></a>Application Load Balancer 的侦听器</h2><p>在开始使用 应用程序负载均衡器 之前，您必须添加一个或多个侦听器。侦听器是一个使用您配置的协议和端口检查连接请求的进程。您为侦听器定义的规则确定负载均衡器如何将请求路由到其已注册目标。</p>
<h2 id="更新HTTPS侦听器"><a href="#更新HTTPS侦听器" class="headerlink" title="更新HTTPS侦听器"></a>更新HTTPS侦听器</h2><p><strong>更新安全策略：</strong><a href="https://blog.csdn.net/zhuzixiangshui/article/details/83341343">ELB disable TLSv1.0</a></p>
<p>在创建 HTTPS 侦听器时，您可以选择满足您的需求的安全策略。添加新的安全策略后，您可以将 HTTPS 侦听器更新为使用此新安全策略。Application Load Balancer 不支持自定义安全策略。</p>
<p><strong>使用控制台更新安全策略：</strong></p>
<ol>
<li>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/">https://console.aws.amazon.com/ec2/</a></li>
<li>在导航窗格上的 <code>LOAD BALANCING</code> 下，选择 <code>Load Balancers</code>。</li>
<li>选择负载均衡器，然后选择 <code>Listeners</code>。</li>
<li>选中 HTTPS 侦听器对应的复选框，然后选择 <code>Edit (编辑)</code>。</li>
<li>对于 <code>Security policy (安全策略)</code>，选择安全策略。</li>
</ol>
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>ELB</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS应用程序负载均衡的使用</title>
    <url>/2020/09/03/aws_elb_use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="配置负载均衡器"><a href="#配置负载均衡器" class="headerlink" title="配置负载均衡器"></a>配置负载均衡器</h2><p>名称：就是ELB的标识名称<br>模式：如果是需要对外Internet访问就选择面向internet；如果是内网服务使用，就选择内部<br>侦听器：就是填写监听的端口，端口号，自定义</p>
<p>可用区：（这个比较重要）<br>你后端的那些机器在那个VPC、子网、可用区内，这里你就选哪个。<br>例如，我的两台web在默认VPC内的，az-1a和az-1d内，所以我在ALB选择可用区的话，就选择az-1a和az-1d<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/01a9cdfffeb10700ff42605b6ef322f2.png?x-oss-process=style/original_format"></p>
<blockquote>
<p>查看后端实例所在的可用区</p>
</blockquote>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/1cb1628791011acb24d8b04cf2ff04c0.png?x-oss-process=style/original_format"></p>
<p>ALB设置可用区<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/24b640b19d75bf16eb79ad25b9624af1.png?x-oss-process=style/original_format"></p>
<h2 id="配置安全组"><a href="#配置安全组" class="headerlink" title="配置安全组"></a>配置安全组</h2><p>此安全组跟实例的安全组不是一个。详情区分请看，<a href="https://www.imangodoc.com/32879.html">如何理解使用安全组和NACL</a><br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/a3ac1937a3a1ff7dd29e6bb3961b6726.png?x-oss-process=style/original_format"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/b1445275a04d3e31ac7c6f04de3d37cb.png?x-oss-process=style/original_format"></p>
<h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>目标组：就是后端使用机器的群组，新建或者选择现有的<br>名称：标记性名称<br>协议：就是ALB到后端服务器之前的协议。<br>端口：这个是后端服务的端口。如果是访问NLB的80端口转到后端机器8080的端口。这里就要填8080了。80—》8080<br>目录类型：这里要选择instance（实例类型）</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/064996bfd450622045a74b0219315acd.png?x-oss-process=style/original_format"></p>
<h2 id="注册目标"><a href="#注册目标" class="headerlink" title="注册目标"></a>注册目标</h2><p>这里选择的要注意：</p>
<ul>
<li>1、在下方选择相应的实例，记住你这里的机器所处的可用区必须要和前面选的可用区是一样的，要不无法使用</li>
<li>2、选择好实例后，记住！一定要点击添加到已注册！！如果直接点击下一步，这个后端实例就没有添加到目标群组里面</li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/0fdbde6ed4403309eebcc4172f2ac990.png?x-oss-process=style/original_format"></p>
<h2 id="审核"><a href="#审核" class="headerlink" title="审核"></a>审核</h2><p>检查之前设置的是否有问题：<br>这里要注意的是子网。如果前面可用区，和后端的实例不是在一个可用区的话，这里会显示一个叹号！！<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/7554debec96b16a5df3cd7836f61eefd.png?x-oss-process=style/original_format"></p>
<h2 id="创建过程中的状态"><a href="#创建过程中的状态" class="headerlink" title="创建过程中的状态"></a>创建过程中的状态</h2><p>两处都是初始化过程中<br><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/61a27ec7ad094358377fab8c508d7f7e.png?x-oss-process=style/original_format"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/3664985107a626a3ee7cc3528f5e39b5.png?x-oss-process=style/original_format"></p>
<h2 id="创建成功的状态"><a href="#创建成功的状态" class="headerlink" title="创建成功的状态"></a>创建成功的状态</h2><p>在状态为 active和healthy时，再去访问连接。如果状态不是这样的话，就要排查是否有其他问题</p>
<h2 id="如何访问创建好的ALB"><a href="#如何访问创建好的ALB" class="headerlink" title="如何访问创建好的ALB"></a>如何访问创建好的ALB</h2><p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/154a2751e03adfdac11e61b9f42f179d.png?x-oss-process=style/original_format"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/824/axy01a9cdfffeb10700ff42%202f2.png?x-oss-process=style/original_format"></p>
<hr>
<h2 id="删除LB-more"><a href="#删除LB-more" class="headerlink" title="删除LB(more)"></a>删除LB<a href="https://docs.aws.amazon.com/zh_cn/elasticloadbalancing/latest/application/load-balancer-delete.html">(more)</a></h2><p><strong>操作要点：</strong></p>
<ol>
<li>关闭删除保护</li>
<li>删除目标组</li>
<li>如果您有一个指向LB的域的一个别名记录，请将它指向新的位置并等待 DNS 更改生效，在删除LB</li>
</ol>
<!--http://www.cloudbin.cn/?p=1697-->  
<!--http://www.cloudbin.cn/?p=2253-->  
<!--  https://docs.aws.amazon.com/zh_cn/elasticloadbalancing/latest/application/application-load-balancers.html-->  

]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>ELB</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS用户的角色和权限的划分建议</title>
    <url>/2020/04/09/aws_iam_suggest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><ul>
<li>测试环境</li>
<li>预发布环境</li>
<li>生产环境</li>
</ul>
<h2 id="用户角色和职责"><a href="#用户角色和职责" class="headerlink" title="用户角色和职责"></a>用户角色和职责</h2><ul>
<li><p>AWS账号所有者<br>管理账号，开通IAM用户</p>
</li>
<li><p>AWS账号管理人员<br>日常运维管理工作者、账单管理（除根用户外最大的权限的用户）</p>
</li>
<li><p>只读用户<br>只能查看AWS console控制台</p>
</li>
<li><p>开发用户</p>
</li>
<li><p>部署用户<br>环境设计和部署管理</p>
</li>
</ul>
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
  </entry>
  <entry>
    <title>Lambda + Cloud Watch定时维护EC2</title>
    <url>/2020/09/01/aws_lambda_cloudwatch_operate_ec2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/golang-package.html">Lambda</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudWatch/latest/events/ScheduledEvents.html">Cloudwatch</a></li>
</ul>
<hr>
<p>有时候在EC2上的一些业务只需要在每天的某个时间段对外提供服务，其余的时候是处于闲置空转的状态。但付费方式为EC2的按需收费，那么闲置时间产生的费用就显得浪费了。怎么办呢？通过Lambda服务结合Cloudwatch规则，实现实例的定时开关，达到节约成本的目的。</p>
<p><strong>业务需求</strong>：</p>
<ul>
<li>每天上午（UTC）9:00~20:00，将实例启动使其处于running状态</li>
<li>每天晚上（UTC）20:00~次日上午9:00，将实例停止使其处于stopped状态。</li>
</ul>
<hr>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>需要用到的AWS服务包括：</strong></p>
<ol>
<li><strong>EC2</strong>：即云端虚拟机，将用于运行我们的脚本。</li>
<li><strong>Lambda</strong>, 用于操作我们的EC2实例，即启动和关闭。</li>
<li><strong>IAM</strong>, AWS Identity and Access Management, 用于赋予Lambda函数操作我们EC2实例的权限。</li>
<li><strong>Cloud Watch</strong>, 用于定时执行我们的Lambda函数，达到定时开关机的效果。</li>
</ol>
<hr>
<h2 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h2><p>实例的创建步骤这里就不介绍了，可以参考<a href="https://docs.aws.amazon.com/index.html">AWS 官方文档</a>。</p>
<p>测试资源如下：</p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">实例ID</th>
</tr>
</thead>
<tbody><tr>
<td align="center">XLDSMILE-US-Pordoction-app1</td>
<td align="center">i-0611856bef37b1295</td>
</tr>
<tr>
<td align="center">XLDSMILE-US-Pordoction-app2</td>
<td align="center">i-01c2654a6acc2f933</td>
</tr>
</tbody></table>
<h2 id="创建Lambda的IAM角色"><a href="#创建Lambda的IAM角色" class="headerlink" title="创建Lambda的IAM角色"></a>创建Lambda的IAM角色</h2><p>因为在创建Lambda函数时会要求选择IAM，因此这里要先把IAM角色给配置喽。</p>
<h3 id="创建策略"><a href="#创建策略" class="headerlink" title="创建策略"></a>创建策略</h3><ul>
<li><strong>登录<code>控制台</code>，选择<code>IAM</code>服务》<code>角色</code>》<code>创建角色</code></strong></li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/add-lambda-role_20201105175614.png?x-oss-process=style/original_format"></p>
<ul>
<li>选择 <strong><code>创建策略</code></strong> ，为角色附加自定义权限策略：</li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/lambda_20201106104548.png?x-oss-process=style/original_format"></p>
<blockquote>
<p>将如下JSON字符串复制到选项框内</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">    &quot;Statement&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: [</span><br><span class="line">                &quot;logs:CreateLogGroup&quot;,</span><br><span class="line">                &quot;logs:CreateLogStream&quot;,</span><br><span class="line">                &quot;logs:PutLogEvents&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Resource&quot;: &quot;arn:aws:logs:*:*:*&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: [</span><br><span class="line">                &quot;ec2:Start*&quot;,</span><br><span class="line">                &quot;ec2:Stop*&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Resource&quot;: &quot;*&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>点击 <strong><code>查看策略</code></strong> ，为其创建<code>名字</code>和<code>描述</code>，点击<code>创建策略</code>，跳转到以下界面。</li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/lambda_polic1_20201106115100.png?x-oss-process=style/original_format"></p>
<h3 id="为角色分配策略"><a href="#为角色分配策略" class="headerlink" title="为角色分配策略"></a>为角色分配策略</h3><ul>
<li>策略创建完成后返回 <strong><code>创建角色</code></strong> 界面，筛选并勾选策略</li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/lambda_20201106165248.png?x-oss-process=style/original_format"></p>
<ul>
<li>点击下一步，标签啥的选默认，点击 <strong><code>审核</code></strong> 》 <strong><code>创建角色</code></strong> ：</li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/lamdba_20201106165915.png?x-oss-process=style/original_format"></p>
<h2 id="创建Lambda函数"><a href="#创建Lambda函数" class="headerlink" title="创建Lambda函数"></a>创建Lambda函数</h2><p><strong>步骤或选型：</strong></p>
<ul>
<li>选择Lambda服务</li>
<li>点击 <strong><code>函数</code></strong> 》 <strong><code>创建函数</code></strong></li>
<li>选择“从头开始撰写”</li>
<li>函数名称：StopEC2Instances</li>
<li>语言：Pyhton3.8</li>
<li>执行角色：现有角色》搜索我们刚才建立的角色</li>
<li>点击 <strong><code>创建函数</code></strong></li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/lambda50_20201106175051.png?x-oss-process=style/original_format"></p>
<p>将以下Python3代码复制粘贴。region替换为你的EC2 region, instancces 替换为你的instance id。这些都可以在EC2控制台找到。完成后点击 <strong><code>Deploy</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># stopped your instances</span><br><span class="line">import boto3</span><br><span class="line">region = &#x27;us-east-1&#x27;</span><br><span class="line">instances = [&#x27;i-0571c93e69719637c&#x27;, &#x27;i-057659afa167f65a5&#x27;]</span><br><span class="line">ec2 = boto3.client(&#x27;ec2&#x27;, region_name=region)</span><br><span class="line">    </span><br><span class="line">def lambda_handler(event, context):</span><br><span class="line">    ec2.stop_instances(InstanceIds=instances)</span><br><span class="line">    print(&#x27;stopped your instances: &#x27; + str(instances))</span><br></pre></td></tr></table></figure>


<p>这样，<code>关闭实例的Lambda函数</code>就创建好了，我们还需要创建一个类似的<code>启动实例的函数</code>。</p>
<p>重复从 建立函数 开始的以上所有步骤，有以下几点改变：</p>
<ul>
<li>函数名称: StartEC2Instances</li>
<li>Python代码里的 ec2.stop_instances 替换为 ec2.start_instances</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># started your instances</span><br><span class="line">import boto3</span><br><span class="line">region = &#x27;us-east-1&#x27;</span><br><span class="line">instances = [&#x27;i-0571c93e69719637c&#x27;, &#x27;i-057659afa167f65a5&#x27;]</span><br><span class="line">ec2 = boto3.client(&#x27;ec2&#x27;, region_name=region)</span><br><span class="line">    </span><br><span class="line">def lambda_handler(event, context):</span><br><span class="line">    ec2.start_instances(InstanceIds=instances)</span><br><span class="line">    print(&#x27;started your instances: &#x27; + str(instances))</span><br></pre></td></tr></table></figure>

<ul>
<li>完成后，在Lambda控制台，就能看到我们刚才建立的两个函数</li>
</ul>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/lambda_20201106180107.png?x-oss-process=style/original_format"></p>
<hr>
<h2 id="使用CloudWatch服务，创建规则"><a href="#使用CloudWatch服务，创建规则" class="headerlink" title="使用CloudWatch服务，创建规则"></a>使用CloudWatch服务，创建规则</h2><ol>
<li>CloudWatch控制台，选择<code>规则</code>》<code>创建规则</code>，事件源选择<code>计划</code>》<code>cron表达式</code> ，输入 “0 9 * * ? *”</li>
<li>任务计划格式参考：<a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron 表达式</a><ul>
<li>cron 使用的时间是UTC时间，具体UTC时间可查询此网站：<a href="https://time.is/UTC">https://time.is/UTC</a></li>
</ul>
</li>
<li>目标选择<code>Lambda函数</code>，选择<code>函数</code></li>
<li>点击<code>配置规则详细信息</code>，名称和描述均写<code>StartEC2</code></li>
<li>重复步骤1操作，这时cron表达式为“0 20 * * ? *”</li>
<li>重复上文3，4两步骤，函数版本选择“V2”。文件名和描述均写“StopEC2”</li>
<li>测试，若机器到时间未停止，首先检查cron表达式和UTC时间表述。其次检查Lambda代码中的instance ID，region是否正确。</li>
</ol>
<hr>
<!--https://segmentfault.com/a/1190000023101856-->  
<!--https://blog.csdn.net/kepa520/article/details/79297085-->  
<!--https://blog.csdn.net/captsinpata/article/details/93501163?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param-->  

]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>CloudWatch</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS账号注册和控制台介绍</title>
    <url>/2020/04/09/aws_present/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><a href="https://docs.aws.amazon.com/">AWS官方文档</a></p>
</blockquote>
<hr>
<h2 id="AWS账号注册"><a href="#AWS账号注册" class="headerlink" title="AWS账号注册"></a>AWS账号注册</h2><p>首先，注册一个Global账号：</p>
<ul>
<li><a href="https://aws.amazon.com/">https://aws.amazon.com</a></li>
<li><a href="https://amazonaws-china.com/">https://amazonaws-china.com</a></li>
</ul>
<p>注册帐号美国版和中国版一致, 创建EC2时注意选择的国家区域；不要用 <a href="https://www.amazonaws.cn注册/">https://www.amazonaws.cn注册</a><br>免费套餐介绍：<a href="https://amazonaws-china.com/cn/free/faqs/">https://amazonaws-china.com/cn/free/faqs/</a></p>
<h2 id="AWS控制台"><a href="#AWS控制台" class="headerlink" title="AWS控制台"></a>AWS控制台</h2><p><strong>申请IAM用户</strong><br>登录到aws控制台，打开IAM控制台，开启MFA安全认证，保证根用户的安全；<br>申请一个IAM用户并授权此用户最大权限（AWS架构师第一准则，<code>不要使用根用户登录控制台操作</code>）；<br>用申请的IAM用户进行所有的操作，根用户在没有必要的情况不要使用，并由专人负责；</p>
<p><strong>熟悉AWS控制台</strong></p>
<p>把控制台上面的服务选项都点一遍，看看各个服务在哪里；方便后期使用的话知道点击哪里；<br><code>控制台的左下角可以切换语言</code>，如果英语不好的可以换成中文显示；</p>
<p><strong>熟悉AWS账单管理</strong></p>
<p>切换到账单控制台，查看账单<br>登录账单控制台，看看账单首选项、付款方式、整合账单、税务设置、订单发票、服务抵扣金额、成本管理等等<br>这个要认真搞下，因为账号区分全球的和中国区账号。</p>
<ol>
<li>汇款方式（信用卡（外币卡&amp;银联卡）、电汇、）</li>
<li>发票问题（中国区可以提供发票、全球区没有发票只有收据）</li>
<li>缴费时间点（账单生成时间、最迟缴费时间）</li>
</ol>
<p><strong>熟悉AWS服务限制</strong></p>
<p>通过控制台查看服务的限制，或者通过此链接：</p>
<p><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ec2-resource-limits.html">Amazon EC2 服务限制</a><br><a href="https://docs.aws.amazon.com/zh_cn/general/latest/gr/aws_service_limits.html">AWS 服务配额</a></p>
<p>服务限制，会更好的控制对于AWS资源的合理利用，防止有心人有意或无意的无节制的开启资源。<br>还有就是一些其他不知道的原因，某项服务在某个region不能使用，这些都要知道；防止你们公司业务要上线了。发现那个地区没有想使用的服务；因为你测试的时候使用的region跟上线所在的那个region不一样，而且你也没有提前确认；等等原因。</p>
<p><strong>熟悉AWS的support中心</strong><br>技术支持，服务限制申请提高；<br>技术支持分为三种，开发人员、商业、企业。<br>具体收费模式请看链接：<a href="https://aws.amazon.com/cn/premiumsupport/plans/">https://aws.amazon.com/cn/premiumsupport/plans/</a><br>还有一种技术支持，就是安排专门的架构师服务于你们公司的，But你公司必须在AWS消费很多大洋才可以伺候你</p>
<h2 id="AWS学习-阶段划分"><a href="#AWS学习-阶段划分" class="headerlink" title="AWS学习 阶段划分"></a>AWS学习 阶段划分</h2><p><strong>基础玩法</strong></p>
<p>EC2、ELB、S3、ElastiCache（redis）、RDS（MySql）<br>建议你们先熟悉上面几个服务，使用默认选项（默认VPC、安全组）等创建简单的三层服务并测试。<br>因为几乎迁移到AWS，使用的服务属上面几项最多，当然也是最常用的服务；先熟悉熟悉基本情况，打好基础。</p>
<p><strong>中级玩法</strong></p>
<p>首先，<code>全面深入学习VPC一定要学明白VPC</code>，因为AWS大多数服务，多AZ、高可用，都是基于VPC网络区分开的。<br>还有个问题就是，强迫症选手做事情是不会选择默认的选项去做事的。<br>通过自定义VPC，进行网络划分；各个服务做使用的网络不同（公有子网、私有子网），后期扩展。<br>这样做的好处就是，你可以清楚的了解到你们整个架构的划分、业务划分、网络划分、安全防护、后期如何进行架构扩展，都能清楚的了解到；<br>通过自定义的VPC网络进行服务创建，先把基础那几项服务玩一遍；再去测试其他的服务。</p>
<p><strong>高级玩法</strong></p>
<p>DevOps<br>ECS、EKS<br>Serverless</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/aws/aws-55ed8db05deb6a0c99575b200bd4d317.jpeg?x-oss-process=style/watermark"></p>
<hr>
<!--  https://www.bookstack.cn/read/awschina/c0f7d53e63c37006.md  -->  
<!--  https://www.jianshu.com/p/89004a16789f  -->  
]]></content>
      <categories>
        <category>AWS</category>
      </categories>
  </entry>
  <entry>
    <title>AWS S3 Bucket 简介</title>
    <url>/2020/09/05/aws_s3_introduction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://aws.amazon.com/cn/s3/">产品介绍</a></li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/gsg/GetStartedWithS3.html">DOSC</a></li>
</ul>
<hr>
<h2 id="对象存储-Amazon-S3"><a href="#对象存储-Amazon-S3" class="headerlink" title="对象存储 Amazon S3"></a>对象存储 <a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/Welcome.html">Amazon S3</a></h2><p>Amazon Simple Storage Service (Amazon S3) 是一种<code>对象存储</code>服务，提供行业领先的可扩展性、数据可用性、安全性和性能。Amazon S3 可达到 99.999999999%（11 个 9）的持久性，并为全球各地的公司存储数百万个应用程序的数据。</p>
<h2 id="使用-Amazon-S3-的优势"><a href="#使用-Amazon-S3-的优势" class="headerlink" title="使用 Amazon S3 的优势"></a>使用 Amazon S3 的优势</h2><p>Amazon S3 特意内置了着重于简易性和稳健性的最小功能集。以下是使用 Amazon S3 的一些优势：</p>
<ul>
<li>创建存储桶 – 创建和命名存储数据的存储桶。存储桶是 Amazon S3 中用于数据存储的基础容器。</li>
<li>存储数据 – 在存储桶中存储无限量的数据。可将所需数量的对象上传到 Amazon S3 存储桶。每个对象可包含最多 5 TB 的数据。使用开发人员分配的唯一键值存储和检索每个对象。</li>
<li>下载数据 – 下载您的数据或允许其他人进行下载。随时下载您的数据或允许其他人进行下载。</li>
<li>权限 – 对于要在您的 Amazon S3 存储桶中上传或下载数据的其他人员，您可以授予其访问权限或拒绝其访问。将上传和下载的许可授予三种类型的用户。身份验证机制可帮助确保数据安全，以防未授权访问。</li>
<li>标准接口 – 使用基于标准的 REST 和 SOAP 接口，它们可与任何 Internet 开发工具包搭配使用。<ul>
<li>注意：HTTP 上的 SOAP 支持已弃用，但是仍可在 HTTPS 上使用。不支持将新 Amazon S3 功能用于 SOAP。我们建议您使用 REST API 或 AWS 开发工具包。</li>
</ul>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>存储桶：存储桶是 Amazon S3 中用于存储对象的容器。每个对象都储存在一个存储桶中。</li>
<li>对象：对象是 Amazon S3 中存储的基本实体。对象由对象数据和元数据组成。数据部分对 Amazon S3 不透明。元数据是一组描述对象的名称-值对。其中包括一些默认元数据（如上次修改日期）和标准 HTTP 元数据（如 Content-Type）。您还可以在存储对象时指定自定义元数据。在存储桶中，对象将由键 (名称) 和版本 ID 进行唯一地标识。</li>
<li>键：键是指存储桶中对象的唯一标识符。存储桶内的每个对象都只能有一个键。存储桶、键和版本 ID 的组合唯一标识各个对象。</li>
<li>区域：您可以选择一个 AWS 区域供 Amazon S3 存储您创建的存储桶。您可以选择一个区域，以便优化延迟、尽可能降低成本或满足法规要求。在某一区域存储的数据元将一直留在该区域，除非您特意将其传输到另一区域。</li>
<li>Amazon S3 数据一致性模型：最终一致性</li>
</ul>
<h2 id="S3-收费模式"><a href="#S3-收费模式" class="headerlink" title="S3 收费模式"></a>S3 收费模式</h2><p>参考 <a href="https://aws.amazon.com/cn/s3/pricing/">Amazon S3 定价</a>，Amazon S3 成本组成：</p>
<ul>
<li>存储</li>
<li>请求和数据检索(API 调用)</li>
<li>数据传输</li>
<li>管理和分析</li>
<li>复制</li>
<li>S3 Object Lambda</li>
</ul>
<h2 id="Amazon-S3-存储类比较"><a href="#Amazon-S3-存储类比较" class="headerlink" title="Amazon S3 存储类比较"></a>Amazon S3 存储类比较</h2><p>存储类别只有在上传对象，或者通过生命周期管理时涉及到。<br><strong>Topics：</strong></p>
<ul>
<li>经常访问对象的存储类</li>
<li>用于自动优化访问模式不断变化或未知的数据的存储类</li>
<li>不经常访问对象的存储类</li>
<li>用于存档对象的存储类</li>
<li>Amazon S3 on Outposts 的存储类</li>
<li>比较 Amazon S3 存储类</li>
<li>设置对象的存储类</li>
</ul>
<h2 id="操作入门"><a href="#操作入门" class="headerlink" title="操作入门"></a>操作入门</h2><p>参考文档<a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/gsg/GetStartedWithS3.html"> AWS S3 DOSC</a></p>
<hr>
<!--https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/Welcome.html-->  

]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>S3</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之数组</title>
    <url>/2020/04/09/go_base_array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组：是同一种数据类型的固定长度的序列。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个长度为3元素类型为int的数组a</span><br><span class="line">var a [3]int</span><br></pre></td></tr></table></figure>

<h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><p><code>var 数组变量名 [元素数量]Type</code><br>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。<code>[5]int和[10]int</code>是不同的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a [3]int</span><br><span class="line">var b [4]int</span><br><span class="line">a = b //不可以这样做，因为此时a和b是不同的类型</span><br></pre></td></tr></table></figure>
<p>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p><strong><em>一维数组</em></strong></p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var testArray [3]int                        //数组会初始化为int类型的零值</span><br><span class="line">    var numArray = [3]int&#123;1, 2&#125;                 //使用指定的初始值完成初始化</span><br><span class="line">    var cityArray = [3]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; //使用指定的初始值完成初始化</span><br><span class="line">    fmt.Println(testArray)                      //[0 0 0]</span><br><span class="line">    fmt.Println(numArray)                       //[1 2 0]</span><br><span class="line">    fmt.Println(cityArray)                      //[北京 上海 深圳]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var testArray [3]int</span><br><span class="line">    var numArray = [...]int&#123;1, 2&#125;</span><br><span class="line">    var cityArray = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line">    fmt.Println(testArray)                          //[0 0 0]</span><br><span class="line">    fmt.Println(numArray)                           //[1 2]</span><br><span class="line">    fmt.Printf(&quot;type of numArray:%T\n&quot;, numArray)   //type of numArray:[2]int</span><br><span class="line">    fmt.Println(cityArray)                          //[北京 上海 深圳]</span><br><span class="line">    fmt.Printf(&quot;type of cityArray:%T\n&quot;, cityArray) //type of cityArray:[3]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := [...]int&#123;1: 1, 3: 5&#125;</span><br><span class="line">    fmt.Println(a)                  // [0 1 0 5]</span><br><span class="line">    fmt.Printf(&quot;type of a:%T\n&quot;, a) //type of a:[4]int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p><strong><em>一维数组</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 遍历数组a有以下两种方法：</span><br><span class="line">func main() &#123;</span><br><span class="line">    var a = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line">    // 方法1：for循环遍历</span><br><span class="line">    for i := 0; i &lt; len(a); i++ &#123;</span><br><span class="line">        fmt.Println(a[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法2：for range遍历</span><br><span class="line">    for index, value := range a &#123;</span><br><span class="line">        fmt.Println(index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := [3][2]string&#123;</span><br><span class="line">        &#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">        &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">        &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]</span><br><span class="line">    fmt.Println(a[2][1]) //支持索引取值:重庆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := [3][2]string&#123;</span><br><span class="line">        &#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">        &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">        &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    for _, v1 := range a &#123;</span><br><span class="line">        for _, v2 := range v1 &#123;</span><br><span class="line">            fmt.Printf(&quot;%s\t&quot;, v2)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">北京    上海    </span><br><span class="line">广州    深圳    </span><br><span class="line">成都    重庆    </span><br></pre></td></tr></table></figure>
<p><code>注意</code>： 多维数组<code>只有第一层</code>可以使用<code>...</code>来让编译器推导数组长度。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//支持的写法</span><br><span class="line">a := [...][2]string&#123;</span><br><span class="line">    &#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">    &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">    &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">//不支持多维数组的内层使用...</span><br><span class="line">b := [3][...]string&#123;</span><br><span class="line">    &#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">    &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">    &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组拷贝和传参"><a href="#数组拷贝和传参" class="headerlink" title="数组拷贝和传参"></a>数组拷贝和传参</h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func modifyArray(x [3]int) &#123;</span><br><span class="line">    x[0] = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func modifyArray2(x [3][2]int) &#123;</span><br><span class="line">    x[2][0] = 100</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    a := [3]int&#123;10, 20, 30&#125;</span><br><span class="line">    modifyArray(a) //在modify中修改的是a的副本x</span><br><span class="line">    fmt.Println(a) //[10 20 30]</span><br><span class="line">    b := [3][2]int&#123;</span><br><span class="line">        &#123;1, 1&#125;,</span><br><span class="line">        &#123;1, 1&#125;,</span><br><span class="line">        &#123;1, 1&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    modifyArray2(b) //在modify中修改的是b的副本x</span><br><span class="line">    fmt.Println(b)  //[[1 1] [1 1] [1 1]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li>
<li>[n]*T表示指针数组，*[n]T表示数组指针 。</li>
</ol>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>求数组[1, 3, 5, 7, 8]所有元素的和<br>找出数组中和为指定值的两个元素的下标，比如从数组[1, 3, 5, 7, 8]中找出和为8的两个元素的下标分别为(0,3)和(1,2)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>s3cmd—AWS S3存储桶管理工具</title>
    <url>/2020/09/05/aws_s3cmd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>s3cmd 是用于创建S3桶，上传，检索和管理数据到对象存储命令行实用程序。 本文将指导linux下安装s3cmd程序，以及对象存储服务桶和对象数据管理，包括创建桶、上传、检索、删除及本地与对象存储服务间数据同步等。本文以下内容将以CentOS 7.3的弹性云服务器为例，windows操作系统使用类似。</p>
<h2 id="1-安装s3cmd"><a href="#1-安装s3cmd" class="headerlink" title="1. 安装s3cmd"></a>1. 安装s3cmd</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum -y install s3cmd</span><br></pre></td></tr></table></figure>


<h2 id="2-配置s3cmd"><a href="#2-配置s3cmd" class="headerlink" title="2. 配置s3cmd"></a>2. 配置s3cmd</h2><p><strong>执行 <code>$ s3cmd --configure</code>生成配置文件，一路<code>Enter</code>，注意跳过认证并保存配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">...</span><br><span class="line">Test access with supplied credentials? [Y/n] n</span><br><span class="line"></span><br><span class="line">Save settings? [y/N] y</span><br><span class="line">Configuration saved to &#x27;/root/.s3cfg&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>修改一下几项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim /root/.s3cfg</span><br><span class="line">access_key = xxx</span><br><span class="line">secret_key = xxx</span><br><span class="line">host_base = ip:port</span><br><span class="line">host_bucket = ip/kucketname</span><br><span class="line">use_https = False</span><br></pre></td></tr></table></figure>

<p>其中，access_key和secret_key是在本地创建S3用户时获得，host_base是S3服务所使用的ip地址（包括端口 号）,host_bucket为S3用户下的一个bucket(可在配置之后再创建，但该字段不能为空)</p>
<h2 id="3-使用s3cmd"><a href="#3-使用s3cmd" class="headerlink" title="3. 使用s3cmd"></a>3. 使用s3cmd</h2><p>通过s3cmd –help查看具体使用方法；</p>
<ul>
<li>列举所有 Buckets<br><code>$ s3cmd ls</code></li>
<li>创建 bucket，且 bucket 名称是唯一的，不能重复。<br><code>s3cmd mb s3://my-bucket-name</code></li>
<li>删除空 bucket<br><code>s3cmd rb s3://my-bucket-name</code></li>
<li>列举 Bucket 中的内容<br><code>s3cmd ls s3://my-bucket-name</code></li>
<li>上传 file.txt 到某个 bucket，<br><code>s3cmd put file.txt s3://my-bucket-name/file.txt</code></li>
<li>上传并将权限设置为所有人可读<br><code>s3cmd put --acl-public file.txt s3://my-bucket-name/file.txt</code></li>
<li>批量上传文件<br><code>s3cmd put ./* s3://my-bucket-name/</code></li>
<li>下载文件<br><code>s3cmd get s3://my-bucket-name/file.txt file.txt</code></li>
<li>批量下载<br><code>s3cmd get s3://my-bucket-name/* ./</code></li>
<li>删除文件<br><code>s3cmd del s3://my-bucket-name/file.txt</code></li>
<li>来获得对应的bucket所占用的空间大小<br><code>s3cmd du -H s3://my-bucket-name</code></li>
<li>设置S3 bucket的Public权限<br><code>s3cmd setacl s3://myexamplebucket.calvium.com/ --acl-public --recursive</code></li>
</ul>
<hr>
<!--  https://blog.csdn.net/baidu_26495369/article/details/81535209  -->
<!--  https://blog.51cto.com/weimouren/2166601  -->
<!--  https://bbs.huaweicloud.com/blogs/378ac7ff96c611e7b8317ca23e93a891  -->
<!--  https://www.cnblogs.com/xd502djj/p/3604783.htmlhttps://www.cnblogs.com/xd502djj/p/3604783.html  -->
<!--https://www.cnblogs.com/hiyang/p/12631922.html-->


]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>S3</tag>
      </tags>
  </entry>
  <entry>
    <title>烧烤撒料配比</title>
    <url>/2020/05/12/eat_1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><strong>烧烤撒料配比：</strong></p>
<ul>
<li>桃酥50克</li>
<li>腰果30克</li>
<li>熟黄豆50克</li>
<li>油炸花生米80克</li>
<li>熟芝麻80克</li>
<li>干辣椒40克</li>
<li>小茴香50克</li>
</ul>
<p>放入料理机打碎抓匀，再放入：</p>
<ul>
<li>孜然粉80克</li>
<li>味精40克</li>
<li>胡椒粉30</li>
<li>十三香10克</li>
<li>麻辣鲜50克</li>
</ul>
]]></content>
      <categories>
        <category>吃喝玩乐</category>
      </categories>
      <tags>
        <tag>吃喝玩乐</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之函数</title>
    <url>/2020/05/07/go_base_func/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。Go语言中支持函数、匿名函数和闭包</p>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>使用<code>func</code>关键字定义函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func 函数名(参数)(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>函数名：由<code>字母、数字、下划线</code>组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li>
<li>参数：参数由<code>参数变量和参数变量的类型</code>组成，多个参数之间使用<code>,</code>分隔。</li>
<li>返回值：返回值由<code>返回值变量和其变量类型</code>组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li>
<li>函数体：实现指定功能的<code>代码块</code>。</li>
</ul>
<blockquote>
<p>示例：定义一个求两个数之和的函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func intSum(x int, y int) int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>函数的参数和返回值都是可选的</code>，例如我们可以定义一个既没有参数也没有返回值的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func sayHIHI() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello Mr.GaO&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>我们可以通过<code>函数名()</code>的方式调用函数。例如调用上面定义的求和函数，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    sayHIHI()</span><br><span class="line">    countint := intSum(6, 60)</span><br><span class="line">    fmt.Println(countint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：调用有返回值的函数时，可以不接收其返回值。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>函数的参数中，如果<code>相邻变量的类型相同，则可以省略类型</code>，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func intSum(x, y int) int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表示，intSum函数的两个参数的类型均为 int。因为y后面有类型说明，x参数也是该类型，所以可以省略x的类型。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的<code>参数数量不固定</code>，通过在<code>参数名后加...</code>来标识。<br><strong>注意</strong>：可变参数通常要作为<code>函数的最后一个参数</code>。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func intSum2(x ...int) int &#123;</span><br><span class="line">    fmt.Println(x) //x是一个切片</span><br><span class="line">    sum := 0</span><br><span class="line">    for _, v := range x &#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ret1 := intSum2()</span><br><span class="line">    ret2 := intSum2(10)</span><br><span class="line">    ret3 := intSum2(10, 20)</span><br><span class="line">    ret4 := intSum2(10, 20, 30)</span><br><span class="line">    fmt.Println(ret1, ret2, ret3, ret4)</span><br><span class="line">&#125;</span><br><span class="line">// 输出：</span><br><span class="line">[]</span><br><span class="line">[10]</span><br><span class="line">[10 20]</span><br><span class="line">[10 20 30]</span><br><span class="line">0 10 30 60</span><br></pre></td></tr></table></figure>

<p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func intSum3(x int, y ...int) int &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">    sum := x</span><br><span class="line">    for _, v := range y &#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上述函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret5 := intSum3(100)</span><br><span class="line">ret6 := intSum3(100, 10)</span><br><span class="line">ret7 := intSum3(100, 10, 20)</span><br><span class="line">ret8 := intSum3(100, 10, 20, 30)</span><br><span class="line">fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160</span><br></pre></td></tr></table></figure>
<p>本质上，函数的可变参数是通过切片来实现的。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func calc(x, y int) (int, int) &#123;</span><br><span class="line">    sum := x + y</span><br><span class="line">    sub := x - y</span><br><span class="line">    return sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h3><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func calc(x, y int) (sum, sub int) &#123;</span><br><span class="line">    sum = x + y</span><br><span class="line">    sub = x - y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值补充"><a href="#返回值补充" class="headerlink" title="返回值补充"></a>返回值补充</h3><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func someFunc(x string) []int &#123;</span><br><span class="line">    if x == &quot;&quot; &#123;</span><br><span class="line">        return nil // 没必要返回[]int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之map</title>
    <url>/2020/04/30/go_base_map/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><a href="http://wen.topgoer.com/docs/golang/chapter03-13">map</a> 是Go语言中提供的<code>映射关系容器</code>，其内部使用散列表（hash）实现。</p>
</blockquote>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<h2 id="map的定义语法"><a href="#map的定义语法" class="headerlink" title="map的定义语法"></a>map的定义语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map[KeyType]ValueType</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make(map[KeyType]ValueType, cap)</span><br></pre></td></tr></table></figure>
<p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>
<h2 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h2><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    scoreMap := make(map[string]int, 8)</span><br><span class="line">    scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">    scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">    fmt.Println(scoreMap)                  // map[小明:100 张三:90]</span><br><span class="line">    fmt.Println(scoreMap[&quot;小明&quot;])          // 100</span><br><span class="line">    fmt.Printf(&quot;type of a:%T\n&quot;, scoreMap) //type of a:map[string]int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    scoreMap := make(map[string]string, 8)</span><br><span class="line">    scoreMap[&quot;射手&quot;] = &quot;小鲁蛋&quot;</span><br><span class="line">    scoreMap[&quot;打野&quot;] = &quot;赵云&quot;</span><br><span class="line">    scoreMap[&quot;辅助&quot;] = &quot;廉颇&quot;</span><br><span class="line">    fmt.Println(scoreMap)</span><br><span class="line">    fmt.Printf(&quot;type of scoreMap is: %T\n&quot;, scoreMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// map[坦边:吕布 射手:小鲁蛋 打野:赵云 辅助:廉颇]</span><br><span class="line">// type of scoreMap is: map[string]string</span><br></pre></td></tr></table></figure>

<p>map也支持在声明的时候填充元素，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    userLogin := map[string]string&#123;</span><br><span class="line">        &quot;username&quot;: &quot;xyxxb&quot;,</span><br><span class="line">        &quot;password&quot;: &quot;123123&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(userLogin) // map[password:123123 username:xyxxb]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中判断map中键是否存在的特殊写法，格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value, ok := map[key]</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    scoreMap := make(map[string]int)</span><br><span class="line">    scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">    scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">    // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span><br><span class="line">    v, ok := scoreMap[&quot;张三&quot;]</span><br><span class="line">    if ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;查无此人&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>使用for range遍历map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    scoreMap := make(map[string]int)</span><br><span class="line">    scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">    scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">    scoreMap[&quot;娜扎&quot;] = 60</span><br><span class="line">    for k, v := range scoreMap &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅遍历key的时候，可以按下面的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    scoreMap := make(map[string]int)</span><br><span class="line">    scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">    scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">    scoreMap[&quot;娜扎&quot;] = 60</span><br><span class="line">    for k := range scoreMap &#123;</span><br><span class="line">        scoreMap[&quot;小明&quot;] = 120</span><br><span class="line">        fmt.Println(k) // 取value：fmt.Println(scoreMap[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**<code>注意</code>**： 遍历map时的元素顺序与添加键值对的顺序无关。</p>
<h2 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h2><p>使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(map, key)</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    scoreMap := make(map[string]int)</span><br><span class="line">    scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">    scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">    scoreMap[&quot;娜扎&quot;] = 60</span><br><span class="line">    delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除</span><br><span class="line">    for k,v := range scoreMap&#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano()) //初始化随机数种子</span><br><span class="line"></span><br><span class="line">    var scoreMap = make(map[string]int, 200)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">        key := fmt.Sprintf(&quot;stu%02d&quot;, i) // 生成stu开头的字符串</span><br><span class="line">        value := rand.Intn(100)          // 生成0~99的随机整数</span><br><span class="line">        scoreMap[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    // 取出map中的所有key存入切片keys</span><br><span class="line">    var keys = make([]string, 0, 200)</span><br><span class="line">    for key := range scoreMap &#123;</span><br><span class="line">        keys = append(keys, key)</span><br><span class="line">    &#125;</span><br><span class="line">    // 对切片进行排序</span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    // 按照排序后的key遍历map</span><br><span class="line">    for _, key := range keys &#123;</span><br><span class="line">        fmt.Println(key, scoreMap[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var mapSlice = make([]map[string]string, 3)</span><br><span class="line">    for index, value := range mapSlice &#123;</span><br><span class="line">        fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;after init&quot;)</span><br><span class="line">    // 对切片中的map元素进行初始化</span><br><span class="line">    mapSlice[0] = make(map[string]string, 10)</span><br><span class="line">    mapSlice[0][&quot;name&quot;] = &quot;小王子&quot;</span><br><span class="line">    mapSlice[0][&quot;password&quot;] = &quot;123456&quot;</span><br><span class="line">    mapSlice[0][&quot;address&quot;] = &quot;沙河&quot;</span><br><span class="line">    for index, value := range mapSlice &#123;</span><br><span class="line">        fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index:0 value:map[]</span><br><span class="line">index:1 value:map[]</span><br><span class="line">index:2 value:map[]</span><br><span class="line">after init</span><br><span class="line">index:0 value:map[address:沙河 name:小王子 password:123456]</span><br><span class="line">index:1 value:map[]</span><br><span class="line">index:2 value:map[]</span><br></pre></td></tr></table></figure>

<h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><p>下面的代码演示了map中值为切片类型的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var sliceMap = make(map[string][]string, 3)</span><br><span class="line">    fmt.Println(sliceMap)</span><br><span class="line">    fmt.Println(&quot;after init&quot;)</span><br><span class="line">    key := &quot;中国&quot;</span><br><span class="line">    value, ok := sliceMap[key]</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        value = make([]string, 0, 2)</span><br><span class="line">    &#125;</span><br><span class="line">    value = append(value, &quot;北京&quot;, &quot;上海&quot;)</span><br><span class="line">    sliceMap[key] = value</span><br><span class="line">    fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map[]</span><br><span class="line">after init</span><br><span class="line">map[中国:[北京 上海]]</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。<br>观察下面代码，写出最终的打印结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    type Map map[string][]int</span><br><span class="line">    m := make(Map)</span><br><span class="line">    s := []int&#123;1, 2&#125;</span><br><span class="line">    s = append(s, 3)</span><br><span class="line">    fmt.Printf(&quot;%+v\n&quot;, s)</span><br><span class="line">    m[&quot;q1mi&quot;] = s</span><br><span class="line">    s = append(s[:1], s[2:]...)</span><br><span class="line">    fmt.Printf(&quot;%+v\n&quot;, s)</span><br><span class="line">    fmt.Printf(&quot;%+v\n&quot;, m[&quot;q1mi&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!---->  
<!---->  
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之函数进阶</title>
    <url>/2020/05/10/go_base_func2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 定义全局变量num</span><br><span class="line">var num int64 = 10</span><br><span class="line"></span><br><span class="line">func testGlobalVar() &#123;</span><br><span class="line">    fmt.Printf(&quot;num=%d\n&quot;, num) // 函数中可以访问全局变量num</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    testGlobalVar() // num=10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p><code>函数内定义的变量无法在该函数外使用</code>，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func testLocalVar() &#123;</span><br><span class="line">    // 定义一个函数局部变量x,仅在该函数内生效</span><br><span class="line">    var x int64 = 100</span><br><span class="line">    fmt.Printf(&quot;x=%d\n&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    testLocalVar()</span><br><span class="line">    fmt.Println(x) // 此时无法使用变量x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果局部变量和全局变量重名，<code>优先访问局部变量</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 定义全局变量num</span><br><span class="line">var num int64 = 10</span><br><span class="line"></span><br><span class="line">func testNum() &#123;</span><br><span class="line">    num := 100</span><br><span class="line">    fmt.Printf(&quot;num=%d\n&quot;, num) // 函数中优先使用局部变量</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    testNum() // num=100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句块定义的变量：通常会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func testLocalVar2(x, y int) &#123;</span><br><span class="line">    fmt.Println(x, y) // 函数的参数也是只在本函数中生效</span><br><span class="line">    if x &gt; 0 &#123;</span><br><span class="line">        z := 100 // 变量z只在if语句块生效</span><br><span class="line">        fmt.Println(z)</span><br><span class="line">    &#125;</span><br><span class="line">    // fmt.Println(z) // 此处无法使用变量z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testLocalVar3() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Println(i) // 变量i只在当前for语句块中生效</span><br><span class="line">    &#125;</span><br><span class="line">    // fmt.Println(i) // 此处无法使用变量i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数的类型与变量"><a href="#函数的类型与变量" class="headerlink" title="函数的类型与变量"></a>函数的类型与变量</h2><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>使用<code>type关键字</code>来定义一个函数类型，具体格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type calculation func(int, int) int</span><br></pre></td></tr></table></figure>
<p>上面语句定义了一个<code>calculation</code>类型的函数，这种函数可以接收两个int类型的参数并且返回一个int类型的返回值。</p>
<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func add(x, y int) int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sub(x, y int) int &#123;</span><br><span class="line">    return x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add和sub都能赋值给calculation类型的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure>

<h3 id="函数类型的变量"><a href="#函数类型的变量" class="headerlink" title="函数类型的变量"></a>函数类型的变量</h3><p>声明函数类型的变量并为变量赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var c calculation               // 声明一个calculation类型的变量c</span><br><span class="line">    c = add                         // 把add赋值给c</span><br><span class="line">    fmt.Printf(&quot;type of c:%T\n&quot;, c) // type of c:main.calculation</span><br><span class="line">    fmt.Println(c(1, 2))            // 像调用add一样调用c</span><br><span class="line"></span><br><span class="line">    f := add                        // 将函数add赋值给变量f</span><br><span class="line">    fmt.Printf(&quot;type of f:%T\n&quot;, f) // type of f:func(int, int) int</span><br><span class="line">    fmt.Println(f(10, 20))          // 像调用add一样调用f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数分为 <strong><code>函数作为参数</code></strong> 和 <strong><code>函数作为返回值</code></strong> 两部分</p>
<h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func add(x, y int) int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">func calc(x, y int, op func(int, int) int) int &#123;</span><br><span class="line">    return op(x, y)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    ret2 := calc(10, 20, add)</span><br><span class="line">    fmt.Println(ret2) //30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func do(s string) (func(int, int) int, error) &#123;</span><br><span class="line">    switch s &#123;</span><br><span class="line">    case &quot;+&quot;:</span><br><span class="line">        return add, nil</span><br><span class="line">    case &quot;-&quot;:</span><br><span class="line">        return sub, nil</span><br><span class="line">    default:</span><br><span class="line">        err := errors.New(&quot;无法识别的操作符&quot;)</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func(参数)(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 将匿名函数保存到变量</span><br><span class="line">    add := func(x, y int) &#123;</span><br><span class="line">        fmt.Println(x + y)</span><br><span class="line">    &#125;</span><br><span class="line">    add(10, 20) // 通过变量调用匿名函数</span><br><span class="line"></span><br><span class="line">    //自执行函数：匿名函数定义完加()直接执行</span><br><span class="line">    func(x, y int) &#123;</span><br><span class="line">        fmt.Println(x + y)</span><br><span class="line">    &#125;(10, 20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数多用于实现回调函数和<a href="https://www.runoob.com/go/go-function-closures.html">闭包</a>。</p>
<h3 id="闭包-more"><a href="#闭包-more" class="headerlink" title="闭包(more)"></a>闭包(<a href="http://www.topgoer.cn/docs/golang/chapter05-5">more</a>)</h3><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。<br>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>首先我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func adder() func(int) int &#123;</span><br><span class="line">    var x int</span><br><span class="line">    return func(y int) int &#123;</span><br><span class="line">        x += y</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var f = adder()</span><br><span class="line">    fmt.Println(f(10)) //10</span><br><span class="line">    fmt.Println(f(20)) //30</span><br><span class="line">    fmt.Println(f(30)) //60</span><br><span class="line"></span><br><span class="line">    f1 := adder()</span><br><span class="line">    fmt.Println(f1(40)) //40</span><br><span class="line">    fmt.Println(f1(50)) //90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func adder2(x int) func(int) int &#123;</span><br><span class="line">    return func(y int) int &#123;</span><br><span class="line">        x += y</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var f = adder2(10)</span><br><span class="line">    fmt.Println(f(10)) //20</span><br><span class="line">    fmt.Println(f(20)) //40</span><br><span class="line">    fmt.Println(f(30)) //70</span><br><span class="line"></span><br><span class="line">    f1 := adder2(20)</span><br><span class="line">    fmt.Println(f1(40)) //60</span><br><span class="line">    fmt.Println(f1(50)) //110</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包进阶示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func makeSuffixFunc(suffix string) func(string) string &#123;</span><br><span class="line">    return func(name string) string &#123;</span><br><span class="line">        if !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line">            return name + suffix</span><br><span class="line">        &#125;</span><br><span class="line">        return name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    jpgFunc := makeSuffixFunc(&quot;.jpg&quot;)</span><br><span class="line">    txtFunc := makeSuffixFunc(&quot;.txt&quot;)</span><br><span class="line">    fmt.Println(jpgFunc(&quot;test&quot;)) //test.jpg</span><br><span class="line">    fmt.Println(txtFunc(&quot;test&quot;)) //test.txt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包进阶示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func calc(base int) (func(int) int, func(int) int) &#123;</span><br><span class="line">    add := func(i int) int &#123;</span><br><span class="line">        base += i</span><br><span class="line">        return base</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sub := func(i int) int &#123;</span><br><span class="line">        base -= i</span><br><span class="line">        return base</span><br><span class="line">    &#125;</span><br><span class="line">    return add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    f1, f2 := calc(10)</span><br><span class="line">    fmt.Println(f1(1), f2(2)) //11 9</span><br><span class="line">    fmt.Println(f1(3), f2(4)) //12 8</span><br><span class="line">    fmt.Println(f1(5), f2(6)) //13 7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p>
<h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;start&quot;)</span><br><span class="line">    defer fmt.Println(1)</span><br><span class="line">    defer fmt.Println(2)</span><br><span class="line">    defer fmt.Println(3)</span><br><span class="line">    fmt.Println(&quot;end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>
<h3 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h3><p>在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：</p>
<p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/05/defer.png?x-oss-process=style/original_format"></p>
<h3 id="defer经典案例"><a href="#defer经典案例" class="headerlink" title="defer经典案例"></a>defer经典案例</h3><p>阅读下面的代码，写出最后的打印结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func f1() int &#123;</span><br><span class="line">    x := 5</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;()</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f2() (x int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;()</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f3() (y int) &#123;</span><br><span class="line">    x := 5</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;()</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line">func f4() (x int) &#123;</span><br><span class="line">    defer func(x int) &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;(x)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(f1())</span><br><span class="line">    fmt.Println(f2())</span><br><span class="line">    fmt.Println(f3())</span><br><span class="line">    fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="defer面试题"><a href="#defer面试题" class="headerlink" title="defer面试题"></a>defer面试题</h3><p>问：以下代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">    ret := a + b</span><br><span class="line">    fmt.Println(index, a, b, ret)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    x := 1</span><br><span class="line">    y := 2</span><br><span class="line">    defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span><br><span class="line">    x = 10</span><br><span class="line">    defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">    y = 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h1><table>
<thead>
<tr>
<th align="left">内置函数</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">close</td>
<td align="left">主要用来关闭channel</td>
</tr>
<tr>
<td align="left">len</td>
<td align="left">用来求长度，比如string、array、slice、map、channel</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>
<tr>
<td align="left">make</td>
<td align="left">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>
<tr>
<td align="left">append</td>
<td align="left">用来追加元素到数组、slice中</td>
</tr>
<tr>
<td align="left">panic和recover</td>
<td align="left">用来做错误处理</td>
</tr>
</tbody></table>
<h2 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h2><p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func funcA() &#123;</span><br><span class="line">    fmt.Println(&quot;func A&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcB() &#123;</span><br><span class="line">    panic(&quot;panic in B&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcC() &#123;</span><br><span class="line">    fmt.Println(&quot;func C&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    funcA()</span><br><span class="line">    funcB()</span><br><span class="line">    funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func A</span><br><span class="line">panic: panic in B</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.funcB(...)</span><br><span class="line">        .../code/func/main.go:12</span><br><span class="line">main.main()</span><br><span class="line">        .../code/func/main.go:20 +0x98</span><br></pre></td></tr></table></figure>

<p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func funcA() &#123;</span><br><span class="line">    fmt.Println(&quot;func A&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcB() &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        //如果程序出出现了panic错误,可以通过recover恢复过来</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;recover in B&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;panic in B&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcC() &#123;</span><br><span class="line">    fmt.Println(&quot;func C&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    funcA()</span><br><span class="line">    funcB()</span><br><span class="line">    funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>recover()必须搭配defer使用。</li>
<li>defer一定要在可能引发panic的语句之前定义。</li>
</ol>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p><strong>Q：分金币</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span><br><span class="line">分配规则如下：</span><br><span class="line">a. 名字中每包含1个&#x27;e&#x27;或&#x27;E&#x27;分1枚金币</span><br><span class="line">b. 名字中每包含1个&#x27;i&#x27;或&#x27;I&#x27;分2枚金币</span><br><span class="line">c. 名字中每包含1个&#x27;o&#x27;或&#x27;O&#x27;分3枚金币</span><br><span class="line">d: 名字中每包含1个&#x27;u&#x27;或&#x27;U&#x27;分4枚金币</span><br><span class="line">写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span><br><span class="line">程序结构如下，请实现 ‘dispatchCoin’ 函数</span><br><span class="line">*/</span><br><span class="line">var (</span><br><span class="line">    coins = 50</span><br><span class="line">    users = []string&#123;</span><br><span class="line">        &quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    distribution = make(map[string]int, len(users))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    left := dispatchCoin()</span><br><span class="line">    fmt.Println(&quot;剩下：&quot;, left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之运算符</title>
    <url>/2020/04/08/go_base_operator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>运算符用于在程序运行时执行数学或逻辑运算。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">相加</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">相减</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">相乘</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">相除</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">求余</td>
</tr>
</tbody></table>
<p>注意： <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody></table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">参与运算的两数各对应的二进位相与。（两位均为1才为1）</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">参与运算的两数各对应的二进位相或。（两位有一个为1就为1）</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移n位就是乘以2的n次方。“a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移n位就是除以2的n次方。“a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody></table>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td align="left">+=</td>
<td align="left">相加后再赋值</td>
</tr>
<tr>
<td align="left">-=</td>
<td align="left">相减后再赋值</td>
</tr>
<tr>
<td align="left">*=</td>
<td align="left">相乘后再赋值</td>
</tr>
<tr>
<td align="left">/=</td>
<td align="left">相除后再赋值</td>
</tr>
<tr>
<td align="left">%=</td>
<td align="left">求余后再赋值</td>
</tr>
<tr>
<td align="left">&lt;&lt;=</td>
<td align="left">左移后赋值</td>
</tr>
<tr>
<td align="left">&gt;&gt;=</td>
<td align="left">右移后赋值</td>
</tr>
<tr>
<td align="left">&amp;=</td>
<td align="left">按位与后赋值</td>
</tr>
<tr>
<td align="left">|=</td>
<td align="left">按位或后赋值</td>
</tr>
<tr>
<td align="left">^=</td>
<td align="left">按位异或后赋值</td>
</tr>
</tbody></table>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ul>
<li>有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</span><br><span class="line">    // 相同，为 0</span><br><span class="line">    nums := [...]int&#123;1, 2, 3, 3, 2, 1, 9, 8, 8&#125;</span><br><span class="line"></span><br><span class="line">    n := nums[0]</span><br><span class="line">    for i := 1; i &lt; len(nums); i++ &#123;</span><br><span class="line">        n ^= nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之流程控制</title>
    <url>/2020/04/09/go_base_process_control/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>
<p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 表达式1 &#123;</span><br><span class="line">    分支1</span><br><span class="line">&#125; else if 表达式2 &#123;</span><br><span class="line">    分支2</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    分支3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言规定与<code>if</code>匹配的左括号<code>&#123;</code>必须与<code>if和表达式</code>放在同一行，<code>&#123;</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>&#123;</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p>
<blockquote>
<p>例子：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输出：C</span><br><span class="line">func ifDemo1() &#123;</span><br><span class="line">    score := 65</span><br><span class="line">    if score &gt;= 90 &#123;</span><br><span class="line">        fmt.Println(&quot;A&quot;)</span><br><span class="line">    &#125; else if score &gt; 75 &#123;</span><br><span class="line">        fmt.Println(&quot;B&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;C&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>与上个例子的区别，<code>score</code>变量只在if分支内生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func ifDemo2() &#123;</span><br><span class="line">    if score := 65; score &gt;= 90 &#123;</span><br><span class="line">        fmt.Println(&quot;A&quot;)</span><br><span class="line">    &#125; else if score &gt; 75 &#123;</span><br><span class="line">        fmt.Println(&quot;B&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;C&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go 语言中的所有循环类型均可以使用<code>for关键字</code>来完成。</p>
<p>for循环的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func forDemo() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func forDemo2() &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    for ; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环的初始语句和结束语句都可以省略，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func forDemo3() &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    for i &lt; 10 &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环可以通过<code>break、goto、return、panic</code>语句强制退出循环。</p>
<h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break(跳出循环)"></a>break(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p>
<p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func breakDemo1() &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; 10; j++ &#123;</span><br><span class="line">            if j == 3 &#123;</span><br><span class="line">                break BREAKDEMO1</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-0</span><br><span class="line">0-1</span><br><span class="line">0-2</span><br></pre></td></tr></table></figure>

<h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h2><p><code>continue</code> 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p>
<p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func continueDemo() &#123;</span><br><span class="line">forloop1:</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        // forloop2:</span><br><span class="line">        for j := 0; j &lt; 5; j++ &#123;</span><br><span class="line">            if i == 2 &amp;&amp; j == 2 &#123;</span><br><span class="line">                continue forloop1</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-0</span><br><span class="line">0-1</span><br><span class="line">0-2</span><br><span class="line">0-3</span><br><span class="line">0-4</span><br><span class="line">1-0</span><br><span class="line">1-1</span><br><span class="line">1-2</span><br><span class="line">1-3</span><br><span class="line">1-4</span><br><span class="line">2-0</span><br><span class="line">2-1</span><br><span class="line">3-0</span><br><span class="line">3-1</span><br><span class="line">3-2</span><br><span class="line">3-3</span><br><span class="line">3-4</span><br><span class="line">4-0</span><br><span class="line">4-1</span><br><span class="line">4-2</span><br><span class="line">4-3</span><br><span class="line">4-4</span><br></pre></td></tr></table></figure>

<h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><blockquote>
<p><a href="http://wen.topgoer.com/docs/golang/chapter04-3">select 语句</a>：select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p>
</blockquote>
<p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输出：中指</span><br><span class="line">func switchDemo1() &#123;</span><br><span class="line">    finger := 3</span><br><span class="line">    switch finger &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        fmt.Println(&quot;大拇指&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        fmt.Println(&quot;食指&quot;)</span><br><span class="line">    case 3:</span><br><span class="line">        fmt.Println(&quot;中指&quot;)</span><br><span class="line">    case 4:</span><br><span class="line">        fmt.Println(&quot;无名指&quot;)</span><br><span class="line">    case 5:</span><br><span class="line">        fmt.Println(&quot;小拇指&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;无效的输入！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p>
<p>一个分支可以有多个值，多个<code>case</code>值中间使用英文逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输出：奇数</span><br><span class="line">func testSwitch3() &#123;</span><br><span class="line">    switch n := 7; n &#123;</span><br><span class="line">    case 1, 3, 5, 7, 9:</span><br><span class="line">        fmt.Println(&quot;奇数&quot;)</span><br><span class="line">    case 2, 4, 6, 8:</span><br><span class="line">        fmt.Println(&quot;偶数&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分支还可以使用表达式，这时候<code>switch</code>语句后面不需要再跟判断变量。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func switchDemo4() &#123;</span><br><span class="line">    age := 30</span><br><span class="line">    switch &#123;</span><br><span class="line">    case age &lt; 25:</span><br><span class="line">        fmt.Println(&quot;好好学习吧&quot;)</span><br><span class="line">    case age &gt; 25 &amp;&amp; age &lt; 35:</span><br><span class="line">        fmt.Println(&quot;好好工作吧&quot;)</span><br><span class="line">    case age &gt; 60:</span><br><span class="line">        fmt.Println(&quot;好好享受吧&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;活着真好&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fallthrough</code>语法可以执行满足条件的<code>case</code>的下一个<code>case</code>，是为了兼容C语言中的<code>case</code>设计的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func switchDemo5() &#123;</span><br><span class="line">    s := &quot;a&quot;</span><br><span class="line">    switch &#123;</span><br><span class="line">    case s == &quot;a&quot;:</span><br><span class="line">        fmt.Println(&quot;a&quot;)</span><br><span class="line">        fallthrough</span><br><span class="line">    case s == &quot;b&quot;:</span><br><span class="line">        fmt.Println(&quot;b&quot;)</span><br><span class="line">    case s == &quot;c&quot;:</span><br><span class="line">        fmt.Println(&quot;c&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func gotoDemo1() &#123;</span><br><span class="line">    var breakFlag bool</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; 10; j++ &#123;</span><br><span class="line">            if j == 2 &#123;</span><br><span class="line">                // 设置退出标签</span><br><span class="line">                breakFlag = true</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">        // 外层for循环判断</span><br><span class="line">        if breakFlag &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-0</span><br><span class="line">0-1</span><br></pre></td></tr></table></figure>

<p>使用goto语句能简化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func gotoDemo2() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; 10; j++ &#123;</span><br><span class="line">            if j == 2 &#123;</span><br><span class="line">                // 设置退出标签</span><br><span class="line">                goto breakTag</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">    // 标签</span><br><span class="line">breakTag:</span><br><span class="line">    fmt.Println(&quot;结束for循环&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><blockquote>
<ol>
<li>编写代码打印9*9乘法表</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>流程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之切片</title>
    <url>/2020/04/29/go_base_slice/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="http://wen.topgoer.com/docs/golang/chapter03-10">切片Slice</a></li>
</ul>
<hr>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。切片一般用于快速地操作一块数据集合。</p>
<pre><code>1. 切片：切片是数组的一个引用，因此切片是引用类型，它的内部结构包含地址、长度和容量。
2. 切片的长度可以改变，因此，切片是一个可变的数组。
3. 切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 
4. cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。
5. 切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。
6. 如果 slice == nil，那么 len、cap 结果都等于 0。
</code></pre>
<h2 id="切片定义"><a href="#切片定义" class="headerlink" title="切片定义"></a>切片定义</h2><p>声明切片类型的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name []T</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>name:表示变量名</li>
<li>T:表示切片中的元素类型</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 声明切片类型</span><br><span class="line">    var a []string              //声明一个字符串切片</span><br><span class="line">    var b = []int&#123;&#125;             //声明一个整型切片并初始化</span><br><span class="line">    var c = []bool&#123;false, true&#125; //声明一个布尔切片并初始化</span><br><span class="line">    var d = []bool&#123;false, true&#125; //声明一个布尔切片并初始化</span><br><span class="line">    fmt.Println(a)              //[]</span><br><span class="line">    fmt.Println(b)              //[]</span><br><span class="line">    fmt.Println(c)              //[false true]</span><br><span class="line">    fmt.Println(a == nil)       //true</span><br><span class="line">    fmt.Println(b == nil)       //false</span><br><span class="line">    fmt.Println(c == nil)       //false</span><br><span class="line">    // fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p>
<h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定<code>low</code>和<code>high</code>两个索引界限值的简单的形式，另一种是除了<code>low</code>和<code>high</code>索引界限值外还指定容量的完整的形式。</p>
<p><strong><code>简单切片表达式</code></strong><br>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含）</p>
<ul>
<li>切片的长度是它所包含的元素个数。</li>
<li>切片的容量是从它的第一个元素到其底层数组元素末尾的个数。</li>
<li>切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    s := a[1:3]  // s := a[low:high]</span><br><span class="line">    fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:[2 3] len(s):2 cap(s):4</span><br></pre></td></tr></table></figure>
<p>为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[2:]  // 等同于 a[2:len(a)]</span><br><span class="line">a[:3]  // 等同于 a[0:3]</span><br><span class="line">a[:]   // 等同于 a[0:len(a)]</span><br></pre></td></tr></table></figure>

<p><code>注意</code>：<br>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p>
<p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<code>常量索引</code>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    s := a[1:3]  // s := a[low:high]</span><br><span class="line">    fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))</span><br><span class="line">    s2 := s[3:4]  // 索引的上限是cap(s)而不是len(s)</span><br><span class="line">    fmt.Printf(&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;, s2, len(s2), cap(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:[2 3] len(s):2 cap(s):4</span><br><span class="line">s2:[5] len(s2):1 cap(s2):1</span><br></pre></td></tr></table></figure>

<p><strong><code>完整切片表达式</code></strong><br>对于数组，指向数组的指针，或切片a(<code>注意不能是字符串</code>)支持完整切片表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure>
<p>上面的代码会构造与简单切片表达式·<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    t := a[1:3:5]</span><br><span class="line">    fmt.Printf(&quot;t:%v len(t):%v cap(t):%v\n&quot;, t, len(t), cap(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t:[2 3] len(t):2 cap(t):4</span><br></pre></td></tr></table></figure>
<p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p>
<h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make([]T, size, cap)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := make([]int, 2, 10)</span><br><span class="line">    fmt.Println(a)      //[0 0]</span><br><span class="line">    fmt.Println(len(a)) //2</span><br><span class="line">    fmt.Println(cap(a)) //10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p>
<h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。<br>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<br><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/04/slice_01.png?x-oss-process=style/original_format"></p>
<p>切片<code>s2 := a[3:6]</code>，相应示意图如下：<br><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/04/slice_02.png?x-oss-process=style/original_format"></p>
<h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>
<h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil</span><br><span class="line">s2 := []int&#123;&#125;        //len(s2)=0;cap(s2)=0;s2!=nil</span><br><span class="line">s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil</span><br></pre></td></tr></table></figure>
<p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>
<h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    s1 := make([]int, 3) //[0 0 0]</span><br><span class="line">    s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组</span><br><span class="line">    s2[0] = 100</span><br><span class="line">    fmt.Println(s1) //[100 0 0]</span><br><span class="line">    fmt.Println(s2) //[100 0 0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    s := []int&#123;1, 3, 5&#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; len(s); i++ &#123;</span><br><span class="line">        fmt.Println(i, s[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for index, value := range s &#123;</span><br><span class="line">        fmt.Println(index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    var s []int</span><br><span class="line">    s = append(s, 1)        // [1]</span><br><span class="line">    s = append(s, 2, 3, 4)  // [1 2 3 4]</span><br><span class="line">    s2 := []int&#123;5, 6, 7&#125;  </span><br><span class="line">    s = append(s, s2...)    // [1 2 3 4 5 6 7]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>注意</code>**：通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var s []int</span><br><span class="line">s = append(s, 1, 2, 3)</span><br></pre></td></tr></table></figure>

<p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s := []int&#123;&#125;  // 没有必要初始化</span><br><span class="line">s = append(s, 1, 2, 3)</span><br><span class="line"></span><br><span class="line">var s = make([]int)  // 没有必要初始化</span><br><span class="line">s = append(s, 1, 2, 3)</span><br></pre></td></tr></table></figure>

<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。<br>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    //append()添加元素和切片扩容</span><br><span class="line">    var numSlice []int</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        numSlice = append(numSlice, i)</span><br><span class="line">        fmt.Printf(&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;, numSlice, len(numSlice), cap(numSlice), numSlice)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0]  len:1  cap:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  cap:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  cap:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看出：</p>
<ul>
<li>append()函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ul>
<p>append()函数还支持一次性追加多个元素。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var citySlice []string</span><br><span class="line">// 追加一个元素</span><br><span class="line">citySlice = append(citySlice, &quot;北京&quot;)</span><br><span class="line">// 追加多个元素</span><br><span class="line">citySlice = append(citySlice, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)</span><br><span class="line">// 追加切片</span><br><span class="line">a := []string&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;</span><br><span class="line">citySlice = append(citySlice, a...)</span><br><span class="line">fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]</span><br></pre></td></tr></table></figure>

<h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newcap := old.cap</span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line">if cap &gt; doublecap &#123;</span><br><span class="line">    newcap = cap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if old.len &lt; 1024 &#123;</span><br><span class="line">        newcap = doublecap</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Check 0 &lt; newcap to detect overflow</span><br><span class="line">        // and prevent an infinite loop.</span><br><span class="line">        for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">            newcap += newcap / 4</span><br><span class="line">        &#125;</span><br><span class="line">        // Set newcap to the requested cap when</span><br><span class="line">        // the newcap calculation overflowed.</span><br><span class="line">        if newcap &lt;= 0 &#123;</span><br><span class="line">            newcap = cap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出以下内容：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>
<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。</p>
<h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    b := a</span><br><span class="line">    fmt.Println(a) //[1 2 3 4 5]</span><br><span class="line">    fmt.Println(b) //[1 2 3 4 5]</span><br><span class="line">    b[0] = 1000</span><br><span class="line">    fmt.Println(a) //[1000 2 3 4 5]</span><br><span class="line">    fmt.Println(b) //[1000 2 3 4 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p>
<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // copy()复制切片</span><br><span class="line">    a := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    c := make([]int, 5, 5)</span><br><span class="line">    copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c</span><br><span class="line">    fmt.Println(a) //[1 2 3 4 5]</span><br><span class="line">    fmt.Println(c) //[1 2 3 4 5]</span><br><span class="line">    c[0] = 1000</span><br><span class="line">    fmt.Println(a) //[1 2 3 4 5]</span><br><span class="line">    fmt.Println(c) //[1000 2 3 4 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 从切片中删除元素</span><br><span class="line">    a := []int&#123;30, 31, 32, 33, 34, 35, 36, 37&#125;</span><br><span class="line">    // 要删除索引为2的元素</span><br><span class="line">    a = append(a[:2], a[3:]...)</span><br><span class="line">    fmt.Println(a) //[30 31 33 34 35 36 37]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol>
<li>请写出下面代码的输出结果。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var a = make([]string, 5, 10)</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        a = append(a, fmt.Sprintf(&quot;%v&quot;, i))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
解答：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>请使用内置的sort包对数组var a = […]int{3, 7, 8, 9, 1}进行排序（附加题，自行查资料解答）。<br>解答：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!---->  
<!---->  
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 格式化符号%说明</title>
    <url>/2020/04/08/go_format_description/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。</p>
<p><strong>定义示例类型和变量</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Human struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people = Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="普通占位符"><a href="#普通占位符" class="headerlink" title="普通占位符"></a>普通占位符</h2><table>
<thead>
<tr>
<th align="left">占位符</th>
<th align="left">说明</th>
<th align="left">举例</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%v</td>
<td align="left">使用默认格式输出值，或者如果方法存在，则使用类性值的String()方法输出自定义值</td>
<td align="left">Printf(“%v”, people)</td>
<td align="left">{zhangsan}，</td>
</tr>
<tr>
<td align="left">%+v</td>
<td align="left">打印结构体时，会添加字段名</td>
<td align="left">Printf(“%+v”, people)</td>
<td align="left">{Name:zhangsan}</td>
</tr>
<tr>
<td align="left">%#v</td>
<td align="left">输出Go语言语法格式的值</td>
<td align="left">Printf(“%#v”, people)</td>
<td align="left">main.Human{Name:”zhangsan”}</td>
</tr>
<tr>
<td align="left">%T</td>
<td align="left">输出值的类型</td>
<td align="left">Printf(“%T”, people)</td>
<td align="left">main.Human</td>
</tr>
<tr>
<td align="left">%%</td>
<td align="left">字面上的百分号，并非值的占位符</td>
<td align="left">Printf(“%%”)</td>
<td align="left">%</td>
</tr>
</tbody></table>
<h2 id="布尔占位符"><a href="#布尔占位符" class="headerlink" title="布尔占位符"></a>布尔占位符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符       说明                举例                     输出</span><br><span class="line">%t          true 或 false。     Printf(&quot;%t&quot;, true)       true</span><br></pre></td></tr></table></figure>

<h2 id="整数占位符"><a href="#整数占位符" class="headerlink" title="整数占位符"></a>整数占位符</h2><table>
<thead>
<tr>
<th align="left">占位符</th>
<th align="left">说明</th>
<th align="left">举例</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%b</td>
<td align="left">二进制表示</td>
<td align="left">Printf(“%b”, 5)</td>
<td align="left">101</td>
</tr>
<tr>
<td align="left">%c</td>
<td align="left">相应Unicode码点所表示的字符</td>
<td align="left">Printf(“%c”, 0x4E2D)</td>
<td align="left">中</td>
</tr>
<tr>
<td align="left">%d</td>
<td align="left">十进制表示</td>
<td align="left">Printf(“%d”, 0x12)</td>
<td align="left">18</td>
</tr>
<tr>
<td align="left">%o</td>
<td align="left">八进制表示</td>
<td align="left">Printf(“%d”, 10)</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">%q</td>
<td align="left">单引号围绕的字符字面值，由Go语法安全地转义</td>
<td align="left">Printf(“%q”, 0x4E2D)</td>
<td align="left">‘中’</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">十六进制表示，字母形式为小写 a-f</td>
<td align="left">Printf(“%x”, 13)</td>
<td align="left">d</td>
</tr>
<tr>
<td align="left">%X</td>
<td align="left">十六进制表示，字母形式为大写 A-F</td>
<td align="left">Printf(“%x”, 13)</td>
<td align="left">D</td>
</tr>
<tr>
<td align="left">%U</td>
<td align="left">Unicode格式：U+1234，等同于 “U+%04X”</td>
<td align="left">Printf(“%U”, 0x4E2D)</td>
<td align="left">U+4E2D</td>
</tr>
</tbody></table>
<h2 id="浮点数和复数的组成部分（实部和虚部）"><a href="#浮点数和复数的组成部分（实部和虚部）" class="headerlink" title="浮点数和复数的组成部分（实部和虚部）"></a>浮点数和复数的组成部分（实部和虚部）</h2><table>
<thead>
<tr>
<th align="left">占位符</th>
<th align="left">说明</th>
<th align="left">举例</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%b</td>
<td align="left">无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 ‘b’ 转换格式一致。例如 -123456p-78</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">%e</td>
<td align="left">科学计数法，例如 -1234.456e+78</td>
<td align="left">Printf(“%e”, 10.2)</td>
<td align="left">1.020000e+01</td>
</tr>
<tr>
<td align="left">%E</td>
<td align="left">科学计数法，例如 -1234.456E+78</td>
<td align="left">Printf(“%e”, 10.2)</td>
<td align="left">1.020000E+01</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="left">有小数点而无指数，例如 123.456</td>
<td align="left">Printf(“%f”, 10.2)</td>
<td align="left">10.200000</td>
</tr>
<tr>
<td align="left">%g</td>
<td align="left">根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>
<td align="left">Printf(“%g”, 10.20)</td>
<td align="left">10.2</td>
</tr>
<tr>
<td align="left">%G</td>
<td align="left">根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>
<td align="left">Printf(“%G”, 10.20+2i)</td>
<td align="left">(10.2+2i)</td>
</tr>
</tbody></table>
<h2 id="字符串与字节切片"><a href="#字符串与字节切片" class="headerlink" title="字符串与字节切片"></a>字符串与字节切片</h2><table>
<thead>
<tr>
<th align="left">占位符</th>
<th align="left">说明</th>
<th align="left">举例</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%s</td>
<td align="left">输出字符串表示（string类型或[]byte)</td>
<td align="left">Printf(“%s”, []byte(“Go语言”))</td>
<td align="left">Go语言</td>
</tr>
<tr>
<td align="left">%q</td>
<td align="left">双引号围绕的字符串，由Go语法安全地转义</td>
<td align="left">Printf(“%q”, “Go语言”)</td>
<td align="left">“Go语言”</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">十六进制，小写字母，每字节两个字符</td>
<td align="left">Printf(“%x”, “golang”)</td>
<td align="left">676f6c616e67</td>
</tr>
<tr>
<td align="left">%X</td>
<td align="left">十六进制，大写字母，每字节两个字符</td>
<td align="left">Printf(“%X”, “golang”)</td>
<td align="left">676F6C616E67</td>
</tr>
</tbody></table>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">占位符         说明                      举例                             输出</span><br><span class="line">%p      十六进制表示，前缀 0x          Printf(&quot;%p&quot;, &amp;people)             0x4f57f0</span><br></pre></td></tr></table></figure>

<h2 id="其它标记"><a href="#其它标记" class="headerlink" title="其它标记"></a>其它标记</h2><pre><code>占位符      说明                             举例          输出
+      总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 
                                           Printf(&quot;%+q&quot;, &quot;中文&quot;)  &quot;\u4e2d\u6587&quot;
-      在右侧而非左侧填充空格（左对齐该区域）
#      备用格式：为八进制添加前导 0（%#o）      Printf(&quot;%#U&quot;, &#39;中&#39;)      U+4E2D
       为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；
       如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串；
       如果是可打印字符，%U（%#U）会写出该字符的
       Unicode 编码形式（如字符 x 会被打印成 U+0078 &#39;x&#39;）。
&#39; &#39;    (空格)为数值中省略的正负号留出空白（% d）；
       以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开
0      填充前导的0而非空格；对于数字，这会将填充移到正负号之后
</code></pre>
<p>golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。</p>
<p>宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。<br>操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。</p>
<p>对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。</p>
<p>%e 和 %f 的默认精度为6</p>
<p>对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。</p>
<p>而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之数据类型</title>
    <url>/2020/04/08/go_data_type/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/go/int_20201118230752.png?x-oss-process=style/original_format"></p>
<blockquote>
<p>特殊整型</p>
</blockquote>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/go/int2_20201118231157.png?x-oss-process=style/original_format"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 十进制</span><br><span class="line">    var a int = 10</span><br><span class="line">    fmt.Printf(&quot;%d \n&quot;, a) // 10</span><br><span class="line">    fmt.Printf(&quot;%b \n&quot;, a) // 1010  占位符%b表示二进制</span><br><span class="line"></span><br><span class="line">    // 八进制  以0开头</span><br><span class="line">    var b int = 077</span><br><span class="line">    fmt.Printf(&quot;%o \n&quot;, b) // 77</span><br><span class="line"></span><br><span class="line">    // 十六进制  以0x开头</span><br><span class="line">    var c int = 0xff</span><br><span class="line">    fmt.Printf(&quot;%x \n&quot;, c) // ff</span><br><span class="line">    fmt.Printf(&quot;%X \n&quot;, c) // FF</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="浮点型-more"><a href="#浮点型-more" class="headerlink" title="浮点型(more)"></a>浮点型(<a href="https://www.cnblogs.com/goujian/p/11797764.html">more</a>)</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循IEEE 754标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。<code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<p>打印浮点数时，可以使用fmt包配合动词<code>%f</code>，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;math&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">        fmt.Printf(&quot;%f\n&quot;, math.Pi)</span><br><span class="line">        fmt.Printf(&quot;%.2f\n&quot;, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><blockquote>
<p>了解即可，用于科学计算领域</p>
</blockquote>
<p>complex64和complex128</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var c1 complex64</span><br><span class="line">c1 = 1 + 2i</span><br><span class="line">var c2 complex128</span><br><span class="line">c2 = 2 + 3i</span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure>
<p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>
<hr>
<h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><ol>
<li>布尔类型变量的默认值为false。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为双引号<code>(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 := &quot;hello&quot;</span><br><span class="line">s2 := &quot;你好&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串转义符</p>
</blockquote>
<p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\r</td>
<td align="center">回车符（返回行首）</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center">&#39;</td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">反斜杠</td>
</tr>
</tbody></table>
<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多行字符串：</p>
</blockquote>
<p>Go语言中要定义一个多行字符串时，就必须使用反引号字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 := `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">`</span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>
<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/go/gostring_20201117171335.png?x-oss-process=style/original_format"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main // 声明一个包，表示当前是一个可执行程序</span><br><span class="line"></span><br><span class="line">import ( // 导入内置的fmt包</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 字符串常用操作</span><br><span class="line">func main() &#123; // main函数，程序执行的入口</span><br><span class="line">   // 求字符串的长度</span><br><span class="line">   s1 := &quot;hello&quot;</span><br><span class="line">   fmt.Println(len(s1)) // 5</span><br><span class="line">   s2 := &quot;hello beijing&quot;</span><br><span class="line">   fmt.Println(len(s2)) // 11</span><br><span class="line"></span><br><span class="line">   // 拼接字符串</span><br><span class="line">   fmt.Println(s1 + s2)</span><br><span class="line">   s3 := fmt.Sprintf(&quot;%s - %s&quot;, s1, s2) // hello - hello beijing</span><br><span class="line">   fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">   // 字符串的分割</span><br><span class="line">   s4 := &quot;how do you do&quot;</span><br><span class="line">   fmt.Println(strings.Split(s4, &quot; &quot;)) // [how old are you]</span><br><span class="line">   fmt.Printf(&quot;%T\n&quot;, strings.Split(s4, &quot; &quot;)) // 切割之后的数据类型 []string</span><br><span class="line"></span><br><span class="line">   // 判断是否包含</span><br><span class="line">   fmt.Println(strings.Contains(s4, &quot;do&quot;))</span><br><span class="line"></span><br><span class="line">   // 判断前缀</span><br><span class="line">   fmt.Println(strings.HasPrefix(s4, &quot;how&quot;)) // 返回bool true</span><br><span class="line">   // 判断后缀</span><br><span class="line">   fmt.Println(strings.HasSuffix(s4, &quot;how&quot;)) // 返回bool false</span><br><span class="line"></span><br><span class="line">   // 判断子串的位置</span><br><span class="line">   fmt.Println(strings.LastIndex(s4, &quot;do&quot;))</span><br><span class="line">   // 最后子串出现的位置</span><br><span class="line">   fmt.Println(strings.LastIndex(s4, &quot;do&quot;))</span><br><span class="line"></span><br><span class="line">   // join</span><br><span class="line">   s5 := []string&#123;&quot;how&quot;, &quot;do&quot;, &quot;you&quot;, &quot;do&quot;&#125;</span><br><span class="line">   fmt.Println(s5) // [how do you do]</span><br><span class="line">   fmt.Println(strings.Join(s5, &quot;+&quot;)) // how+do+you+do</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="byte-和-rune"><a href="#byte-和-rune" class="headerlink" title="byte 和 rune"></a>byte 和 rune</h2><p>Go 语言的字符有以下两种：</p>
<ul>
<li>uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。</li>
<li>rune类型，代表一个 UTF-8字符。</li>
</ul>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 遍历字符串</span><br><span class="line">func traversalString() &#123;</span><br><span class="line">    s := &quot;hello沙河&quot;</span><br><span class="line">    for i := 0; i &lt; len(s); i++ &#123; //byte</span><br><span class="line">        fmt.Printf(&quot;%v(%c) &quot;, s[i], s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    for _, r := range s &#123; //rune</span><br><span class="line">        fmt.Printf(&quot;%v(%c) &quot;, r, r)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) </span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // byte unit8的别名 ASCII码</span><br><span class="line">    // rune int32的别名</span><br><span class="line">    var c1 byte = &#x27;c&#x27;</span><br><span class="line">    var c2 rune = &#x27;c&#x27;</span><br><span class="line">    fmt.Println(c1, c2)</span><br><span class="line">    fmt.Printf(&quot;c1:%T c2:%T&quot;, c1, c2)</span><br><span class="line"></span><br><span class="line">    s := &quot;hello 北京&quot;</span><br><span class="line">    for i := 0; i &lt; len(s); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%c\n&quot;, s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;-------\n&quot;)</span><br><span class="line">    for _,r := range s &#123;</span><br><span class="line">        fmt.Printf(&quot;%c\n&quot;, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">99 99</span><br><span class="line">c1:uint8 c2:int32h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line"> </span><br><span class="line">å</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ä</span><br><span class="line">º</span><br><span class="line">¬</span><br><span class="line">-------</span><br><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line"> </span><br><span class="line">北</span><br><span class="line">京</span><br></pre></td></tr></table></figure>

<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func changeString() &#123;</span><br><span class="line">    s1 := &quot;big&quot;</span><br><span class="line">    // 强制类型转换</span><br><span class="line">    byteS1 := []byte(s1)</span><br><span class="line">    byteS1[0] = &#x27;p&#x27;</span><br><span class="line">    fmt.Println(string(byteS1))</span><br><span class="line"></span><br><span class="line">    s2 := &quot;白萝卜&quot;</span><br><span class="line">    runeS2 := []rune(s2)</span><br><span class="line">    runeS2[0] = &#x27;红&#x27;</span><br><span class="line">    fmt.Println(string(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换-more"><a href="#类型转换-more" class="headerlink" title="类型转换(more)"></a>类型转换(<a href="http://wen.topgoer.com/docs/golang/chapter03-8">more</a>)</h2><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ul>
<li><p>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用fmt.Printf()搭配%T分别打印出上述变量的值和类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := 11</span><br><span class="line">    var b float64 = 3.14</span><br><span class="line">    c := true</span><br><span class="line">    d := &quot;boy&quot;</span><br><span class="line">    fmt.Println(&quot;值：类型&quot;)</span><br><span class="line">    fmt.Printf(&quot;%d：%T\n&quot;, a, a)</span><br><span class="line">    fmt.Printf(&quot;%v：%T\n&quot;, b, b)</span><br><span class="line">    fmt.Printf(&quot;%v：%T\n&quot;, c, c)</span><br><span class="line">    fmt.Printf(&quot;%v：%T\n&quot;, d, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写代码统计出字符串”hello 房山小王子”中汉字的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    s := &quot;hello 房山小王子&quot;</span><br><span class="line">    count := 0</span><br><span class="line">    for _, v := range s &#123;</span><br><span class="line">        fmt.Printf(&quot;%v: %T\n&quot;, v, v)</span><br><span class="line">        // fmt.Println(string(v))</span><br><span class="line">        fmt.Println(len(string(v)))</span><br><span class="line">        if len(string(v)) &gt;= 3 &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;汉字数量&quot;, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<blockquote>
<p><strong>知识文档</strong>：</p>
</blockquote>
<ul>
<li><a href="https://www.liwenzhou.com/posts/Go/02_datatype/">基本数据类型-LWZ</a></li>
<li><a href="http://wen.topgoer.com/docs/golang/chapter03-8">基本类型-topgoer发布</a></li>
<li><a href="https://studygolang.com/articles/2644">golang fmt格式“占位符”</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>go主要特征—标识符、关键字、构建、编译</title>
    <url>/2020/01/31/go%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>区别关键字和标识符：</p>
</blockquote>
<pre><code>标识（zhi）符，所谓标识符，就是指变量、函数、属性的名字，或者是函数的参数。

关键字，就是在控制语句的开始或结束以及执行特定操作时具有关键作用、特定作用的符号。

保留（关键）字不能用作常量、变量、函数名以及结构字段等标识符。从字面意思上即可得知它是被保留的，将来可能被用作关键字
</code></pre>
<p><strong>划重点了：</strong>·<code>关键字是系统自带的 ，标识符是自定义的</code>。</p>
<hr>
<h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>Go 的源文件以 .go 为后缀名存储在计算机中，这些<code>文件名均由小写字母组成</code>，如 <code>scanner.go</code> 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 <code>scanner_test.go</code> 。<code>文件名不包含空格或其他特殊字符</code>。</p>
<p>一个源文件可以包含任意多行的代码，Go 本身没有对源文件的大小进行限制。</p>
<h2 id="Go语言命名"><a href="#Go语言命名" class="headerlink" title="Go语言命名"></a>Go语言命名</h2><p>Go的函数、变量、常量、自定义类型、包<code>(package)</code>的命名方式遵循以下规则：</p>
<pre><code>1）首字符可以是任意的Unicode字符或者下划线
2）剩余字符可以是Unicode字符、下划线、数字
3）字符长度不限
</code></pre>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><code>具有特殊意义的词</code>，比如变量、常量、函数。</p>
<blockquote>
<p>标识符是允许作为变量（函数、类等）名称的有效字符串</p>
</blockquote>
<p>Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头，然后紧跟着 0 个或多个字符或 Unicode 数字。<br>举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字是编程语言中<code>预先定义好的具有特殊含义的标识符</code>。关键字和保留字都不建议用作变量名。</p>
<p><strong>Go语言中有25个关键字：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break        default      func         interface    select</span><br><span class="line">case         defer        go           map          struct</span><br><span class="line">chan         else         goto         package      switch</span><br><span class="line">const        fallthrough  if           range        type</span><br><span class="line">continue     for          import       return       var</span><br></pre></td></tr></table></figure>

<p><strong>此外，Go语言中还有37个保留字：</strong><br>（分类为<a href="http://wen.topgoer.com/docs/golang/chapter02-2">内置常量/类型/函数</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constants:    true  false  iota  nil</span><br><span class="line"></span><br><span class="line">Types:    int  int8  int16  int32  int64  </span><br><span class="line">          uint  uint8  uint16  uint32  uint64  uintptr</span><br><span class="line">          float32  float64  complex128  complex64</span><br><span class="line">          bool  byte  rune  string  error</span><br><span class="line"></span><br><span class="line">Functions:   make  len  cap  new  append  copy  close  delete</span><br><span class="line">             complex  real  imag</span><br><span class="line">             panic  recover</span><br></pre></td></tr></table></figure>

<h2 id="Go语言声明："><a href="#Go语言声明：" class="headerlink" title="Go语言声明："></a>Go语言声明：</h2><p>有四种主要声明方式：</p>
<pre><code>var（声明变量）, const（声明常量）, type（声明类型） ,func（声明函数）。
</code></pre>
<p>Go的程序是保存在多个.go文件中，文件的第一行就是package XXX声明，用来说明该文件属于哪个包(package)，package声明下来就是import声明，再下来是类型，变量，常量，函数的声明。</p>
<h2 id="预定义标识符的总结分类"><a href="#预定义标识符的总结分类" class="headerlink" title="预定义标识符的总结分类"></a>预定义标识符的总结分类</h2><blockquote>
<p><a href="https://www.cnblogs.com/xzpin/p/11659839.html">Go 内置常量 类型和函数</a></p>
</blockquote>
<h2 id="Go项目构建及编译"><a href="#Go项目构建及编译" class="headerlink" title="Go项目构建及编译"></a>Go项目构建及编译</h2><p>一个Go工程中主要包含以下三个目录：</p>
<pre><code>src：源代码文件
pkg：包文件
bin：相关bin文件
</code></pre>
<p>1: 建立工程文件夹 goproject<br>2: 在工程文件夹中建立src,pkg,bin文件夹<br>3: 在GOPATH中添加projiect路径 例 e:/goproject<br>4: 如工程中有自己的包examplepackage，那在src文件夹下建立以包名命名的文件夹 例 examplepackage<br>5：在src文件夹下编写主程序代码代码 goproject.go<br>6：在examplepackage文件夹中编写 examplepackage.go 和 包测试文件 examplepackage_test.go<br>7：编译调试包<br>go build examplepackage<br>go test examplepackage<br>go install examplepackage<br>这时在pkg文件夹中可以发现会有一个相应的操作系统文件夹如windows_386z, 在这个文件夹中会有examplepackage文件夹，在该文件中有examplepackage.a文件<br>8：编译主程序<br>go build goproject.go<br>成功后会生成goproject.exe文件<br>至此一个Go工程编辑成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.建立工程文件夹 go</span><br><span class="line">$ pwd</span><br><span class="line">/Users/***/Desktop/go</span><br><span class="line">2: 在工程文件夹中建立src,pkg,bin文件夹</span><br><span class="line">$ ls</span><br><span class="line">bin        conf    pkg        src</span><br><span class="line">3: 在GOPATH中添加projiect路径</span><br><span class="line">$ go env</span><br><span class="line">GOPATH=&quot;/Users/liupengjie/Desktop/go&quot;</span><br><span class="line">4: 那在src文件夹下建立以自己的包 example 文件夹</span><br><span class="line">$ cd src/</span><br><span class="line">$ mkdir example</span><br><span class="line">5：在src文件夹下编写主程序代码代码 goproject.go</span><br><span class="line">6：在example文件夹中编写 example.go 和 包测试文件 example_test.go</span><br><span class="line">    example.go 写入如下代码：</span><br><span class="line"></span><br><span class="line">    package example</span><br><span class="line"></span><br><span class="line">    func add(a, b int) int &#123;</span><br><span class="line">        return a + b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sub(a, b int) int &#123;</span><br><span class="line">        return a - b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    example_test.go 写入如下代码：</span><br><span class="line"></span><br><span class="line">    package example</span><br><span class="line"></span><br><span class="line">    import (</span><br><span class="line">        &quot;testing&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    func TestAdd(t *testing.T) &#123;</span><br><span class="line">        r := add(2, 4)</span><br><span class="line">        if r != 6 &#123;</span><br><span class="line">            t.Fatalf(&quot;add(2, 4) error, expect:%d, actual:%d&quot;, 6, r)</span><br><span class="line">        &#125;</span><br><span class="line">        t.Logf(&quot;test add succ&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">7：编译调试包</span><br><span class="line">$ go build example</span><br><span class="line">$ go test example</span><br><span class="line">ok      example    0.013s</span><br><span class="line">$ go install example</span><br><span class="line"></span><br><span class="line">$ ls /Users/***/Desktop/go/pkg/</span><br><span class="line">darwin_amd64</span><br><span class="line">$ ls /Users/***/Desktop/go/pkg/darwin_amd64/</span><br><span class="line">example.a    </span><br><span class="line">8：编译主程序</span><br><span class="line">oproject.go 写入如下代码：</span><br><span class="line">package main </span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    fmt.Println(&quot;go project test&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go build goproject.go</span><br><span class="line">$ ls</span><br><span class="line"> example        goproject.go    goproject</span><br><span class="line"></span><br><span class="line">成功后会生成goproject文件，至此一个Go工程编辑成功。</span><br><span class="line"></span><br><span class="line">运行该文件：</span><br><span class="line">$ ./goproject</span><br><span class="line">go project test</span><br></pre></td></tr></table></figure>

<h2 id="go-编译问题"><a href="#go-编译问题" class="headerlink" title="go 编译问题"></a>go 编译问题</h2><p>golang的编译使用命令 go build , go install;除非仅写一个main函数，否则还是准备好目录结构；<br>GOPATH=工程根目录；其下应创建src，pkg，bin目录，bin目录中用于生成可执行文件，pkg目录中用于生成.a文件；<br>golang中的import name，实际是到GOPATH中去寻找name.a, 使用时是该name.a的源码中生命的package 名字；这个在前面已经介绍过了。</p>
<p>注意点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.系统编译时 go install abc_name时，系统会到GOPATH的src目录中寻找abc_name目录，然后编译其下的go文件；</span><br><span class="line">2.同一个目录中所有的go文件的package声明必须相同，所以main方法要单独放一个文件，否则在eclipse和liteide中都会报错；</span><br><span class="line">编译报错如下：（假设test目录中有个main.go 和mymath.go,其中main.go声明package为main，mymath.go声明packag 为test);</span><br><span class="line"></span><br><span class="line">    $ go install test</span><br><span class="line">    can&#x27;t load package: package test: found packages main (main.go) and test (mymath.go) in /home/wanjm/go/src/test</span><br><span class="line">    报错说 不能加载package test（这是命令行的参数），因为发现了两个package，分别时main.go 和 mymath.go;</span><br><span class="line"></span><br><span class="line">3.对于main方法，只能在bin目录下运行 go build path_tomain.go; 可以用-o参数指出输出文件名；</span><br><span class="line">4.可以添加参数 go build -gcflags &quot;-N -l&quot; ****,可以更好的便于gdb；详细参见 http://golang.org/doc/gdb</span><br><span class="line">5.gdb全局变量主一点。 如有全局变量 a；则应写为 p &#x27;main.a&#x27;；注意但引号不可少；</span><br></pre></td></tr></table></figure>

<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!--https://www.cnblogs.com/xzpin/p/11659839.html-->  
<!--https://www.pianshen.com/article/2306569585/-->  
<!--http://wen.topgoer.com/docs/golang/chapter02-1-->
<!--https://blog.csdn.net/vongolar/article/details/108314005-->  
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础之变量和常量</title>
    <url>/2020/04/08/go_var_constant/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：<code>整型、浮点型、布尔型</code>等。</p>
<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>
<h2 id="变量声明-var"><a href="#变量声明-var" class="headerlink" title="变量声明 var"></a>变量声明 var</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p>
<h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 变量名 变量类型</span><br></pre></td></tr></table></figure>

<p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">var isOk bool</span><br></pre></td></tr></table></figure>

<h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    a string</span><br><span class="line">    b int</span><br><span class="line">    c bool</span><br><span class="line">    d float32</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p>
<p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name string = &quot;Q1mi&quot;</span><br><span class="line">var age int = 18</span><br></pre></td></tr></table></figure>
<p>或者一次初始化多个变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name, age = &quot;Q1mi&quot;, 20</span><br></pre></td></tr></table></figure>

<p><strong>类型推导</strong><br>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &quot;Q1mi&quot;</span><br><span class="line">var age = 18</span><br></pre></td></tr></table></figure>

<h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明 :="></a><strong>短变量声明</strong> :=</h3><p>在函数内部，可以使用更简略的<code>:=</code>方式声明并初始化变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">// 全局变量m</span><br><span class="line">var m = 100</span><br><span class="line">// n := &quot;smile111&quot; // 非法，短变量声明方式只能用于函数内部</span><br><span class="line">func main() &#123;</span><br><span class="line">    n := 10</span><br><span class="line">    m := 200 // 此处声明局部变量m</span><br><span class="line">    fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量 _"></a><strong>匿名变量</strong> _</h3><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线_表示，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func foo() (int, string) &#123;</span><br><span class="line">    return 10, &quot;Q1mi&quot;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    x, _ := foo()</span><br><span class="line">    _, y := foo()</span><br><span class="line">    fmt.Println(&quot;x=&quot;, x)</span><br><span class="line">    fmt.Println(&quot;y=&quot;, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p>
<p> <code>注意事项：</code></p>
<ol>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li><code>:=</code>不能使用在函数外。</li>
<li><code>_</code>多用于占位，表示忽略值。</li>
</ol>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const pi = 3.1415</span><br><span class="line">const e = 2.7182</span><br></pre></td></tr></table></figure>
<p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>
<p>多个常量也可以一起声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    pi = 3.1415</span><br><span class="line">    e = 2.7182</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    n1 = 100</span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p>
<p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p>
<p><strong>举个例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    n1 = iota //0</span><br><span class="line">    n2        //1</span><br><span class="line">    n3        //2</span><br><span class="line">    n4        //3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>几个常见的iota示例:</strong><br>使用<code>_</code>跳过某些值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    n1 = iota //0</span><br><span class="line">    n2        //1</span><br><span class="line">    _</span><br><span class="line">    n4        //3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>iota</code>声明中间插队</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    n1 = iota //0</span><br><span class="line">    n2 = 100  //100</span><br><span class="line">    n3 = iota //2</span><br><span class="line">    n4        //3</span><br><span class="line">)</span><br><span class="line">const n5 = iota //0</span><br></pre></td></tr></table></figure>

<p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    _  = iota</span><br><span class="line">    KB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">    MB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">    GB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">    TB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">    PB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>多个<code>iota</code>定义在一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a, b = iota + 1, iota + 2 //1,2</span><br><span class="line">    c, d                      //2,3</span><br><span class="line">    e, f                      //3,4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
        <tag>variable</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/1992/06/21/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>吃喝玩乐</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Go依赖管理—从godep到go mod</title>
    <url>/2020/01/31/go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E2%80%94_godep_gomod/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="1-1-为什么需要依赖管理"><a href="#1-1-为什么需要依赖管理" class="headerlink" title="1.1 为什么需要依赖管理"></a>1.1 为什么需要依赖管理</h2><p>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p>
<h2 id="1-2-godep"><a href="#1-2-godep" class="headerlink" title="1.2 godep"></a>1.2 godep</h2><p>Go语言从<code>v1.5</code>开始开始引入<code>vendor</code>模式，如果项目目录下有vendor目录，那么go工具链会优先使用<code>vendor</code>内的包进行编译、测试等。</p>
<p><code>godep</code>是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具<code>dep</code>。</p>
<blockquote>
<p>注意：在<code>Go1.11</code>之后，建议<a href="https://learnku.com/articles/33241">将 dep 更换为 go mod</a>进行项目管理，更方便</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行以下命令安装godep工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get github.com/tools/godep</span><br></pre></td></tr></table></figure>

<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>安装好godep之后，在终端输入godep查看支持的所有命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">godep save     将依赖项输出并复制到Godeps.json文件中</span><br><span class="line">godep go       使用保存的依赖项运行go工具</span><br><span class="line">godep get      下载并安装具有指定依赖项的包</span><br><span class="line">godep path     打印依赖的GOPATH路径</span><br><span class="line">godep restore  在GOPATH中拉取依赖的版本</span><br><span class="line">godep update   更新选定的包或go版本</span><br><span class="line">godep diff     显示当前和以前保存的依赖项集之间的差异</span><br><span class="line">godep version  查看版本信息</span><br></pre></td></tr></table></figure>
<p>使用godep help [command]可以看看具体命令的帮助信息</p>
<h3 id="使用godep"><a href="#使用godep" class="headerlink" title="使用godep"></a>使用godep</h3><p>在项目目录下执行godep save命令，会在当前项目中创建Godeps和vender两个文件夹。</p>
<p>其中Godeps文件夹下有一个Godeps.json的文件，里面记录了项目所依赖的包信息。 vender文件夹下是项目依赖的包的源代码文件。</p>
<h3 id="vender机制"><a href="#vender机制" class="headerlink" title="vender机制"></a>vender机制</h3><p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p>
<p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p>
<h3 id="godep开发流程"><a href="#godep开发流程" class="headerlink" title="godep开发流程"></a>godep开发流程</h3><p>保证程序能够正常编译<br>执行godep save保存当前项目的所有第三方依赖的版本信息和代码<br>提交Godeps目录和vender目录到代码库。<br>如果要更新依赖的版本，可以直接修改Godeps.json文件中的对应项</p>
<h2 id="1-3-go-module"><a href="#1-3-go-module" class="headerlink" title="1.3 go module"></a>1.3 go module</h2><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p>
<h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off、on、auto</code>，默认值是<code>auto</code>。</p>
<ol>
<li>GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。</li>
<li>GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。</li>
<li>GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。<br>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。<br>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</li>
</ol>
<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>Go1.11之后设置GOPROXY命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure>
<p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>，在国内是无法访问的，所以十分建议大家设置<code>GOPROXY=https://goproxy.cn</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>常用的go mod命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）</span><br><span class="line">go mod edit        编辑go.mod文件</span><br><span class="line">go mod graph       打印模块依赖图</span><br><span class="line">go mod init        初始化当前文件夹, 创建go.mod文件</span><br><span class="line">go mod tidy        增加缺少的module，删除无用的module</span><br><span class="line">go mod vendor      将依赖复制到vendor下</span><br><span class="line">go mod verify      校验依赖</span><br><span class="line">go mod why         解释为什么需要依赖</span><br></pre></td></tr></table></figure>

<p><strong>go.mod</strong><br>go.mod文件记录了项目所有的依赖信息，其结构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module github.com/Q1mi/studygo/blogger</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586</span><br><span class="line">    github.com/gin-gonic/gin v1.4.0</span><br><span class="line">    github.com/go-sql-driver/mysql v1.4.1</span><br><span class="line">    github.com/jmoiron/sqlx v1.2.0</span><br><span class="line">    github.com/satori/go.uuid v1.2.0</span><br><span class="line">    google.golang.org/appengine v1.6.1 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>module用来定义包名</li>
<li>require用来定义依赖包及版本</li>
<li>indirect表示间接引用</li>
</ul>
<p><strong><code>依赖的版本</code></strong><br>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7</span><br><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2.9.1</span><br><span class="line">gopkg.in/yaml.v2 &lt;=v2.2.1</span><br><span class="line">github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e</span><br><span class="line">latest</span><br></pre></td></tr></table></figure>

<p><strong><code>replace</code></strong><br>在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace (</span><br><span class="line">    golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac</span><br><span class="line">    golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d</span><br><span class="line">    golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p>
<ol>
<li>运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行go get -u=patch将会升级到最新的修订版本</li>
<li>运行go get package@version将会升级到指定的版本号version<br>如果下载所有依赖可以使用<code>go mod download</code>命令。</li>
</ol>
<h3 id="go-mod-edit"><a href="#go-mod-edit" class="headerlink" title="go mod edit"></a>go mod edit</h3><p><strong><code>格式化</code></strong><br>因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure>
<p><strong><code>添加依赖项</code></strong><br>go mod edit -require=golang.org/x/text<br><strong><code>移除依赖项</code></strong><br>如果只是想修改go.mod文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/tex</code>t包，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go mod edit -droprequire=golang.org/x/text</span><br></pre></td></tr></table></figure>
<p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p>
<h2 id="1-4在项目中使用go-module"><a href="#1-4在项目中使用go-module" class="headerlink" title="1.4在项目中使用go module"></a>1.4在项目中使用go module</h2><h3 id="既有项目"><a href="#既有项目" class="headerlink" title="既有项目"></a>既有项目</h3><p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p>
<p>在项目目录下执行go mod init，生成一个go.mod文件。<br>执行go get，查找并记录当前项目的依赖，同时生成一个go.sum记录每个依赖库的版本和哈希值。</p>
<h3 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h3><p>对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作：</p>
<ul>
<li>执行go mod init 项目名命令，在当前项目文件夹下创建一个go.mod文件。</li>
<li>手动编辑go.mod中的require依赖项或执行go get自动发现、维护依赖。</li>
</ul>
<hr>
<p>&nbsp;  </p>
<!--**参考文章**：-->  
<!---->  
<!---->  



]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux grep命令详解：查找文件内容</title>
    <url>/2017/04/06/linux_cmd_grep/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。</p>
<h1 id="grep-与-正则表达式"><a href="#grep-与-正则表达式" class="headerlink" title="grep 与 正则表达式"></a>grep 与 正则表达式</h1><p>grep命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。</p>
<p>正则表达式只是字符串的一种描述，它的构成模仿了数学表达式，通过使用操作符将较小的表达式组合成一个新的表达式；只有和支持正则表达式的工具相结合才能进行字符串处理。vim、grep、awk 、sed 都支持正则表达式，也正是因为由于它们支持正则，才显得它们强大；</p>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p><strong>功能：</strong><br>输入文件的每一行中查找字符串。<br><strong>语法：</strong></p>
<pre><code>grep [-acinv] [--color=auto] [-A n] [-B n] &#39;搜寻字符串&#39; 文件名
</code></pre>
<p><strong>选项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：将二进制文档以文本方式处理</span><br><span class="line">-c：显示匹配次数</span><br><span class="line">-i：忽略大小写差异</span><br><span class="line">-n：在行首显示行号</span><br><span class="line">-A：After的意思，显示匹配字符串后n行的数据</span><br><span class="line">-B：before的意思，显示匹配字符串前n行的数据</span><br><span class="line">-v：显示没有匹配行</span><br><span class="line">-A：After的意思，显示匹配部分之后n行</span><br><span class="line">-B：before的意思，显示匹配部分之前n行</span><br><span class="line">--color：以特定颜色高亮显示匹配关键字</span><br><span class="line">    --color选项是个非常好的选项，可以让你清楚的明白匹配了那些字符。最好在自己的.bashrc或者.bash_profile文件中加入：</span><br><span class="line">    alias grep=grep --color=auto</span><br><span class="line">    每次grep搜索之后，自动高亮匹配效果了。</span><br><span class="line">    搜寻字符串’是正则表达式，注意为了避免shell的元字符对正则表达式的影响，请用单引号（’’）括起来，千万不要用双引号括起来（&quot;”）或者不括起来。</span><br><span class="line">    正则表达式分为基本正则表达式和扩展正则表达式。下面分别简单总结一下。</span><br></pre></td></tr></table></figure>

<h2 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h2><p>正则表达式学习，主要是对正则表达式元数据的学习。正则表达式本身没有什么高深的东西，本文仅仅对基本正则表达式的元数据进行一下总结：</p>
<p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/06/grep_1.png?x-oss-process=style/original_format"></p>
<h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>grep一般情况下支持基本正则表达式，可以通过参数-E支持扩展正则表达式，另外grep单独提供了一个扩展命令叫做egrep用来支持扩展正则表达式，这条命令和grep -E等价。虽然一般情况下，基本正则表达式就够用了。特殊情况下，复杂的扩展表达式，可以简化字符串的匹配。</p>
<p>扩展正则表达式就是在基本正则表达式的基础上，增加了一些元数据。</p>
<p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/06/grep_2.png?x-oss-process=style/original_format"></p>
<hr>
<!--http://c.biancheng.net/view/4017.html-->  
<!---->  


]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Vim基本操作（文件的打开和编辑）完全攻略</title>
    <url>/2017/03/27/linux_cmd_vim/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Linux 系统中“一切皆文件”，因此当我们在命令行下更改文件内容时，不可避免地要用到文本编辑器。</p>
<h2 id="Vim（文件的打开和编辑）的常用快捷键"><a href="#Vim（文件的打开和编辑）的常用快捷键" class="headerlink" title="Vim（文件的打开和编辑）的常用快捷键"></a>Vim（文件的打开和编辑）的常用快捷键</h2><p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/06/vim_20210615144140.jpg?x-oss-process=style/original_format"></p>
]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux tar/zip/unzip命令：打包（归档）和压缩详解</title>
    <url>/2017/03/25/linux_command_tar/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><strong>打包</strong> 指的是将多个文件和目录集中存储在一个文件中；<br><strong>压缩</strong> 指的是利用算法对文件进行处理，从而达到缩减占用磁盘空间的目的。<br>Linux 下，常用归档（打包）命令有 2 个，分别是 <code>tar</code> 和 <code>dd</code>（相对而言，tar 的使用更为广泛）；常用的压缩命令有很多，比如 <code>gzip、zip、bzip2</code> 等</p>
<h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a><a href="https://wangchujiang.com/linux-command/c/tar.html">tar</a></h1><p>Linux 系统中，最常用的归档（打包）命令就是 tar，该命令可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。不仅如此，该命令还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包。</p>
<pre><code>使用 tar 命令归档的包通常称为 tar 包（tar 包文件都是以“.tar”结尾的）
</code></pre>
<h2 id="tar命令做打包操作"><a href="#tar命令做打包操作" class="headerlink" title="tar命令做打包操作"></a>tar命令做打包操作</h2><p><strong>语法：</strong></p>
<pre><code>tar [选项] 源文件或目录
</code></pre>
<p><strong>选项：</strong></p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-c</td>
<td align="left">将多个文件或目录进行打包。</td>
</tr>
<tr>
<td align="left">-A</td>
<td align="left">追加 tar 文件到归档文件。</td>
</tr>
<tr>
<td align="left">-f 包名</td>
<td align="left">指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">显示打包文件过程；</td>
</tr>
</tbody></table>
<p>需要注意的是，在使用 tar 命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和 “-cvf”起到的作用一样。</p>
<p><strong>举例：</strong></p>
<blockquote>
<p>Example 1：打包文件和目录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br><span class="line"># 把anacondehks.cfg打包为 anacondehks.cfg.tar文件</span><br></pre></td></tr></table></figure>

<p>选项 “-cvf” 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 “.tar” 作为扩展名。打包目录也是如此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll -d test/</span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test/</span><br><span class="line"># test是我们之前的测试目录</span><br><span class="line">[root@localhost ~]# tar -cvf test.tar test/</span><br><span class="line">test/</span><br><span class="line">test/test3</span><br><span class="line">test/test2</span><br><span class="line">test/test1</span><br><span class="line"># 把目录打包为test.tar文件</span><br><span class="line"># tar命令也可以打包多个文件或目录，只要用空格分开即可。例如:</span><br><span class="line">[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg /tmp/</span><br><span class="line"># 把anaconda-ks.cfg文件和/tmp目录打包成ana.tar文件包</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2：包并压缩目录。</p>
</blockquote>
<p>首先声明一点，压缩命令不能直接压缩目录，必须先用 tar 命令将目录打包，然后才能用 gzip 命令或 bzip2 命令对打包文件进行压缩。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#ll -d test test.tar</span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test</span><br><span class="line">-rw-r--r-- 1 root root 10240 6月 18 01:06 test.tar</span><br><span class="line"># 我们之前已经把test目录打包成test.tar文件</span><br><span class="line">[root@localhost ~]# gzip test.tar</span><br><span class="line">[root@localhost ~]# ll test.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 176 6月 18 01:06 test.tar.gz</span><br><span class="line"># gzip命令会把test.tar压缩成test.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="tar命令做解打包操作"><a href="#tar命令做解打包操作" class="headerlink" title="tar命令做解打包操作"></a>tar命令做解打包操作</h2><p><strong>语法：</strong></p>
<pre><code>tar [选项] 压缩包
</code></pre>
<p><strong>选项：</strong></p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-x</td>
<td align="left">对 tar 包做解打包操作。</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">指定要解压的 tar 包的包名。</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td>
</tr>
<tr>
<td align="left">-C 目录</td>
<td align="left">指定解打包位置。</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">显示解打包的具体过程。</td>
</tr>
</tbody></table>
<p>其实解打包和打包相比，只是把打包选项 “-cvf” 更换为 “-xvf”</p>
<p><strong>举例：</strong></p>
<blockquote>
<p>Example1：解打包到当前目录下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg. tar</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example2：解打包到指定目录下</p>
</blockquote>
<p>如果使用 “-xvf” 选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用 “-C(大写)” 选项。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf test.tar -C /tmp</span><br><span class="line"># 把文件包test.tar解打包到/tmp/目录下</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example3：查看包中有哪些文件</p>
</blockquote>
<p>如果只想查看文件包中有哪些文件，则可以把解打包选项 <code>&quot;-x&quot;</code> 更换为测试选项 <code>&quot;-t&quot;</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -tvf test.tar</span><br><span class="line">drwxr-xr-x root/root 0 2016-06-17 21:09 test/</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test3</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test2</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test1</span><br><span class="line"># 会用长格式显示test.tar文件包中文件的详细信息</span><br></pre></td></tr></table></figure>

<h2 id="tar命令做打包压缩（解压缩解打包）操作"><a href="#tar命令做打包压缩（解压缩解打包）操作" class="headerlink" title="tar命令做打包压缩（解压缩解打包）操作"></a>tar命令做打包压缩（解压缩解打包）操作</h2><p>你可能会觉得 Linux 实在太不智能了，一个打包压缩，居然还要先打包成 “.tar” 格式，再压缩成 “.tar.gz” 或 “.tar.bz2” 格式。其实 tar 命令是可以同时打包压缩的，前面的讲解之所打包和压缩分开，是为了让大家了解在 Linux 中打包和压缩的不同。</p>
<p><strong>语法：</strong></p>
<pre><code>tar [选项] 压缩包 源文件或目录
</code></pre>
<p><strong>选项：</strong><br>此处常用的选项有以下 2 个，分别是：</p>
<ul>
<li>-z：压缩和解压缩 “.tar.gz” 格式；</li>
<li>-j：压缩和解压缩 “.tar.bz2”格式。</li>
</ul>
<p><strong>举例：</strong></p>
<blockquote>
<p>Example 1：压缩与解压缩 “.tar.gz”格式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/</span><br><span class="line"># 把/temp/目录直接打包压缩为&quot;.tar.gz&quot;格式，通过&quot;-z&quot;来识别格式，&quot;-cvf&quot;和打包选项一致</span><br></pre></td></tr></table></figure>

<p>解压缩也只是在解打包选项 “-xvf” 前面加了一个 “-z” 选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -zxvf tmp.tar.gz</span><br><span class="line"># 解压缩与解打包&quot;.tar.gz&quot;格式</span><br></pre></td></tr></table></figure>
<p>前面讲的选项 “-C” 用于指定解压位置、”-t” 用于查看压缩包内容，在这里同样适用。</p>
<blockquote>
<p>Example 2：压缩与解压缩 “.tar.bz2” 格式。</p>
</blockquote>
<p>和”.tar.gz”格式唯一的不同就是”-zcvf”选项换成了 “-jcvf”，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/</span><br><span class="line"># 打包压缩为&quot;.tar.bz2&quot;格式，注意压缩包文件名</span><br><span class="line">[root@localhost ~]# tar -jxvf tmp.tar.bz2</span><br><span class="line"># 解压缩与解打包&quot;.tar.bz2&quot;格式</span><br></pre></td></tr></table></figure>

<p>把文件直接压缩成”.tar.gz”和”.tar.bz2”格式，才是 Linux 中最常用的压缩方式，这是大家一定要掌握的压缩和解压缩方法。</p>
<p>tar 命令最初被用来在磁带上创建备份，现在可以在任何设备上创建备份。利用 tar 命令可以把一大堆的文件和目录打包成一个文件，这对于备份文件或是将几个文件组合成为一个文件进行网络传输是非常有用的。</p>
<h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><p>我们经常会在 Windows 系统上使用 “.zip”格式压缩文件，其实“.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式（zip、rar等）之一，是一种相当简单的分别压缩每个文件的存储格式，</p>
<p><strong>语法：</strong></p>
<pre><code>zip [选项] 压缩包名 源文件或源目录列表
</code></pre>
<p><strong>选项：</strong></p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-r</td>
<td align="left">递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td>
</tr>
<tr>
<td align="left">-m</td>
<td align="left">将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">显示详细的压缩过程信息。</td>
</tr>
<tr>
<td align="left">-q</td>
<td align="left">在压缩的时候不显示命令的执行过程。</td>
</tr>
<tr>
<td align="left">-压缩级别</td>
<td align="left">压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td>
</tr>
<tr>
<td align="left">-u</td>
<td align="left">更新压缩文件，即往压缩文件中添加新文件。</td>
</tr>
</tbody></table>
<h1 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h1><p>unzip 命令可以查看和解压缩 zip 文件。<br><strong>语法：</strong></p>
<pre><code>unzip [选项] 压缩包名
</code></pre>
<p><strong>选项：</strong></p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-d 目录名</td>
<td align="left">将压缩文件解压到指定目录下。</td>
</tr>
<tr>
<td align="left">-q</td>
<td align="left">执行时不显示任何信息；</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">解压时并不覆盖已经存在的文件。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">解压时覆盖已经存在的文件，并且无需用户确认。</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">测试压缩文件有无损坏，但并不解压。</td>
</tr>
<tr>
<td align="left">-x 文件列表</td>
<td align="left">解压文件，但不包含文件列表中指定的文件。</td>
</tr>
</tbody></table>
<p><strong>举例：</strong></p>
<blockquote>
<p>Example 1：使用 -d 选项手动指定解压缩位置，例如：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unzip -d /tmp/ ana.zip</span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line"># 把压缩包解压到指定位置</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统的层次结构</title>
    <url>/2017/03/20/linux_directory_structure/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>知识文档：</p>
</blockquote>
<p><a href="https://www.runoob.com/linux/linux-system-contents.html">根目录下的各目录用途</a></p>
<h2 id="Linux文件系统的层次结构"><a href="#Linux文件系统的层次结构" class="headerlink" title="Linux文件系统的层次结构"></a>Linux文件系统的层次结构</h2><p>在 Linux 操作系统中，所有的文件和目录都被组织成以一个根节点“/”开始的倒置的树状结构</p>
<p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/06/2-1Z5061A1003X.gif?x-oss-process=style/original_format" alt="Linux 系统文件和目录组织示意图"></p>
<p>其中，目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用“/”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。</p>
<pre><code>其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。
</code></pre>
<p>现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。</p>
<p>注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“/”来分隔。如 cat 的完整路径是 /home/cat。</p>
<p>在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“.”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“..”表示。</p>
<pre><code>如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找（后续会讲查找命令）时，不显示该目录或文件。
</code></pre>
]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>Linux安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux touch命令：创建文件及修改文件时间戳</title>
    <url>/2017/03/21/linux_command_touch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h1><p>touch 命令不光可以用来创建文件（当指定操作文件不存在时，该命令会在当前位置建立一个空文件），此命令更重要的功能是修改文件的时间参数（但当文件存在时，会修改此文件的时间参数）。</p>
<p>Linux 系统中，每个文件主要拥有 3 个时间参数（通过 stat 命令进行查看），分别是文件的访问时间、数据修改时间以及状态修改时间：<br>访问时间（Access Time，简称 atime）：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变。<br>数据修改时间（Modify Time，简称 mtime）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。<br>状态修改时间（Change Time，简称 ctime）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</p>
<p><strong>语法：</strong></p>
<pre><code>touch [选项] 文件名
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li>-a：只修改文件的访问时间；</li>
<li>-c：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。</li>
<li>-d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</li>
<li>-m：只修改文件的数据修改时间。</li>
<li>-t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm。</li>
</ul>
<p>可以看到，touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是<code>不能只修改文件的状态修改时间</code>。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变（更新为操作当前文件的真正时间）。</p>
<p><strong>举例：</strong></p>
<blockquote>
<p>Example 1：touch 命令创建文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#touch bols</span><br><span class="line"># 建立名为 bols 的空文件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2：在例 1 的基础上修改文件的访问时间。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#ll --time=atime bols</span><br><span class="line"># 查看文件的访问时间</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 25 21:23 bols</span><br><span class="line"># 文件上次的访问时间为 9 月 25 号 21：23</span><br><span class="line">[root@localhost ~]#touch bols</span><br><span class="line">[root@localhost ~]#ll --time=atime bols</span><br><span class="line">-rw-r--r-- 1 root root 0 May 15 16:36 bols</span><br><span class="line"># 而如果文件已经存在，则也不会报错，只是会修改文件的访问时间。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 3：修改 bols 文件的 atime 和 mtime。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch -d &quot;2017-05-04 15:44&quot; bols</span><br><span class="line">[root@localhost ~]# ll bols; ll --time=atime bols; ll --time=ctime bols</span><br><span class="line">-rw-r--r-- 1 root root 0 May 4 2017 bols</span><br><span class="line">-rw-r--r-- 1 root root 0 May 4 2017 bols</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 25 21:40 bols</span><br><span class="line"># ctime不会变为设定时间，但更新为当前服务器的时间</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux简介以及32位与64位操作系统</title>
    <url>/2017/03/16/linux_introduction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Linux操作系统简介"><a href="#Linux操作系统简介" class="headerlink" title="Linux操作系统简介"></a>Linux操作系统简介</h2><p><a href="https://baike.baidu.com/item/Linux/27050?fr=aladdin">Linux</a>，全称GNU/Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h2 id="常见Linux发行版本"><a href="#常见Linux发行版本" class="headerlink" title="常见Linux发行版本"></a>常见Linux发行版本</h2><p>从技术上来说，李纳斯•托瓦兹开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p>
<p>在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以Linux为核心的操作系统软件包”。</p>
<p>Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层（由发行商整合开发的应用）才有所体现。</p>
<p><strong>Linux 的发行版本可以大体分为两类：</strong></p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表；</li>
<li>社区组织维护的发行版本，以 Debian 为代表。</li>
</ul>
<p><strong>Linux 发行版本的选择：</strong><br>Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议：<br>如果你需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议你选择 CentOS 或 RHEL。<br>如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。<br>如果你想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。<br>如果你对系统稳定性要求很高，则可以考虑 FreeBSD。<br>如果你需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。</p>
<h2 id="32位与64位操作系统的区别"><a href="#32位与64位操作系统的区别" class="headerlink" title="32位与64位操作系统的区别"></a>32位与64位操作系统的区别</h2><p><strong><code>操作系统</code></strong> （英语：operating system，缩写作 OS）是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p>
<p><strong><code>中央处理器</code></strong> （<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/284033?fromtitle=CPU&fromid=120556&fr=aladdin">CPU</a>）是你智能设备的大脑。<br>它的任务是通过执行一系列指令来驱动你的设备，包括显示屏、触摸屏、调制解调器等，让一坨塑料金属混合物变成闪亮的智能手机或者平板电脑。<br>移动设备非常复杂，其中的处理器需要执行数百万行指令才能完成人们希望这些设备去做的事。速度和功耗对处理器来说至关重要。速度影响用户体验，功耗影响电池寿命。完美的移动设备必须有好性能以及低功耗。这就是为什么选择什么样的处理器很重要。一个超级耗电、反应迟钝的处理器会很快吸干你的电池，而一个考究的、高效的处理器给你带来高性能和长久的电池寿命。</p>
<h3 id="CPU对比"><a href="#CPU对比" class="headerlink" title="CPU对比"></a>CPU对比</h3><p>32位系统CPU一次可处理32位数据，即一次处理4个字节<br>64位系统CPU一次可处理64位数据，即一次处理8个字节。</p>
<p>通俗一点说：</p>
<ul>
<li>32位，就相当于你拥有32个工人，每次能完成32个工人的工作量</li>
<li>64位，就相当于你拥有64个工人，每次能完成64个工人的工作量</li>
</ul>
<p>总结： 由32位系统过渡到64位系统，CPU处理数据能力提升了一倍。</p>
<h3 id="寻址能力"><a href="#寻址能力" class="headerlink" title="寻址能力"></a>寻址能力</h3><p>内存中一个地址占用8bit，即一个字节，32位cpu含有32根地址线，寻址能力为2的32次方个字节，相当于4G内存（所以，如果我们装32位系统，安装8G内存实际上是没有用的）。而64位cpu理论上寻址能力为2的64次方个字节，但目前硬件还达不到这个水准，当然我们用不了这么大的内存。</p>
<p>另外，补充两点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 Byte = 8 bit （8）</span><br><span class="line">1 KB = 2^10 Byte （1024）</span><br><span class="line">1 MB = 2^10 KB （1024）</span><br><span class="line">1 GB = 2^10 MB （1024）</span><br><span class="line">1 TB = 2^10 GB （1024）</span><br></pre></td></tr></table></figure>
<p>64位系统下运行64位软件比32位系统运行32位软件要快；<br>但是，64位系统运行32位软件跟32位系统运行32位软件速度应该是一样的 。<br>总结： 64位CPU有更大的寻址能力。</p>
<h2 id="Linux内核版本命名规则"><a href="#Linux内核版本命名规则" class="headerlink" title="Linux内核版本命名规则"></a>Linux内核版本命名规则</h2><p><strong>1.有关Linux内核版本命名如下：</strong></p>
<pre><code>major.minor.patch-build.desc
</code></pre>
<p>major—–表示主版本号<br>minor—–次版本号<br>patch——对minor版本的修订次数<br>build—–编译次数<br>desc—–当前版本的特殊信息</p>
<ul>
<li>次版本号有奇数偶数之分，奇数表示开发版本，偶数表示稳定版</li>
<li>每次对内核修订一次或打一次补丁就递增版本号中的patch域</li>
<li>当对少量代码做了优化或者修改，并重新编译一次，那么就递增版本号中的build域</li>
</ul>
<p><strong>2.有关desc域</strong><br>desc即description，采用一些具有实际意义的省略字符串来描述当前内核的关键特征。常用的主要有以下几种：<br>rc—-release candidate，表示候选版本<br>smp—-symmetric multiprocessing,表示对称多处理器<br>pp—–pre-patch,表示测试版本<br>EL—-enterprise Linux ，表示企业版<br>fc—-fedora core ,表示Fedora core</p>
<hr>
<!--http://c.biancheng.net/view/710.html-->
<!--https://www.kancloud.cn/thinkphp/linux_basic/43178-->
<!--https://www.bookstack.cn/read/fasionchan-learn-linux/c01ec522d84363da.md--> 



]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
  </entry>
  <entry>
    <title>Linux ln命令：建立链接（硬链接和软链接）文件</title>
    <url>/2017/03/21/linux_command_ln/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><pre><code>软连接与硬连接：
    硬链接：通过inode进行链接，硬链接就是文件的入口，多硬链删除一个不影响，删除所有才消失，目录也不能做硬链，且不能跨分区，多个硬链接inode相同
    软连接：相当于快捷方式，链连接就是一个文本文件，文件中记录着另一个文件的位置，并指向目的位置，多个软链接inode不同。
inode和block：
    Block：实际存储数据用的。
    Inode：存储数据属性信息，包含文件大小、属主、归属、用户组、权限、文件类型、修改时间，就不包括文件名
</code></pre>
<hr>
<p>如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统（Linux 文件系统）是如何工作的。我们在前面讲解了分区的格式化就是写入文件系统，而我们的 Linux 目前使用的是 ext4 文件系统。用一张示意图来描述 ext4 文件系统</p>
<p><img src="https://996promax.oss-cn-beijing.aliyuncs.com/2021/06/2-1P92Q6130RO.jpg?x-oss-process=style/original_format" alt="ext4 文件系统示意图"></p>
<p>ext4 文件系统会把分区主要分为两大部分（暂时不提超级块）：小部分用于保存文件的 inode (i 节点）信息；剩余的大部分用于保存 block 信息。</p>
<p>inode 的默认大小为 128 Byte，用来记录文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。</p>
<p>block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息：</p>
<ul>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；</li>
</ul>
<p>了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。</p>
<h1 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h1><p>ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种：</p>
<ul>
<li>软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接：我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
</ul>
<p><strong>语法：</strong></p>
<pre><code>ln [选项] 源文件 目标文件
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li>-s：建立软链接文件。如果不加 “-s” 选项，则建立硬链接文件；</li>
<li>-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<p><strong>举例：</strong></p>
<blockquote>
<p>Example 1：创建硬链接：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch cangls</span><br><span class="line">[root@localhost ~]# ln /root/cangls /tmp</span><br><span class="line"># 建立硬链接文件，目标文件没有写文件名，会和原名一致；也就是/tmp/cangls 是硬链接文件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2：创建软链接：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch bols</span><br><span class="line">[root@localhost ~]# In -s /root/bols /tmp</span><br><span class="line"># 建立软链接文件</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）；否则软链接文件会报错。这是初学者非常容易犯的错误。</p>
]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7系统安装及Raid划分的完整流程</title>
    <url>/2017/03/16/linux_os_install_1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="一、Centos7的新特性："><a href="#一、Centos7的新特性：" class="headerlink" title="一、Centos7的新特性："></a>一、Centos7的新特性：</h1><p><strong>身份管理</strong><br>kerberos将完全兼容微软活动目录</p>
<p><strong>性能管理</strong><br>可以收集、分析系统瓶颈</p>
<p><strong>虚拟化</strong></p>
<ul>
<li>完全兼容vmwarevshpere架构</li>
<li>相比6系列，新增了虚拟I/O，可以为每台虚拟机提供了调用底层PCI 设备的接口</li>
<li>虚拟机USB3.0接口支持</li>
<li>QCOW2格式文件更好的支持快照</li>
<li>新增嵌套虚拟化支持，可以在KVM中安装配置OpenStack</li>
<li>加强了对VMWARE的技术支持，自带open-vm-tools替换vm-tools</li>
<li>完全支持最热的技术Docker</li>
</ul>
<p><strong>文件系统</strong><br>Centos7 选择XFS作为其默认的文件系统。但仍然兼容ext4。<br>XFS文件系统完全为大数据而生，单个文件系统最大可以支持到8EB大小，单个文件的大小最大可达到16T。（1EB=1024PB   1PB=1024TB）<br>可通过工具xfsdump和xfsrestore来备份和恢复xfs文件系统</p>
<p><strong>网络管理</strong><br>新增网络管理接口NMCLI</p>
<p><strong>服务管理</strong><br>使用systemctl 调用服务脚本</p>
<p><strong>RHEL7桌面</strong><br>使用最新的Gnome 3为默认桌面环境，使用最新的KDE 4.10为备选桌面环境。</p>
<p><strong>Centos7新特性总结</strong></p>
<ul>
<li>对于开发人员最大的变化是内核升级到3.10</li>
<li>对于系统管理人员最大的变化是系统及服务管理程序修改为Systemd</li>
<li>对于网络运维人员最大的变化是网络管理程序和服务修改为NetworkManager</li>
<li>对于存储工程师最大的变化是iSCSI导出服务修改为LIO kernel Target Subsystem</li>
<li>对于云计算工程师最大的喜讯是原生的支持KVM嵌套虚拟化和Docker容器虚拟化</li>
</ul>
<h1 id="二、安装方法与准备工作（U盘镜像）"><a href="#二、安装方法与准备工作（U盘镜像）" class="headerlink" title="二、安装方法与准备工作（U盘镜像）"></a>二、安装方法与准备工作（U盘镜像）</h1><h2 id="1-安装方法介绍"><a href="#1-安装方法介绍" class="headerlink" title="1. 安装方法介绍"></a>1. 安装方法介绍</h2><p>系统安装分以下两种方式：</p>
<blockquote>
<p>注：目前广泛使用<strong>U盘安装</strong>方法，光盘安装方法请简单了解即可</p>
</blockquote>
<ol>
<li><p>方法1：设置服务器光盘启动（根据服务器品牌及服务器自带的安装说明或网络查询）<br>准备工作：根据要求下载指定IOS镜像并进行刻录光盘</p>
</li>
<li><p>方法2：设置服务器U盘启动（注意事项同上）<br>准备工作：8G以上U盘、最新版UltraISO（这个要用较新版本，9.3.6以上）、CentOS6/7光盘镜像</p>
</li>
</ol>
<h2 id="2-Centos-iso-常用镜像下载地址："><a href="#2-Centos-iso-常用镜像下载地址：" class="headerlink" title="2. Centos iso 常用镜像下载地址："></a>2. Centos iso 常用镜像下载地址：</h2><ul>
<li>7.2 <a href="http://archive.kernel.org/centos-vault/7.2.1511/isos/x86_64/CentOS-7-x86_64-DVD-1511.iso">http://archive.kernel.org/centos-vault/7.2.1511/isos/x86_64/CentOS-7-x86_64-DVD-1511.iso</a></li>
<li>6.5 <a href="http://vault.centos.org/6.5/isos/x86_64/">http://vault.centos.org/6.5/isos/x86_64/</a></li>
<li>其他：<ul>
<li><a href="http://isoredirect.centos.org/centos/7/isos/x86_64/">http://isoredirect.centos.org/centos/7/isos/x86_64/</a> </li>
<li><a href="http://mirror.atlantic.net/centos/7/isos/x86_64/">http://mirror.atlantic.net/centos/7/isos/x86_64/</a></li>
<li><a href="http://centos.chicago.waneq.com/7/isos/x86_64/">http://centos.chicago.waneq.com/7/isos/x86_64/</a></li>
<li><a href="http://mirror.mojohost.com/centos/7/isos/x86_64/">http://mirror.mojohost.com/centos/7/isos/x86_64/</a></li>
</ul>
</li>
</ul>
<h2 id="3-UltraISO制作U盘系统镜像"><a href="#3-UltraISO制作U盘系统镜像" class="headerlink" title="3. UltraISO制作U盘系统镜像"></a>3. UltraISO制作U盘系统镜像</h2><h3 id="3-1-准备工作："><a href="#3-1-准备工作：" class="headerlink" title="3.1 准备工作："></a>3.1 准备工作：</h3><p>8G以上U盘、最新版UltraISO<a href="https://pan.baidu.com/s/1HlZaUQC4NI_E0LXRihsHhg">点我MrGao下载</a>（密码: tza3）、CentOS6/7光盘镜像</p>
<h3 id="3-2-制作U盘启动盘"><a href="#3-2-制作U盘启动盘" class="headerlink" title="3.2 制作U盘启动盘"></a>3.2 制作U盘启动盘</h3><p>打开<code>UltraISO</code>程序，通过客户端打开iso文件，然后在下面选中我们需要安装的CentOS的镜像，双击打开。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/0.4882599760750157.png?x-oss-process=style/watermark"></p>
<p>启动—&gt;写入硬盘映像…</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/0.8140853472936764.png?x-oss-process=style/watermark"></p>
<p>硬盘驱动器：选择将要写入的U盘<br>写入方式 : USB-HDD+<br>刻录校验：最好选上</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/0.9079941702719487.png?x-oss-process=style/watermark"></p>
<p>然后点写入。点”是”之前确保U盘中的内容已经备份好</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/0.4809153498612806.png?x-oss-process=style/watermark"></p>
<p>开始写入硬盘映像，可能需要几分钟，耐心等待哦。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/0.3567575665802749.png?x-oss-process=style/watermark"></p>
<p>到这一步就是成功了，点返回。</p>
<h1 id="三、Centos7版本安装"><a href="#三、Centos7版本安装" class="headerlink" title="三、Centos7版本安装"></a>三、Centos7版本安装</h1><h2 id="3-1-raid划分"><a href="#3-1-raid划分" class="headerlink" title="3.1 raid划分"></a>3.1 raid划分</h2><blockquote>
<p>Raid的几种类型：关于raid的知识，请自行度娘补充吧</p>
</blockquote>
<h3 id="3-1-1-清理历史raid阵列："><a href="#3-1-1-清理历史raid阵列：" class="headerlink" title="3.1.1 清理历史raid阵列："></a>3.1.1 清理历史raid阵列：</h3><p>开机Ctrl+R，直接进入RAID界面，初始界面会显示服务器所有的磁盘信息，如果做过RAID，使用“↑”移动到最上端，选中磁盘组按F2选择“Clear Config”删除RAID阵列；</p>
<p>最终显示下图效果：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/1a16e70fe-aa4c-44c2-8441-fb351c615d33.jpg?x-oss-process=style/watermark"></p>
<h3 id="3-1-2-raid-划分"><a href="#3-1-2-raid-划分" class="headerlink" title="3.1.2 raid 划分"></a>3.1.2 raid 划分</h3><p>选中最上端的磁盘设备，按“F2”，进入下图状态，再次选择“Create New VD”，回车进行磁盘Raid绑定</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/2f56e37c2-af7e-4951-80cf-61aff3399b07.jpg?x-oss-process=style/watermark"></p>
<p>左上方使用”上下“键选择Raid模式，右侧使用“空格”选择绑定该组Raid的磁盘</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/34ebefef6-474c-4a7c-969c-aa698dbc78c3.jpg?x-oss-process=style/watermark"></p>
<p>左下角显示绑定完Raid后，核对磁盘容量，然后点击OK完成，如下图：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/d7880f02-47f9-4901-843f-8402e0b7bace.jpg?x-oss-process=style/watermark"></p>
<p>绑定完Raid后，选中磁盘组，按F2，选择快速格式化，如下图：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/54d249f6d-2afb-466a-9ac7-88729d1d9a3f.jpg?x-oss-process=style/watermark"></p>
<p>划分完成后，可以看到你已经进行划分的raid类型，确认无误，按ESC推出，根据提示按Ctrl+Alt+DEL保存配置重启：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/6691194.jpg?x-oss-process=style/watermark"></p>
<h2 id="3-2-如何选用U盘启动"><a href="#3-2-如何选用U盘启动" class="headerlink" title="3.2 如何选用U盘启动"></a>3.2 如何选用U盘启动</h2><blockquote>
<p>注：这里特指DELL服务器，其他品牌可能略有差异</p>
</blockquote>
<p>开机按F11进入，启动BIOS Boot Manager</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/ac5bfadb2-a9d8-4b96-bed8-9ccf46cbba17.jpg?x-oss-process=style/watermark"></p>
<p>选择你的USB启动盘，按Enter</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/b51d9fe71-72e6-423e-9e4f-fc9167c8e087.jpg?x-oss-process=style/watermark"></p>
<h2 id="3-3-系统安装过程"><a href="#3-3-系统安装过程" class="headerlink" title="3.3 系统安装过程"></a>3.3 系统安装过程</h2><blockquote>
<p>注意：这里的安装过程，是很早之前通过vmware整理的，只为你提供大致流程</p>
</blockquote>
<p><strong>1）</strong>选择Install CentOS 7，然后等。。成功引导系统后，会出现下面的界面</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/e0c5b9dc-05f4-418b-b358-323805df87ff.png?x-oss-process=style/watermark"></p>
<p><strong>2）</strong>选择语言<br>注：生产服务器建议安装英文版本，单击继续按钮</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/852d9dca-46e8-4df6-8d1d-f20dd95632e8.png?x-oss-process=style/watermark"></p>
<p><strong>3）</strong>日期和时间:<br>注：这里设置为国内使用的时区-东八区 亚洲上海，点击左上角Done完成设置。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/ee3947d7-0f76-43d0-8eca-58caedf16fef.png?x-oss-process=style/watermark"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/433a4787-7b63-4782-be19-f06c78217707.jpg?x-oss-process=style/watermark"></p>
<p><strong>4）</strong>安全设置（可忽略）</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/7c06a199-5a60-4927-9e6d-51487e3f34a6.png?x-oss-process=style/watermark"></p>
<p>选择default（默认的）策略就可以，通过<code>Select profile</code>进行选择，单击完成即可 </p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/dd16cc3f-2eb7-4e50-973f-408367b60a75.png?x-oss-process=style/watermark"></p>
<blockquote>
<p><strong>安全策略说明</strong>：</p>
</blockquote>
<pre><code>Default #默认策略
隐式XCCDF概要文件。通常情况下,默认不包含规则

Standard System Security Profile #---标准系统安全性配置文件
这个概要文件包含规则,以确保标准安全级的CenOS Linux 7系统

Draft PCI-DSS v3 Control Baseline for CentOS Linux 7 #---草案PCI-DSS v3控制基线Linux CentOS 7
这是一个概要草案PCI-DSS v3

CentOS Profile for Cloud Providers (CPCP) #---云提供商CentOS概要(CPCP)
这是一个SCAP概要草案CentOS云提供商

Common Profile for General-Purpose Systems #---常见的通用概要文件系统
这个概要文件包含项目普遍通用的桌面和服务器安装

Pre-release Draft STIG for CentOS Linux 7 Server #---CentOS7的预发布草案
这个概要文件在国防部正在开发共识模型成为STIG配合DISA无线光通信
</code></pre>
<p><strong>5）</strong>安装源选择</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/af558643-d248-4b3e-927e-5a7d3257fa91.png?x-oss-process=style/watermark"></p>
<p>单击验证（可选步骤），验证光盘或镜像是否完整，防止安装过程出现软件包不完整，导致无法安装</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/07b31fef-3015-4a4d-b3d6-c3e76b222042.jpg?x-oss-process=style/watermark"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/3df7b851-ba76-4567-a6dc-15d579baab2d.jpg?x-oss-process=style/watermark"></p>
<p><strong>6）</strong>软件包选择（根据需求，默认最小化安装即可）</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/cd6eeb91-8504-447a-a8d9-681ffc902704.jpg?x-oss-process=style/watermark"></p>
<p>注：在安装完系统后，可配置yum源再次安装需要的软件包。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/5289c537-f85e-4dbe-a6c9-8a183086a5f7.jpg?x-oss-process=style/watermark"></p>
<p><strong>7）</strong>进行磁盘分区</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/9b7c6099-fc27-412b-81b0-1be7c5bd984e.png?x-oss-process=style/watermark"></p>
<p>勾选计划安装操作系统的磁盘后，在选择下面的I will configure partitioning，然后点击左上角的Done来执行手动分区。<br>自定义分区：</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/26092595-82cf-40c8-b01a-d243db371bcb.jpg?x-oss-process=style/watermark"></p>
<p>资源分配：<br>注：boot 200M空间即可<br>Swap交换分区以服务器的物理内容x1.5倍的值设置<br>/ 可以将剩下的分区都给根“/”</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/2c351bdf-89a1-453f-9414-64b7dd8a8267.jpg?x-oss-process=style/watermark"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/876bee86-9e42-4a5e-8082-66df5796cb97.png?x-oss-process=style/watermark"></p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/92ab2934-060d-4001-bf22-f52a8b1be817.jpg?x-oss-process=style/watermark"></p>
<p><strong>8）</strong>登录用户密码设置：默认为root用户</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/3662c6a9-a2ee-40ec-8b4c-c4be6f4a4fc1.jpg?x-oss-process=style/watermark"></p>
<p><strong>9）</strong>安装预设系统及登录验证<br>CentOS 7.x这样默认的安装，是启动到命令行界面的。键入root用户与安装时设置的密码登录到系统。</p>
<p><img src="https://mrgao.oss-cn-beijing.aliyuncs.com/md/OS/76cfb0a6-9cbe-4ca5-b5b6-ab2fbea294e9.jpg?x-oss-process=style/watermark"></p>
<p>至此，CentOS7.2版本安装完成！</p>
<h1 id="四、安装后的基本环境调整"><a href="#四、安装后的基本环境调整" class="headerlink" title="四、安装后的基本环境调整:"></a>四、安装后的基本环境调整:</h1><p>最小化安装的Centos7系统并没有nano、vim、wget、curl、ifconfig、lsof命令，出网后优先安装一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install nano vim wget curl net-tools lsof zip unzip</span><br></pre></td></tr></table></figure>


<!--http://www.mamicode.com/info-detail-1257726.html-->
]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>Linux安装</tag>
      </tags>
  </entry>
  <entry>
    <title>重定向和管道</title>
    <url>/2017/04/05/linux_regular_redirect/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux中的重定向和管道"><a href="#Linux中的重定向和管道" class="headerlink" title="Linux中的重定向和管道"></a>Linux中的重定向和管道</h1><h2 id="llinux中的三种IO设备："><a href="#llinux中的三种IO设备：" class="headerlink" title="llinux中的三种IO设备："></a>llinux中的三种IO设备：</h2><ul>
<li>标准输入（STDIN）,文件描述符号为：0，默认从键盘获取输入</li>
<li>标准输出（STDOUT）,文件描述符号位：1，默认输出到显示终端</li>
<li>标准错误（STDERR）,文件描述符号为：2，默认输出到显示终端</li>
</ul>
<h2 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h2><p>IO重定向是为了改变默认输入、输出的位置：</p>
<p><strong>1. 输出重定向（标准输出STDOUT和标准错误输出STDERR）</strong><br>【&gt;】标准输出覆盖重定向<br>【&gt;&gt;】标准输出追加重定向<br>【2&gt;】标准错误输出重定向<br>【2&gt;&gt;】标准错误输出追加重定向<br>【&amp;&gt;】将标准输出和标准错误输出都同时重定向（相当于二次重定向【2&gt;&amp;1】）<br>【&amp;&gt;&gt;】将标准输出和标准错误输出都同时追加重定向<br>【set -C】命令：启用系统禁止覆盖重定向（set -C执行后，再做重定向时，重定向文件如果存在则会报错 cannot overwrite existing file）如果在启用【set -C】命令后依然需要覆盖重定向文件，可以使用【&gt;|】来强制覆盖<br>【set +C】命令：解除禁止覆盖重定向（set +C执行后，重定向文件如果存在则不会报错，直接覆盖）</p>
<p><strong>2. 输入重定向（标准输入）</strong><br>【&lt;】输入重定向；<br>【&lt;&lt;END】多行输入；(END为多行输入的结束标志)通常用于脚本创建新文件时写入固定内容</p>
<p><strong>3. 管道</strong><br>【|】把前一个命令的执行结果当做后一个命令的输入</p>
]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>通配符与正则表达式</title>
    <url>/2017/03/28/linux_regular_expression/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般用来匹配文件名的。</span><br><span class="line">匹配文件名：</span><br><span class="line">    *：代表任意字符</span><br><span class="line">    ?：代表任意单个字符</span><br><span class="line">    [ ]：匹配指定范围内的任意单个字符</span><br><span class="line">其他通配符：</span><br><span class="line">    ;：两个命令之间的分隔符</span><br><span class="line">    #：在配置文件里，注释效果</span><br><span class="line">    |：管道</span><br><span class="line">    $：变量前需要加的符号</span><br><span class="line">    /：路径分隔符，也是根</span><br><span class="line">    &gt;或1&gt;：输出重定向，覆盖原有数据</span><br><span class="line">    &gt;&gt;：追加输出重定向，追加在文件内容的尾部</span><br><span class="line">    &lt;：输入重定向（xargs，tr）</span><br><span class="line">    &lt;&lt;：追加输入重定向（cat）</span><br><span class="line">    &#x27; &#x27;：单引号，不具备变量置换功能，引号内所见即所得</span><br><span class="line">    &quot; &quot;：双引号，具备变量置换功能，解析变量后输出，不加引号相当于双引号</span><br><span class="line">    ` `：反引号，两个``中间为命令，会先执行，等价$()</span><br><span class="line">    &#123; &#125;：中间为命令去块组合或内容系列</span><br><span class="line">    ! ：逻辑运算中的“非”（not）</span><br><span class="line">    &amp;&amp;：and并且，当前一个指令执行成功时，执行后一个指令</span><br><span class="line">    ||：or或者，当前一个指令执行失败时，执行后一个指令</span><br><span class="line">    ..：代表上级目录</span><br><span class="line">    . ：代表当前目录</span><br><span class="line">    ~：当前用户的家目录</span><br><span class="line">    -：上一次的所在目录</span><br></pre></td></tr></table></figure>

<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用于处理大量字符串而定义，grep、sed、awk都支持正则表达式。</span><br><span class="line">基础正则：</span><br><span class="line">    字符匹配：</span><br><span class="line">        .：任意单个字符</span><br><span class="line">        *：任意长度/次数的字符</span><br><span class="line">        []：指定范围内的任意单个字符</span><br><span class="line">        [^]: 指定范围外的任意单个字符</span><br><span class="line">    元字符：</span><br><span class="line">        [[:upper:]]:任意大写字母</span><br><span class="line">        [[:lower:]]:任意小写字母</span><br><span class="line">        [[:digit:]]:任意一个数字</span><br><span class="line">        [[:alpha:]]:任意大小写字母</span><br><span class="line">        [[:punct:]]:标点符号</span><br><span class="line">        [[:space:]]:一个空格</span><br><span class="line">        [[:alnum:]]：任意一个字母或数字</span><br><span class="line">    行锚定：</span><br><span class="line">        ^：行首</span><br><span class="line">        $：行尾</span><br><span class="line">        ^$：空行</span><br><span class="line">        ^[[:space:]]$：空白行</span><br><span class="line">扩展正则：</span><br><span class="line">    次数匹配：</span><br><span class="line">        |：扩展正则，用于多个字符匹配</span><br><span class="line">        \+：匹配前面的字符1-任意次</span><br><span class="line">        \?：匹配前面的字符0-1次</span><br><span class="line">        \&#123;n,m\&#125;：匹配前面的字符最少n次，最多m次</span><br><span class="line">        \&#123;,m\&#125;：0-m次</span><br><span class="line">        \&#123;n,\&#125;：最少n次</span><br><span class="line">        \&#123;n\&#125;：匹配n个（次）</span><br><span class="line">    边界符：</span><br><span class="line">        \&lt;：匹配字符串从此开始</span><br><span class="line">        \&gt;：匹配字符串到此结束</span><br><span class="line">        \b或\bString\b：匹配字符串 </span><br><span class="line">        \&lt;PATTERN\&gt;：匹配包含整个单词/字符串的行</span><br><span class="line">    分组匹配（sed常用）：</span><br><span class="line">        \(First\) A \(Second\) \1或者\2</span><br><span class="line">        \(xy\(ab\)\) \1或者\2：1是匹配xy 2是匹配ab</span><br><span class="line">        [root@mod-200 ~]#echo &quot;I wanna you&quot;|sed -r &#x27;s/(.*)/\1 Shit/g&#x27;</span><br><span class="line">        I wanna you Shit</span><br><span class="line">        </span><br><span class="line">转义特殊字符（非正则）：</span><br><span class="line">        \\：匹配\</span><br><span class="line">        \s：空格</span><br><span class="line">        \n：回车</span><br><span class="line">        \^,\$,\.：匹配^ $ .</span><br></pre></td></tr></table></figure>


<hr>
<!--https://blog.51cto.com/aresxin/1602624-->  
<!--https://www.yuque.com/guiguyouwo/linux/regex.html-->  


]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos忘记root密码</title>
    <url>/2020/07/30/linux_reset_root/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="重置忘记的-root-用户密码"><a href="#重置忘记的-root-用户密码" class="headerlink" title="重置忘记的 root 用户密码"></a><a href="https://wiki.centos.org/zh/TipsAndTricks/ResetRootPassword">重置忘记的 root 用户密码</a></h2><p>如果你忘记了 root 的密码，可以按照如下方法重新设置一个：</p>
<p><strong>CentOS-6 指引（亦适用于 CentOS 5）:</strong></p>
<p>在 GRUB 阶段中断开机程序，当你看到一个含有 Booting CentOS (2.6.32-…) in X seconds 的选单时，利用以下步骤进入 runlevel 1，也就是单用户模式。</p>
<ul>
<li>按 Esc 键来中断 GRUB，接著输入 “a” 来添加内容到内核参数</li>
<li>按 Backspace 删除 “rhgb quiet” 的内容（假如存在的话）</li>
<li>增加一个空格，然后输入 1 字</li>
<li>按 Enter 开机<br>这将会提供给你一个不需登录的 root 指令壳。此时你可以使用 passwd 指令来设置一个新的 root 用户口令。</li>
</ul>
<p><strong>CentOS-7 及 CentOS-8 请遵照上游的指引：</strong> <a href="https://www.redhat.com/sysadmin/recover-root-passwd">https://www.redhat.com/sysadmin/recover-root-passwd</a></p>
<p>如果 SELinux 的模式是 enforcing 而上游的指引有所指示，别忘了在事后重新标签你的文件系统，否则你将不能登录，直至你重新开机，重复上述步骤并进行重新标签</p>
<!--https://blog.csdn.net/m1585761297/article/details/80017269-->
]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>Linux安装</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2018/04/21/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>前言：  </p>
</blockquote>
<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown语法主要分为如下几大部分： <strong>标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号`</strong></p>
<h1 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>文章内容较多时，可以用标题分段，在想要设置为标题的文字前面加#来表示。<br>一个#是一级标题，二个#是二级标题，以此类推。可表示1-6级标题。<br>标准格式一般在#后跟个空格在写标题，如”# 社会”。</p>
<p><strong>示例</strong>：  </p>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<hr>
<h2 id="段落-换行"><a href="#段落-换行" class="headerlink" title="段落/换行"></a>段落/换行</h2><p>如果另起一行，只需在当前行结尾加 2 个空格<br>若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。</p>
<hr>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><pre><code>&amp;nbsp;
</code></pre>
<hr>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p><strong>示例</strong>：</p>
<pre><code>**粗体**
__粗体__
_斜体_
</code></pre>
<p><strong>效果</strong>：</p>
<blockquote>
<p><strong>粗体</strong><br><strong>粗体</strong><br><em>斜体</em></p>
</blockquote>
<hr>
<h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用<code>(```)</code> 包裹一段代码，并指定一种语言</p>
<pre><code>#```bash
#void main()
#&#123;
#    printf(&quot;Hello, Markdown.&quot;);
#&#125;
#```  
</code></pre>
<p>也可以使用 4 空格缩进，再贴上代码，实现相同的的效果</p>
<pre><code>    void main()
    &#123;
        printf(&quot;Hello, Markdown.&quot;);
    &#125;
</code></pre>
<p>如你不需要代码高亮，可以用下面的方法禁用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#```nohighlight</span><br><span class="line">#    </span><br><span class="line">#```  </span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：需要和普通段落之间存在空行。</p>
<hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>无序列表</strong>：</p>
<pre><code>- 列表文本前使用 [减号+空格]
+ 列表文本前使用 [加号+空格]
* 列表文本前使用 [星号+空格]
</code></pre>
<p><strong>有序列表</strong>：</p>
<pre><code>1. 列表前使用 [数字+&quot;.&quot;+空格]
3. 我们会自动帮你添加数字
1. 不用担心数字编号，显示的时候会自动排序
</code></pre>
<p><strong>列表嵌套</strong>:</p>
<pre><code>1. 列出所有元素：
    - 无序列表元素 A
        1. 元素 A 的有序子列表
    - 前面加四个空格
2. 列表里的多段换行：
    前面必须加四个空格，
    这样换行，整体的格式不会乱
3. 列表里引用：

    &gt; 前面空一行
    &gt; 仍然需要在 &gt; 前面加四个空格

4. 列表里代码段：
    
    前面四个空格，之后按代码语法 ``` 书写
    或者直接空八个，引入代码块  
</code></pre>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>普通引用</strong>：</p>
<pre><code>&gt; 引用文本前使用 [大于号+空格]
&gt; 新起一行
</code></pre>
<p><strong>引用里嵌套引用</strong>：</p>
<pre><code>&gt; 最外层引用
&gt; &gt; 多一个 &gt; 嵌套一层引用
&gt; &gt; &gt; 可以嵌套很多层
</code></pre>
<p><strong>引用里嵌套列表</strong>：</p>
<pre><code>&gt; - 这是引用里嵌套的一个列表
&gt; - 还可以有子列表
&gt; * 子列表需要从 - 之后延后四个空格开始
</code></pre>
<hr>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>分割线最常使用就是三个或以上<em>，还可以使用-和_。例：”</em> * * “ or “- - -“、”_ _ _”<br><strong>示例</strong>：</p>
<pre><code>***
* * *
- - -
_ _ _
</code></pre>
<p><strong>效果</strong>：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><strong>示例</strong>：</p>
<pre><code>~~删除线~~
</code></pre>
<p><strong>效果</strong>：</p>
<blockquote>
<p><del>删除线</del></p>
</blockquote>
<hr>
<h2 id="文字超链接"><a href="#文字超链接" class="headerlink" title="文字超链接"></a>文字超链接</h2><p><strong>示例</strong>：</p>
<blockquote>
<p>[孙红雷的博客](<a href="https://www.cnblogs.com/sunhongleibibi/">https://www.cnblogs.com/sunhongleibibi/</a>)</p>
</blockquote>
<p><strong>效果</strong>：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/sunhongleibibi/">孙红雷的博客</a></p>
</blockquote>
<hr>
<h2 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h2><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个！。</p>
<blockquote>
<p>![自定义名称](imageurl)</p>
</blockquote>
<h2 id="图片超链接："><a href="#图片超链接：" class="headerlink" title="图片超链接："></a>图片超链接：</h2><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[![alt text](http://path/to/img.jpg &quot;title&quot;)](你的链接地址)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="反义符"><a href="#反义符" class="headerlink" title="反义符"></a>反义符</h2><p>如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 _ # * 进行避免。</p>
<pre><code>\_不想这里的文本变斜体\_
\*\*不想这里的文本被加粗\*\*
</code></pre>
<hr>
<h2 id="折叠栏位"><a href="#折叠栏位" class="headerlink" title="折叠栏位"></a>折叠栏位</h2><p><strong>注</strong>：有的编辑器好像不支持，本节为扩展学习</p>
<p><strong>示例：</strong></p>
<pre><code>&lt;details&gt;
&lt;summary&gt;这里是折叠标签&lt;/summary&gt;
`这里写代码aaa`
`这里写代码bbb`
&lt;/details&gt;
</code></pre>
<p><strong>展示：</strong></p>
<details>
<summary>这里是折叠标签</summary>
`这里写代码aaa`
`这里写代码bbb`
</details>

<hr>
<h2 id="隐藏代码"><a href="#隐藏代码" class="headerlink" title="隐藏代码"></a>隐藏代码</h2><pre><code># 语法
&lt;!--隐藏--&gt;
</code></pre>
<hr>
<h1 id="二、markdowb表格"><a href="#二、markdowb表格" class="headerlink" title="二、markdowb表格"></a>二、markdowb表格</h1><h2 id="1-极简方法"><a href="#1-极简方法" class="headerlink" title="1. 极简方法"></a>1. 极简方法</h2><pre><code>name | 价格 | 数量
-|-|-
香蕉 | $1 | 5
苹果 | $1 | 6
草莓 | $1 | 7
</code></pre>
<p><strong>效果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>价格</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>香蕉</td>
<td>$1</td>
<td>5</td>
</tr>
<tr>
<td>苹果</td>
<td>$1</td>
<td>6</td>
</tr>
<tr>
<td>草莓</td>
<td>$1</td>
<td>7</td>
</tr>
</tbody></table>
<h2 id="2-简单"><a href="#2-简单" class="headerlink" title="2. 简单"></a>2. 简单</h2><pre><code>name | 111 | 222 | 333 | 444
- | :-: | :-: | :-: | -:
aaa | bbb | ccc | ddd | eee| 
fff | ggg| hhh | iii | 000|
</code></pre>
<p><strong>效果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th align="center">111</th>
<th align="center">222</th>
<th align="center">333</th>
<th align="right">444</th>
</tr>
</thead>
<tbody><tr>
<td>aaa</td>
<td align="center">bbb</td>
<td align="center">ccc</td>
<td align="center">ddd</td>
<td align="right">eee</td>
</tr>
<tr>
<td>fff</td>
<td align="center">ggg</td>
<td align="center">hhh</td>
<td align="center">iii</td>
<td align="right">000</td>
</tr>
</tbody></table>
<h2 id="3-原生方法"><a href="#3-原生方法" class="headerlink" title="3. 原生方法"></a>3. 原生方法</h2><pre><code>name | 111 | 222 | 333 | 444
:-: | :-: | :-: | :-: | :-:
aaa | bbb | ccc | ddd | eee| 
fff | ggg| hhh | iii | 000|
</code></pre>
<p><strong>效果</strong>：</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">111</th>
<th align="center">222</th>
<th align="center">333</th>
<th align="center">444</th>
</tr>
</thead>
<tbody><tr>
<td align="center">aaa</td>
<td align="center">bbb</td>
<td align="center">ccc</td>
<td align="center">ddd</td>
<td align="center">eee</td>
</tr>
<tr>
<td align="center">fff</td>
<td align="center">ggg</td>
<td align="center">hhh</td>
<td align="center">iii</td>
<td align="center">000</td>
</tr>
</tbody></table>
<h2 id="4-语法说明"><a href="#4-语法说明" class="headerlink" title="4. 语法说明"></a>4. 语法说明</h2><p>  简单方法虽然是稍微简单了些，但是前后因为没有格式所以第一列和最后一列没有居中，对于极简方式来说还相当繁琐。极简方式简单，但是都是左对齐。原生方式格式更美观。个人意见强迫症患者请用原生方式，其他请随意。</p>
<ul>
<li>|、-、:之间的多余空格会被忽略，不影响布局。</li>
<li>默认标题栏居中对齐，内容居左对齐。</li>
<li>-:表示内容和标题栏居右对齐，:-表示内容和标题栏居左对齐，:-:表示内容和标题栏居中对齐。</li>
<li>内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少有一个</li>
</ul>
<p>&nbsp;</p>
<!--  **参考文档**：  -->
<!--  https://www.w3cschool.cn/markdownyfsm/  -->
<!--  https://segmentfault.com/markdown/  -->

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Go module导入本地包</title>
    <url>/2020/01/31/%E4%BD%BF%E7%94%A8Go_module%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>go module是<code>Go1.11版本之后</code>官方推出的版本管理工具，并且从<code>Go1.13</code>版本开始，go module将是Go语言默认的依赖管理工具。到今天<code>Go1.14</code>版本推出之后<code>Go modules</code>功能已经被正式推荐在生产环境下使用了。</p>
<h2 id="1-1-前提"><a href="#1-1-前提" class="headerlink" title="1.1 前提"></a>1.1 前提</h2><p>假设我们现在有<code>moduledemo</code>和<code>mypackage</code>两个包，其中<code>moduledemo</code>包中会导入<code>mypackage</code>包并使用它的<code>New</code>方法。<br>mypackage/mypackage.go内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package mypackage</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func New()&#123;</span><br><span class="line">    fmt.Println(&quot;mypackage.New&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在分两种情况讨论：</p>
<h2 id="1-2-在同一个项目下"><a href="#1-2-在同一个项目下" class="headerlink" title="1.2 在同一个项目下"></a>1.2 在同一个项目下</h2><p><code>注意</code>：在一个项目（project）下我们是可以定义多个包（package）的。</p>
<h3 id="1-2-1-目录结构"><a href="#1-2-1-目录结构" class="headerlink" title="1.2.1 目录结构"></a>1.2.1 目录结构</h3><p>现在的情况是，我们在<code>moduledemo/main.go</code>中调用了<code>mypackage</code>这个包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">moduledemo</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-导入包"><a href="#1-2-2-导入包" class="headerlink" title="1.2.2 导入包"></a>1.2.2 导入包</h3><p>这个时候，我们需要在<code>moduledemo/go.mod</code>中按如下定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure>
<p>然后在<code>moduledemo/main.go</code>中按如下方式导入<code>mypackage</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;moduledemo/mypackage&quot;  // 导入同一项目下的mypackage包</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    mypackage.New()</span><br><span class="line">    fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-栗子"><a href="#1-2-3-栗子" class="headerlink" title="1.2.3 栗子"></a>1.2.3 栗子</h3><p>举一反三，假设我们现在有文件目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└── bubble</span><br><span class="line">    ├── dao</span><br><span class="line">    │   └── mysql.go</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── main.go</span><br></pre></td></tr></table></figure>

<p>其中<code>bubble/go.mod</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module github.com/q1mi/bubble</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure>

<p><code>bubble/dao/mysql.go</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package dao</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func New()&#123;</span><br><span class="line">    fmt.Println(&quot;mypackage.New&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bubble/main.go</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;github.com/q1mi/bubble/dao&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    dao.New()</span><br><span class="line">    fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-不在同一个项目下"><a href="#1-3-不在同一个项目下" class="headerlink" title="1.3 不在同一个项目下"></a>1.3 不在同一个项目下</h2><h3 id="1-3-1-目录结构"><a href="#1-3-1-目录结构" class="headerlink" title="1.3.1 目录结构"></a>1.3.1 目录结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── moduledemo</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-导入包"><a href="#1-3-2-导入包" class="headerlink" title="1.3.2 导入包"></a>1.3.2 导入包</h3><p>这个时候，<code>mypackage</code>也需要进行module初始化，即拥有一个属于自己的<code>go.mod</code>文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module mypackage</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>moduledemo/main.go</code>中按如下方式导入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;mypackage&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    mypackage.New()</span><br><span class="line">    fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p>
<p>在调用方也就是<code>moduledemo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>mypackage</code>这个包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require &quot;mypackage&quot; v0.0.0</span><br><span class="line">replace &quot;mypackage&quot; =&gt; &quot;../mypackage&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-举个例子"><a href="#1-3-3-举个例子" class="headerlink" title="1.3.3 举个例子"></a>1.3.3 举个例子</h3><p>最后我们再举个例子巩固下上面的内容。</p>
<p>我们现在有文件目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── p1</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── p2</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── p2.go</span><br></pre></td></tr></table></figure>
<p><code>p1/main.go</code>中想要导入p2.go中定义的函数。</p>
<p><code>p2/go.mod</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module liwenzhou.com/q1mi/p2</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure>

<p><code>p1/main.go</code>中按如下方式导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;liwenzhou.com/q1mi/p2&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    p2.New()</span><br><span class="line">    fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我并没有把<code>liwenzhou.com/q1mi/p2</code>这个包上传到<code>liwenzhou.com</code>这个网站，我们只是想导入本地的包，这个时候就需要用到<code>replace</code>这个指令了。</p>
<p><code>p1/go.mod</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module github.com/q1mi/p1</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require &quot;liwenzhou.com/q1mi/p2&quot; v0.0.0</span><br><span class="line">replace &quot;liwenzhou.com/q1mi/p2&quot; =&gt; &quot;../p2&quot;</span><br></pre></td></tr></table></figure>
<p>此时，我们就可以正常编译p1这个项目了。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
</search>
